[[{"l":"Kyu-Hwan Shim","p":["Undergraduate student at Sogang University, studying Computer Science & Engineering.","My primary research goal is to develop an Human Centered AI to augment human lifestyles. I'm focusuing on studying mathematics and Deep Learning to make my skills go beyond the fundamentals and take root deeply. Nowadays i'm interested in understanding human explanations for designing AI explanations.","Currently, I'm working as a research & operating officer at OCONNECT, based on UNIST Startup. We create new products that anyone can relate to, but have easily passed, and solve the inconvenience of the underprivileged. we've developing OneStep, which is easy to plug in everywhere, everytime, anyhow."]},{"l":"Research Area","p":["My research focuses on designing a Human Centered AI system"]},{"l":"Featured Project","p":["TBA"]},{"l":"Education"},{"i":"bs--sogang-u-2019--2023","l":"B.S. @ Sogang U. 2019 ~ 2023","p":["Major in Computer Science, Deep interest in Mathematics"]},{"i":"high-school-diploma--chungnam-science-high-school","l":"High School Diploma, @ Chungnam Science High School","p":["2016 - 2018","The Informatica, Informatics student research group"]},{"l":"Military Service"},{"l":"Government Issued FIreFighter","p":["Yeongdong-gun, Chungcheongbuk-do"]},{"l":"Scholarships","p":["Alumni Scholarship, Sogang U. Alumni :: 2020","1-semester full scholarship from Sogang U. Alumni","Albatross Scholarship, Sogang U. :: 2019","1-year full scholarship for freshman who passed the application of Albatross Specialist Decision","KAIST Scholarship, Chungnam Science HS. :: 2018","from KAIST emeritus professor","MyungHak Scholarship, Chungnam Science HS. :: 2016","Myunghak scholarship"]},{"l":"Research Experience"},{"l":"Work Experience"},{"i":"oconnect-as-cheif-research-officer-201903--present","l":"OCONNECT as Cheif Research Officer (2019.03 ~ Present)","p":["UNIST UNISPART","with friends","OX Tab"]},{"l":"Contact","p":["Facebook","Instagram","LinkedIn","GitHub","Google Scholar"]}],[{"l":"Algorithm","p":["2학년 1학기까지 습득한 C/C++ 프로그래밍 능력과 자료구조 이론의 이해 및 구현 능력을 바탕으로, 컴퓨터를 통한 추상적인 문제의 효과적인 해결에 기초가 되는 알고리즘의 설계/분석/구현 기법을 익힘을 목표로 한다.","이를 위하여,","① 문제 분석/풀이 기법 도출/풀이 기법의 비용 분석 ß 주요 내용② C/C++ 언어를 통한 자신의 풀이 기법의 최적의 구현,③ 자신의 소프트웨어 구현물에 대한 분석 과정에 대하여 익히도록 한다"]},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Algorithm에 대한 정의와 complexity와 computability 개념에 대한 이해","Asymptotic analysis of time/space complexity 개념에 대한 이해","Worst-case versus average-case","Recursion 개념의 활용","(Mathematical induction을 통한) algorithm correctness 증명 능력","Dynamic set의 표현 및 응용 능력","Priority queue 구조","Disjoint set 구조","Divide-and-conquer 기법에 대한 이해 및 응용 능력","Sorting 방법에 대한 이해 및 구현 기법 습득","Dynamic programming 기법에 대한 이해 및 응용 능력","Greedy approach에 대한 이해 및 응용 능력","Graph 구조 표현 기법 구현 및 관련 알고리즘 응용 능력","Intractable Problem과 근사 알고리즘에 대한 이해 (희망 사항)"]},{"i":"예상-진도-2020학년도-2학기","l":"예상 진도 (2020학년도 2학기)","p":["W1: 9/1, 9/3 Introduction to Design and Analysis of Algorithm","W2: 9/8, 9/10 Priority Queues and Applications (Review)","W3: 9/15, 9/17 Practice of Complexity Analysis through Example Problems","W4: 9/22, 9/24 Divide-and-Conquer Techniques","W5: 9/29, 10/1추석 Divide-and-Conquer Techniques and Sorting","W6: 10/6, 10/8 Dynamic Programming Techniques","W7: 10/13, 10/15 Dynamic Programming and Applications","W8: 10/19 ~ 10/23 정확한 시험 시간은 추후 공지 예정 MIDTERM","W9: 10/27, 10/29 Greedy Techniques","W10: 11/3, 11/5 Greedy Techniques and Scheduling Algorithms","W11: 11/10, 11/12 Introduction to Graph Data Structures","W12: 11/17, 11/19 Graph Algorithms and Applications I","W13: 11/24, 11/26 Graph Algorithms and Applications II","W14: 12/1, 12/3 Introduction to NP-Completeness","W15: 12/8, 12/10 Intractable Problems and Approximation Algorithms 또는 진도 보충"]},{"l":"교재 및 참고 도서","p":["8 적절한 교재를 선택하여 관련된 내용을 자세하게 읽기를 권장함","Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983.","Aho, J. Hopcroft, and J. Ullman, Design and Analysis of Algorithms, Addison-Wesley, 1974.","Baase and A. Van Gelder, Computer Algorithms: Introduction to Design and Analysis, Addison Wesley, 2000.","Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009.","Dasgupta et al., Algorithms, McGraw-Hill Education, 2006.","Horowitz et al., Fundamentals of Data Structures in C, Computer Science Press, 1993.","Horowitz, S. Sahni and S. Rajasekaran, Computer Algorithms/C++, Computer Science Press, 1997.","Kleinberg and E. Tardos, Algorithm Design, Addison Wesley, 2005.","Levitin, Introduction to the Design and Analysis of Algorithms, Addison Wesley, 2003.","Neapolitan, Foundations of Algorithms (5th ed.), Jones & Bartlett, 2015.","Roughgarden, Algorithms Illuminated, Part 1~3, Soundlikeyourself Publishing, 2018.","Sedgewick and K. Wayne, Algorithms (4th ed.), Addison-Wesley, 2011.","Sedgewick, Algorithms in C: Parts 1-4 (3rd ed), Addison-Wesley, 1998.","Sedgewick, Algorithms in C: Parts 5 (3rd ed), Addison-Wesley, 2002.","Skiena, The Algorithm Design Manual (2nd ed.), Springer, 2008.","Weiss, Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997."]},{"l":"강의 자료 순서","p":["[주제 1] Introduction to Algorithms and Complexity","[주제 2] Heap-based Priority Queues and Heap Sort (Review)","[주제 3] Divide-and-Conquer Techniques and Sorting Techniques","[주제 4] Dynamic Programming","[주제 5] Greedy Methods","[주제 6] Graph Algorithms","[주제 7] Intractable Problems and Approximation Algorithms","[주제 8] More on Priority Queues and Hashing"]},{"l":"목표"}],[{"i":"1-intro--complexity","l":"1. Intro & Complexity"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Algorithm에 대한 정의와 complexity와 computability 개념에 대한 이해","Asymptotic analysis of time/space complexity 개념에 대한 이해","Worst-case versus average-case","Recursion 개념의 활용","(Mathematical induction을 통한) algorithm correctness 증명 능력"]}],[{"i":"10-computational-thinking","l":"1.0. Computational Thinking"},{"l":"Definition of computational thinking","p":["The thought processes involved in(i) formulating a problem and(ii) expressing its solutions in such a way that a computer --human or machine- can effectively carry out.","Problem formulation (abstraction)","Solution expression (automation)","Solution execution & evaluation (analyses)"]},{"l":"Characteristics of computational thinking","p":["Formulating problems in a way that enables us to use a computer and other tools to help solve them","Logically organizing and analyzing data → Data structure","Representing data though abstractions such as models and simulations → Data Structure","Automating solutions through algorithmic thinking (a series of ordered steps) → Algorithm","Identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and effective combination of steps and resources → time and space complexity","Generalizing and transferring the problem solving process to a wide variety of problems"]},{"l":"Problem Solving in Computer Science and Engineering","p":["문 제 (Problem) \\rightarrow 해 (Solution)","Problem : 가상 현실, 문서작성, 홈뱅킹, 인터넷 신문, 문서 번역, 회로 설계, 유전자 분석, 무인 자동차, 온라인 게임, 비디오 편집, 자료 검색, 영화 제작, 음성 인식, 가상 수술, 건축 설계, 기상 예측, 주가 예측, 인공 지능, 대용량 과학 계산, …"]},{"l":"Problem Solving Pipeline"},{"l":"도강 문제","p":["한 어부(M)가 늑대(W), 염소(G), 양배추(C)를 강 한 쪽에서 다른 쪽으로 옮기려 한다. 어부가 배를 타고 강을 건널 때 어부 자신 외에 늑대, 염 소, 양배추 중 하나만 배에 가지고 갈 수가 있는데, 문제는 어부가 늑대 를 싣고 가는 동안, 염소가 양배추를 같은 쪽에 남겨두면 염소가 양배 추를 먹어버리게 되고, 양배추를 싣고 갈 때 늑대와 염소를 같은 쪽에 남겨둘 경우 늑대가 염소를 잡아 먹게 된다. 과연 어떻게 하면 어부가 가장 적은 회수로 강을 건너면서 세 가지를 모두 안전하게 옮길 수 있을까?"]},{"l":"문제 분석"},{"l":"해법 고안","p":["Graph, search, and so on → Which data structures and algorithms?","Cost, time, space, and so on → What complexities?","[연습] 이 문제에 대한 알고리즘과 시간/공간 복잡도를 컴퓨터학의 용 어를 써서 기술한다면, ???","무슨 말인지 전혀 모르겠으면 [43-080 자료구조]를 재수강한 후 이 과목을 들을 것!"]},{"i":"구현---programming-is-an-art","l":"구현 : ✓ Programming is an art!","p":["어떻게 하면 주어진 알고리즘을 가장 효과적으로 구현을 할 수 있을까?","어떻게 하면 C/C++ 를 사용하여 주어진 알고리즘을 가장 최적으로 구현할 수 있을까?","원시 코드 레벨의 측면","어셈블러 레벨의 측면","시스템 레벨의 측면","기타","✓ 과연 내가 http://acm.uva.es/problemset/에 있는 문제들을 스스로 “문제 분석 \\rightarrow 해법 고안 \\rightarrow 구현” 과정을 통하여 효과적으로 해결할 수 있을까???","Programming Challenges by S. Skiena and M. Revilla, Springer, 2003.","어떻게 하면 좋은 구현 결과를 얻을 수 있는가?","동일한 프로세서 상에서 더 빠르게","적은 메모리만 사용하게","안정적이게","구현 예","19 0.265968초 4.862961초 3.4GHz Intel Core i7 CPU"]},{"i":"data-structure--algorithm--theory-of-computation","l":"Data Structure → Algorithm → Theory of Computation","p":["어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?","[Data Structure] 주어진 추상적인 문제를 어떠한 자료 구조를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?","[Algorithm] 주어진 추상적인 문제를 어떠한 알고리즘을 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까?","[Complexity] 과연 컴퓨터가 주어진 문제를 효율적으로 해결할 수 있을까 ?","[Computability] 과연 컴퓨터가 세상의 모든 문제를 해결할 수 있을까?","✓ 이 과목에서는 [CSE3080 자료구조] 과목에 이어, 1번과 2번을 집중적으로 살펴보 고, 3번 문제에 대하여 어느 정도 살펴볼 예정임.","4번 문제는 [CSE3085 자동장치이론] 과목에서 다룸."]}],[{"l":"1. How to think and solve problems with computer"},{"i":"data-structurealgorithmtheory-of-computation","l":"Data Structure→Algorithm→Theory of Computation","p":["어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?","[Data Structure] 주어진 추상적인 문제를 어떠한 자료 구조 를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?","[Algorithm] 주어진 추상적인 문제를 어떠한 알고리즘을 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까","[Complexity] 과연 컴퓨터가 주어진 문제를 효율적으로 해결할 수 있을까 ?","[Computability] 과연 컴퓨터가 세상의 모든 문제를 해결 할 수 있을까?","Data Structure & Algorithm \\rightarrow 1, 2, 3","Automata Theory \\rightarrow 4"]},{"l":"2. Def. of Algorithm"},{"l":"Definition of Algorithm","p":["각 지침은 모두 명확하며, 애매하게 쓰여 있지 않다.","손으로 풀 수 있을 만큼 효과적이어야 한다.","외부로부터 0개 이상의 수량이 입력으로서 들어온다.","제한된 수의 단계 후 종료된다.","하나 이상의 결과값이 수행된다.","An algorithm is a finite set of instructions that, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:","At least one quantity is produced.","Definiteness.","Each instruction is clear and unambiguous.","Effectiveness.","Every instruction must be basic enough to be carried out, in principle, by a person using only pencil and paper.","Finiteness.","from [Horowitz 1.2]","If we trace out the instructions of an algorithm, then for all cases, the algorithm terminates after a finite number of steps.","Input.","it also must be feasible. 또한 실현 가능하여야 한다.","It is not enough that each operation be definite as in (3);","Output.","Zero or more quantities from the outside."]},{"i":"thoughts-on-4-finiteness-computability","l":"Thoughts on 4) Finiteness: [Computability]","p":["Problem ( Post’s correspondence problem 포스트 대응 문제)","결정 불가능한 결정 문제의 예시, 1946년 emil post 에 의해 고안","Consider a finite set P of ordered pairs of nonempty strings such as P = \\{(a, ab), (b, ca), (ca, a), (abc, c)\\}","A match of P is any string w such that, for some m > 0 and some pairs (u_1, v_1), (u_2, v_2), ..., (u_m, v_m) \\in P, w = u_1 u_2...u_m = v_1 v_2...v_m.","Design an algorithm that determine, given P, whether P has a match.","Cheolsu’s algorithm","Can this be regarded as an algorithm?"]},{"i":"thoughts-on-efficiency-complexity","l":"Thoughts on Efficiency: [Complexity]","p":["An algorithm is regarded as efficient or good if there exist a polynomial P(n) such that the time required for solving any instance of size n is bounded above by P(n).","NP-Complete problems:","Nobody has found so far any good algorithm for any problem in this class.","It has been proved that if a good algorithm exists for some algorithm in this class, then a good algorithm exists for all NP-Complete Problem.","Examples","Suppose a CD-ROM can store up to 720MBytes of data. You have a sequence of n files of sizes s_1, s_2, ..., s_n Mbytes, to dump into backup CDs. What is the minimum number of necessary CDs to store all the files?","Consider n tasks to be executed on CPU. All the tasks must be finished within the time requirement L (seconds). If the i-th task takes s_i seconds, and you can harness multiple processors, what would be the minimum number of processors needed to accomplish this?","Ex. L = 10, n = 6, and $(s_1, s_2, s_3, s_4, s_5, s_6) = (5, 6, 3, 7, 5, 4) $","then (5, 5), (6, 4), (7, 3)","어떻게 하면 좀 더 “효율적으로” 문제를 해결할까?"]},{"l":"Efficient Algorithm Design"},{"l":"Example 1","p":["Sequential search vs binary search","Problem: Determine whether x is in the sorted array S of n keys.","Inputs: positive integer n, sorted (nondecreasing order) arrays of keys S indexed from 0 to n - 1, a key x.","Outputs: the location of x \\in S(-1 if x \\notin S).","Sequential search: T(n) = O(n)","Binary search: T(n) = O(log n)","[From Neapolitan] The number of comparisons done by Sequential & Binary Search when x is larger than all the array items","40억 개의 element가 array에 있을 때, Sequential Search는 40억 개 항목과 비교하는 반면에 Binary Search는 단 33개의 항목만을 비교한다.","컴퓨터가 1ns에 whlie loop를 통과할 수 있다고 가정한들 Binary search는 즉각적으로 결정을 내리는 반면 Sequential Search는 4s가 걸린다.","Why is the binary search more efficient? 왜 이진검색이 더 효율적인가?"]},{"i":"example-2the-fibonacci-sequence","l":"Example 2:The Fibonacci Sequence","p":["Problem: Determine the n-th term in the Fibonacci sequence.","Inputs: a nonnegative integer n","Outputs: the nth term of the Fibonacci sequence.","f_0 = 0 f_1 = 1 f_n = f_{n-1} + f_{n-2} for n \\geq 2","Recursive: $T(n) = O(2^ n) $","Iterative: T(n) = O(n)","Why is the iterative version more efficient?","T(n) > 2 ^{\\frac n 2} for n \\geq 2","Mathematical induction을 써서 증명해볼 것!","Linear versus exponential","[From Neapolitan] This table compares these expressions for various values of n. The execution times are based on the simplifying assumption that one term can be computed in 10^{−9} second.","The table shows the time it would take 'Iterative Algorithm' to compute the nth term on a hypothetical computer that could compute each term in a nanosecond, and it shows a lower bound on the time it would take to execute 'Iterative Algorithm'.","By the time n is 80, 'Recursive Algorithm' takes at least 18 minutes. When n is 120, it takes more than 36 years, an amount of time intolerable compared with a human life span. Even if we could build a computer one billion times as fast, 'Recursive Algorithm' would take over 40,000 years to compute the 200th term. This result can be obtained by dividing the time for the 200th term by one billion.","We see that regardless of how fast computers become, 'Recursive Algorithm' will still take an intolerable amount of time unless n is small. On the other hand, 'Iterative Algorithm' computes the nth Fibonacci term almost instantaneously.","This comparison shows why the efficiency of an algorithm remains an important consideration regardless of how fast computers become"]}],[{"i":"-big--notation","l":"O (Big O Notation)","p":["for given two functions f(n) and g(n),","g(n) = O(f(n))\\iff \\exists c \\in \\mathbb{R}, N \\in \\mathbb{N}\\quad","s.t. \\quad g(n)\\leq c\\cdot f(n)\\forall n \\geq N","then we say that : g(n) is big O of f(n)","정답 : g(n) = c_0 + c_1 n + c_2 n^2","예 : g(n) = 5 + 6 + 7n^2 \\leq 8n^2 \\quad \\forall n \\geq 8","g(n) = O(n^2)"]},{"l":"Notes for big O","p":["(Tight) upper bound","[Note 1] The big O puts an asymptotic upper bound on a function.","[Note 2] Given a cost function g(n), how do you find the proper complexity function f(n) such that g(n) = O(f(n))?","$4(log n)^ 2 + nlog n + 100n = O(nlog n) $","10^3 + 10^3n + 10^-3 n^2 = O(n^2)","2^{5n} = O(2^n)??","2^{n+5} = O(2^n)??","3(log_2 n)^2+ 0.1n = O(?)","37log n + 0.1n = O(n)","5nlog_3 n + 3(log_2 n)^2 + n + 6n^2 = O(n^2)","계산 비용이 0.01n^2 과 100n 알고리즘 중 어떤 것이 더 효율적인가?","Asymptotic analysis (from Wikipedia)","Example:","Growth Rates of Some Common Complexity Functions","If f(n) = n^2 + 3n, then as n becomes very large, the term 3n becomes insignificant compared to n^2. The function f(n) is said to be \"asymptotically equivalent to n^2, as n → ∞\". This is often written symbolically as f(n) ~ n^2, which is read as \" f(n) is asymptotic to n^2\".","n^2 + 10n = O(n^200)???","n2 + 10n = O(n^2)","Suppress lower-order terms and constant factors!","then lim_{n \\to \\infty} \\frac{n}{log_en} = lim _{n \\to \\infty} = \\infty","then lim_{n \\to \\infty} \\frac{n^2}{n} = \\infty"]},{"l":"Comparing Orders of Growth","p":["How do you compare orders of growth of two functions?","One possible way is to compute the limit of the ratio of two functions in question.","x = lim_{n \\to \\infty } \\frac{f_1(n)}{f_2(n)}","if x=0, f_1 has a smaller order of growth than f_2","if x=c, f_1 has a same order of growth than f_2","if x=\\infty, f_1 has a larer order of growth than f_2","Ex.1: log_2 n vs \\sqrt{n}","$lim_{n \\to \\infty} \\frac{\\sqrt(n)} = lim_{n \\to \\infty} \\frac{(log_2 n)'}{(\\sqrt(n))'} = lim_{n \\to \\infty} \\frac{(log_2 e)\\frac{1}}{\\sqrt\\frac{1}{2\\sqrt(n)}} = $","Ex.2: n! vs 2^n","lim_{n \\to \\infty} \\frac{ n!}{2^n} = lim_{n \\to \\infty} \\frac{\\sqrt{2 \\pi n} (\\frac {n}{e})^n}{2^n}=lim_{n \\to \\infty }\\sqrt{2 \\pi n} \\frac{({n})^n}{2^n e^n}","stirling's formula : n! \\approx \\sqrt{2 \\pi n} (\\frac {n}{e})^n"]},{"i":"-big-omega-notation","l":"\\Omega (Big Omega Notation)","p":["for two given functions f(n), g(n)","g(n) = \\Omega(f(n))\\iff\\exists c \\in \\mathbb{R} and N \\in \\mathbb{Z^+ \\cup {0}}","s.t. g(n) \\geq cf(n)\\forall n \\geq N","We say that g(n) is \\omega of f(n).","The \\Omega puts an asymptotic lower bound on a function.","Ex:","37logn+0.1n=\\Omega(n)","n^2 + 10n = \\Omega(n^2)","4(logn)^2 +nlogn+100n=\\Omega(nlogn)","n^{200} +10n=\\Omega(n^2)..."]},{"i":"-big-theta-notation","l":"\\Theta (Big Theta Notation)","p":["\\Theta(1)<\\Theta(log n)<\\Theta(n)<\\Theta(n log n)<\\Theta(n^2)<\\Theta(n^3)<\\Theta(n^j)<\\Theta(n^k)<\\Theta(a^n)<\\Theta(b^n)<\\Theta(n!)","$g(n) = \\Theta (f(n)) $ \\iff\\exists c,d \\in \\mathbb{R} and N \\in \\mathbb{Z^+ \\cup {0}} s.t. g(n) \\geq cf(n)$ \\forall n \\geq N$","$g(n) = 0.000001 \\cdot n $","37logn+0.1n=\\Theta(n)","4(logn)^2 +nlogn+100n=\\Theta(nlogn)","Ex:","for $ k>j>3$ and b>a>1","for two given functions f(n), g(n)","g(n) = \\Theta(f(n))$\\iff $ $g(n) = O(f(n)) $ and g(n) = \\Omega (f(n))","g(n) = 1000000","n^2 + 10n = \\Theta(n^2)","O(1) or O(c): constant","Ref. Neapolitan Ex. (pp.42) 19, 24, 26, 28]","that is,","The \\Theta puts an asymptotic bound on a function.","We say that g(n) is order of f(n)."]},{"i":"big-o-omega-and-order","l":"Big O, Omega, and Order","p":["Ref.[Neapolitan Chapter 1.]","Execution Times for Algorithms with the Given Time Complexities"]},{"l":"Worst-Case versus Average-Case Time Complexity","p":["= \\sum_{k=0}^{n-1} (k+1)P_k + n (1 - \\sum_{k=0}^{n-1} P_k)","$T_A (n) = \\sum_{I \\in S_n} p(I) c(I) $","참고: Quick sort 알고리즘 →","Average-case complexity","Average-Case O(n log n)","Cost for a linear search algorithm","Ex.1. n = 10^9, P_0 + P_1 + ...+ P_{10^3} = 1 so g(n) = O(1)","Ex.2. n = 10^9, P_0 + P_1 + ...+ P_{\\frac n {100} }= 1 so g(n) = O(n)","Expected value (from Wikipedia)","Find the index of a given value a in a givven array (a_0, a_1, ...,a _{n-1}). if a doesn't exist in the array return -1","g(n) = 1 \\cdot P_0 + 2 \\cdot P_1 + 3 \\cdot P_2 + ...+ n \\cdot P_{n-1} + n (1 - \\sum_{k=0}^{n-1} P_k)","let P_i be the probability such that a= a_i","let X be a random variable with a finite number of finite outcomes x_1, x_2, ..., x_k occuring with probabilities p_1, p_2, ... p_k respectively.","Problem","since the sum of all probabilities p_i is 1 (\\sum_{i=1}^{k} {p_i}=1) , the expected value is the weighted sum of the x_i values, with the p_i values being the weights","T_W (n) = max \\{ c(I)| I \\in S_n \\}","the Expectation of X is defined as : E(X) = \\sum_{i=1}^{k }{x_i p_i} = x_1p_1+ x_2 p_2 + ... + x_k p_k","then the average cost is :","Worst-case complexity","Worst-case O(n^2),"]},{"l":"Reviews"},{"l":"Summation","p":["\\sum_{i=1}^{n} \\frac 1 i \\in \\Theta(log n)","\\sum_{i=1}^{n} c^i \\in \\Theta( n \\cdot log(n)^{c+1}) for real c greater than 1","\\sum_{i=1}^{n} i = \\frac {n(n+1)} {2}","\\sum_{i=1}^{n} i^{-s} = \\prod_{p prime} \\frac {1} {1 - p^{-s}} = \\zeta(s)","\\sum_{i=1}^{n} i^2 = \\frac {n(n+1)(2n+1)} {6}","\\sum_{i=1}^{n} i^3 = (\\frac {n(n+1)} {2})^2","\\sum_{i=1}^{n} i^4 = \\frac {n(n+1)(2n+1)(3n^2+3n-1)} {30}","\\sum_{i=1}^{n} i^c \\in \\Theta(n^{c+1}) for real c greater than -1","\\sum_{i=1}^{n} i^s = \\frac {(n+1)^{s+1}} {s+1} + \\sum_{k=1}^{s} \\frac {B_k} {s-k+1} {s \\choose k} (n+1)^{s-k+1}","\\sum_{i=1}^{n} log(i)^c \\cdot i^d \\cdot b^i \\in \\Theta(n^{d} \\cdot log(n)^{c} \\cdot b^n) for nonnegative real b>1, c, d","\\sum_{i=1}^{n} log(i)^c \\cdot i^d \\in \\Theta(n^{d+1} \\cdot log(n)^{c}) for nonnegative real c, d","\\sum_{i=1}^{n} log(i)^c \\in \\Theta(n \\cdot log(n)^{c}) for nonnegative real c","\\zeta_k is the Riemann zeta function","B_k is the k^{th} Bernoulli Number.","Growth rates","Read Summation, Mathematical Series","Sums of powers"]},{"l":"Run Time Analysis","p":["(1)","(1) Matrix Addition","(2)","(3)","(3) Could this be faster?","(4)","(4) Magic square : Could this be faster?","(5)","(5) O(\\log n)","(6) \\rightarrow O(N^4)","1","10","11","12","13","14","15","16","17","18","19","2","20","21","22","23","24","25","3","4","5","6","7","8","9","time complexity. : ??= O( \\sqrt n)","time complexity. : c_0 + c_1 n + c_2 n^2 = O(n^2)","time complexity. : c( ⌊{log_2 n}⌋+1) \\cdot n^2 = O(n^2)","What is the worst-case time complexity of each loop?"]}],[{"i":"14-mss","l":"1.4. MSS","p":["최대 부분 수열의 합 Maximum Subsequence Sum"]},{"i":"maximum-subsequence-sum-mss-problem","l":"Maximum Subsequence Sum (MSS) Problem","p":["Ref.[M. Weiss, Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]","Given N(possiblly negative) A_0, A_1, ..., A_{N-1} \\in \\mathbb{Z}","find the maximum value of \\sum_{k=i}^{j} {A_k } for 0 \\leq i \\leq j \\leq N-1","for convenience, the max subseuqence sum is 0 if all the integers 're <0","Example","(-2, 11, -4, 13, -5, -2). → MSS = 20","Maximum Subarray Problem","Maximum Positive Sum Subarray Problem","Max. Sum Subsequence versus Max. Subsequence Sum"]},{"l":"Alg of Maximum Subsequence Sum","p":["길이 $n$인 정수의 수열 a_0, a_1, ..., a_{n-1} 이 입력으로 주어져 있다.","여기서 부분 수열 [i, j]라는 것은 a_i, a_{i+1}, a_{i+2}..., , a_{j} 를 말한다.","본 문제는 주어진 수열의 부분 수열의 합,즉 \\sum_{i \\leq k \\leq j} {a_k} 의 최대값을 구하는 문제이다. (이때 주어진 수열의 정수가 모두 음수이면 최대 부분 수열의 합은 0 이라고 간주한다)","예를 들어 다음과 같은 수열이 주어졌을 때,+ 31, −41, +59, +26, −53, +58, +97, −93, −23, +84 최대 부분 수열은 $[2,6]$이며 수열의 합은 187 이 된다.","이 문제는 최대 부분 수열의 합을 구하는 것이지만, 앞으로 소개할 알고리즘을 조금만 수정하면 최대 부분 수열도 쉽게 구할 수 있다.","Algorithm1 : 모든 경우의 수 찾기 - O(N^3) Algorithm2 : Sum구할 때 중복 조금 피하기 - O(N^2) Algorithm3 : Divide n Conquer - O(N log N) Algorithm4 : Dynamic Programming - O(N)","image"]},{"l":"MSS Algorithm 1","p":["Strategy","Enumerate all possibilities one at a time.","No efficiency is considered, resulting in a lot of unnecessary computation!","모든 경우의 수를 하나하나 모두 따져보는 방법.","Is this for-loop OK for you?","Time Complexity : O(N^3)","\uD835\uDC56와 관련된 반복문은 \uD835\uDC5Bn번, \uD835\uDC57와 관련된 반복문은 최대 \uD835\uDC5B번, Thissum을 구할 때 최대 \uD835\uDC5B개의 요소를 계산해야 하기에","\\sum_{i=0}^{N-1} \\sum_{j=i}^{N-1} \\sum_{k=i}^{j} 1 = \\frac{N^3 + 3N^2 + 2N}{6}","\\sum_{j=i}^{N-1}\\ (j-i+1) = \\frac{(N-i+1)(N-i)}{2}","\\sum_{k=i}^{j} 1 = j-i+1"]},{"l":"MSS Algorithm 2","p":["Strategy","Get rid of the inefficiency in the innermost for-loop. Algorithm 1보다 중복을 줄이는 방법","Notice that \\sum_{k=i}^{j } {A_k} = A_j + \\sum_{k=i}^{j-1} {A_k}","}","time complexity : O(N^2)"]},{"l":"MSS Algorithm 3","p":["Strategy","Use the Divide-and-Conquer strategy.","원 문제를 작은 문제로 나눠 풀고, 그 결과를 합쳐 문제를 해결하는 알고리즘","The maximum subsequence sum can be in one of three places.","cost : T(n) = 2T(n/2) + cn, T(1) = d","why O(N log N)?","T(n) = 2T(\\frac n 2) + cn, T(1) = d$ = 2 [2T(\\frac n {2^ 2}) + c \\frac n 2 ] + cn$= 2^2 T [ \\frac n {2^2}] + 2cn= 2^3 T [ \\frac n {2^3}] + 3cn =...= 2^i T [ \\frac n {2^i}] + icn= 2^{log_2 n} T(1) + log_2 n \\cdot cn=nT(1) + log_2 n \\cdot cn= O(n) + O(n log_2 n) = O(n log_2 n)"]},{"i":"mss-algorithm-4-kadanes-algorithm","l":"MSS Algorithm 4; Kadane’s algorithm","p":["Strategy","Use the Dynamic Programming strategy.","subsequence sum<0인 경우, 논리적으로 최대값이 될 수 없음에 착안한 전략","만약에 sum이 음수라도 무방하고 1개 이상의 원소로 구 성된 Subsequence (subarray)를 구하는 문제라면?","Time Complexity : O(n)","for i, iteration n times, and O(1) for 1 calculation","C Implementation","Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks"]},{"i":"so-why-do-we-bother-with-the-time-complexity","l":"So, why do we bother with the time complexity?"}],[{"i":"15-maximum-sum-subrectangle-in-2d-array","l":"1.5. Maximum Sum Subrectangle in 2D Array","p":["-1","-2","-4","-6","-7","[1D case] for an m * n rectangle,","\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} \\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} 1","= (\\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} 1)(\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} 1)","= { \\sum_{k=0}^{m-1}(m-k)}{\\sum_{i=0}^{n-1}{(n-i)}}","= \\frac {m(m+1)} {2} \\frac {n(n+1)} {2} = O(m^2 n^2) = O(n^4) if m=n","= max sum submatrix","0","1","2","8","9","Design an O(n^3) algorithm.","Design an O(n^4) algorithm.","Design an O(n^5) algorithm.","Design an O(n^6) algorithm.","For the case of m = n,","Given an mxn array of integers, find a subrectangle with the largest sum. (In this problem, we assume that a subrectangle is any contiguous sub-array of size 1x1 or greater located within the whole array.)","How many subrectangles are there in an mxn array?","If m = n→n","Note","Problem","What is the input size of this problem?→ (m, n)"]},{"i":"a-naive-approach","l":"A Naïve Approach","p":["For each subrectangle, find its sum.","[가정] n=m","\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} \\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} (j-i+1)(l-k+1) = \\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} {(j-i+1)} \\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} {(l-k+1)}","let A =\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} {(j-i+1)}","A = 1*n + 2*(n-1) +3(n-2) + ... + n*1= \\sum_{i=1}^{n} {i(n-i+1)} = n \\sum_{i=1}^n i - \\sum_{i=1}^n i^2 + \\sum_{i=1}^n i \\frac{1}{6} n^3","so O(\\frac{1}{36} n^6 )","Time Complexity : O(n^6)"]},{"l":"Summed Area Table","p":["Table construction: O(n^2)","Sum comparisons: O(n^4)","Time Complexity : O(n^4)"]},{"i":"maximum-sum-subrectangle-kadane-algo-based","l":"Maximum Sum Subrectangle: Kadane Algo.-Based","p":["Idea","ref. geeksforgeeks","MSS(2D)의 해당 열은 어디이건 i에서 j까지 임.","가능한 모든 (i, j) 조합에 대하여 MSS(1D)를 Kadane 알고리즘을 사용하여 찾음.","그렇게 하기 위하여, ...","C Implementation","결과는 아래와 같다."]},{"i":"mathematical-induction--proof-of-correctness","l":"Mathematical Induction & Proof of Correctness","p":["Proof by Induction","Proof of Correctness : MSS (1D)","P(j): for-loop가 j번 수행한 직후에 ThisSum 변수는 ( )값을, MaxSum 변수는 ( )값을 가지고 있다."]}],[{"l":"2. Heap"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Dynamic set의 표현 및 응용 능력","Priority queue 구조","Disjoint set 구조"]}],[{"l":"A Variety of Priority Queue Implementations","p":["[Priority Queue 1: Max(Min) Heap]","[Priority Queue 2: Min-Max Heap]","[Priority Queue 3: Heap and Hashing]","[Priority Queue 4: Deap]","[Priority Queue 5: Leftist Tree]","[Priority Queue 6: Binomial Heap]","[Priority Queue 7: Fibonacci Heap]","image"]},{"i":"job-scheduling-example-priority-queue","l":"[Job Scheduling Example: Priority Queue]","p":["Consider the following sequence of requests in an operating system:","image"]},{"l":"Requirement 1","p":["CPU executes the process with the highest priority first.","Use a heap structure – a simple max heap :)","image"]},{"l":"Requirement 2","p":["The priority of processes can be modified after they are placed in the priority queue.","This function requires locating a particular process in the heap, but the basic heap operations provide no efficient way to do it.","Employ an auxiliary data structure such as a hash table that keeps track of the location of each process in the heap structure.","Once the two requirements are satisfied, the operating system can process the following basic commands efficiently:"]}],[{"i":"22-pq1-maxmin-heap-1","l":"2.2. PQ1: Max(Min) Heap (1)","p":["ref.[Horowitz 5.6.2] [Neapolitan 7.6]","Problem","The following operations must be performed as mixed in data processing:","Store a record with a key in an arbitrary order.","Fetch the record with the current largest key.","A solution","Design a data structure that offers an efficient implementation of the following operations:","Insert an element with an arbitrary key.","Delete an element with the largest key."]},{"l":"An Array Implementation","p":["Ref. [Sedgewick 9.2]","What will be the worst-case time complexity of each operation?"]},{"i":"maxmin-heap-definitions","l":"Max(Min) Heap: Definitions"},{"l":"Definition 1","p":["[Horowitz 5.6.2] [Neapolitan 7.6]","A max(min) heap is a complete binary tree where the key value in each internal node is no smaller(larger) than the key values in its children."]},{"l":"Definition 2","p":["A binary tree has the max(min) heap property if and only if","The number of nodes of the tree is either 0 or 1, or","2 For the tree that has at least two nodes, the key in the root is no smaller(larger) than that in each child and the subtree rooted at the child has the max(min) heap property.","A max(min) heap is a complete binary tree that has the max(min) heap property.","image"]},{"l":"Brainstorming on Max Heap Operations","p":["Max Heap Example","Deletion Example 1","image","Deletion Example 2","Insertion Example","Deletion from a Max Heap","ref.[Horowitz 5.6.2]","C = log_2 n","O(log n)"]},{"i":"another-heap-implementation-min-heap","l":"Another Heap Implementation (Min Heap)","p":["ref.[Sedgewick 9.3]","What will be the worst-case time complexity of each operation?"]}],[{"i":"23-pq1-maxmin-heap-2","l":"2.3. PQ1: Max(Min) Heap (2)"},{"l":"Comparisons of Priority Queue Implementations","p":["Representation","Insertion","Deletion","Unordered array","O(1)","O(n)","Unordered linked list","Sorted array","Sorted linked list","Max heap","O(\\log n)"]},{"l":"Heap Sort in C Implementation","p":["1","10","11","115","15","19","2","26","3","4","48","5","59","6","61","7","77","8","9","주어진 정수들을 비감소 순서(non-decreasing order)대로 정렬하라.","Convert an input array of n unordered items into a max heap.","Extract the items from the heap one at a time to build an ordered array.","image image","Make a (max) heap.","max heap","Method","Name","O(n)","O(n\\log n) \\rightarrow O(n\\log n)","ordered","ref.[Horowitz 7.7] [Neapolitan 7.6]","unordered"]},{"i":"the-adjust-function","l":"The adjust() function","p":["Input: a binary tree T whose left and right subtrees satisfy the heap property but whose root may not","Output: a binary tree T adjusted so that the entire binary tree satisfies the heap property","Executed d times, where d is the depth of the tree with root i","So O(d) time"]},{"l":"Cost of Make-Heap","p":["image","C_{MH} \\leq (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \\cdot 2^{k-2}","I= (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \\cdot 2^{k-2}","2I= (k-1)2^1 + (k-2)2^2 + (k-3)2^3 + ...+1 \\cdot 2^{k-1}","2I-1I= -(k-1) + 2^1+ 2^2 + ... + 2^{k-2}","I = -k+ \\frac {1 \\cdot (2^k-1)}{2-1} = 2^k -k -1","\\therefore C_{MH} \\leq 2^k -k -1","Time Complexity Analysis","2^k \\leq 2n, -k < -log_2 n","then 2^k -k -1 < 2n - log_2n -1","so C_{MH} = O(n)"]},{"i":"extract-items-one-by-one","l":"Extract items one by one.","p":["image"]},{"l":"Complexity of Item Extractions","p":["image","2^c \\leq n < 2^{c+1} \\rightarrow c \\leq \\log_2 n < c+1","for a given n, the cost (depth) is c = ⌊\\log_2n⌋","C_{IE}=⌊\\log (n-1)⌋+⌊\\log (n-2)⌋+⌊\\log (n-3)⌋...+⌊\\log2⌋+⌊\\log 1⌋\\leq \\log2 + \\log3 + ...+\\log {(n-1)} < \\sum_{i=2}^n \\log_2 n= O(n \\log n)","Heap Sort : C_{MH} +C_{IE} = O(n)+ O(n \\log n) = O(n \\log n)"]}],[{"i":"24-pq-2-min-max-heap","l":"2.4. PQ 2: Min-Max Heap","p":["Problem","The following operations must be performed as mixed in data processing:","Store a record with a key in an arbitrary order.","Fetch the record with the current largest key.","Fetch the record with the current smallest key.","A solution","Design a data structure that offers the efficient implementation of the following operations (Double-Ended Priority Queue):","Insert an element with an arbitrary key.","Delete an element with the largest key.","Delete an element with the smallest key.","ref.[Horowitz 9.1]","{교육과정 외}"]},{"i":"priority-queue-3-heap-and-hashing","l":"Priority Queue 3: Heap and Hashing"},{"i":"priority-queue-4-deap","l":"Priority Queue 4: Deap"},{"i":"priority-queue-5-leftist-tree","l":"Priority Queue 5: Leftist Tree"},{"i":"priority-queue-6-binomial-heap","l":"Priority Queue 6: Binomial Heap"},{"i":"priority-queue-7-fibonacci-heap","l":"Priority Queue 7: Fibonacci Heap"}],[{"i":"3-divideconquer-sorting-and-selection","l":"3. Divide&Conquer, Sorting, and Selection"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Divide-and-conquer 기법에 대한 이해 및 응용 능력","Sorting 방법에 대한 이해 및 구현 기법 습득"]}],[{"i":"30-algorithm-design-techniques","l":"3.0. Algorithm Design Techniques","p":["Divide-and-Conquer Techniques and Sorting Techniques","Divide-and-Conquer Method","Dynamic Programming Method","Greedy Method","Backtracking Method","Local Search Method","Branch-and-Bound Method","Etc."]},{"l":"The Divide-and-Conquer Approach","p":["Divide an instance of a problem into one or more smaller instances.","문제의 인스턴스를 하나 이상의 작은 인스턴스로 나눕니다.","Conquer(Solve) each of the smaller instances. Unless a smaller instance is sufficiently small, use recursion to do this.","각 작은 인스턴스를 정복합니다. 작은 인스턴스가 충분히 작지 않으면 재귀적을 사용하여 이 작업을 수행합니다.","If necessary, combine the solutions to the smaller instances to obtain the solution to the original instance.","필요한 경우 작은 인스턴스에 대한 솔루션을 결합하여 원래 인스턴스에 대한 솔루션을 확보합니다.","image"]},{"l":"Recursion","p":["Tower of Hanoi","Geeksforgeeks","image","T(n) = 2T(n-1) +1, n>1, T(1) = 1","Recursive thinking!","princeton"]},{"l":"1. Sorting","p":["데이터는 이미 부분적으로 정렬되어 있는가?","원래 링크 깨짐","일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)","품목의 분포를 알고 있습니까?","항목 키가 매우 길거나 비교하기 어렵습니까?","A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.","Are the keys of items very long or hard to compare?","Do you have to worry about disk accesses? 디스크 액세스에 대해 염려해야 합니까?","Do you know the distribution of the items?","Do you need a stable sorting algorithm? 안정적인 정렬 알고리즘이 필요한가?","Ex: non-increasing, non-decreasing, or etc.","Given a list of n items, arrange them in a certain order.","How many items will you be sorting? 얼마나 많은 원소를 정렬할 것인가?","How much time do you have to write and debug your routine? 루틴을 작성하고 디버깅하는 데 얼마나 많은 시간이 필요합니까?","Is the data already partially sorted?","Is the range of possible keys very small? 가능한 키의 범위가 매우 작습니까?","Problem:","ref. Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005,","Some criteria for choosing a sorting algorithm","Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐","What do you know about the data? 데이터에 대해 알고 계십니까?","Will there be duplicate items in the data? 데이터에 중복 항목이 있습니까?"]},{"l":"A Formal Definition of Sorting","p":["A partial order on a set S is a relation R such that for each a, b, and c in S:","aRa is true (R is reflexive).","aRb and bRc imply aRc(R is transitive)","aRb and bRa imply a = b(R is antisymmetric)","A Linear Order or Total Older on a set S is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.","The sorting problem","Given a sequence of n elements a_1, a_2, ..., a_n drawn from a set having a linear order $\\preceq $","find a permutation \\Pi = (\\pi_1, \\pi_2, ..., \\pi_n) of (1,2,...,n) that will map the sequence into a nondecreasing sequence a_{\\pi_1}, a_{\\pi_2},...,a_{\\pi_n} such that a_{\\pi_1} \\preceq a_{\\pi_i+1} for $1 \\leq i < n $","Ex: $ \\leq$ on \\mathbb{Z}, $ $\\subseteq $ on sets","Sorting on data with partial order?","ref. 이산수학 내용"]}],[{"l":"1. Sorting","p":["원래 링크 깨짐","일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)","A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.","Are the keys of items very long or hard to compare? 항목 키가 매우 길거나 비교하기 어렵습니까?","Do you have to worry about disk accesses? 디스크 액세스에 대해 염려해야 합니까?","Do you know the distribution of the items? 품목의 분포를 알고 있습니까?","Do you need a stable sorting algorithm? 안정적인 정렬 알고리즘이 필요한가?","Ex: non-increasing, non-decreasing, or etc.","Given a list of n items, arrange them in a certain order.","How many items will you be sorting? 얼마나 많은 원소를 정렬할 것인가?","How much time do you have to write and debug your routine? 루틴을 작성하고 디버깅하는 데 얼마나 많은 시간이 필요합니까?","Is the data already partially sorted? 데이터는 이미 부분적으로 정렬되어 있는가?","Is the range of possible keys very small? 가능한 키의 범위가 매우 작습니까?","Problem:","ref. Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005,","Some criteria for choosing a sorting algorithm","Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐","What do you know about the data? 데이터에 대해 알고 계십니까?","Will there be duplicate items in the data? 데이터에 중복 항목이 있습니까?"]},{"l":"A Formal Definition of Sorting","p":["A partial order on a set S is a relation R such that for each a, b, and c in S:","a R a is true ( R is reflexive).","aRb and bRc imply aRc( R is transitive)","aRb and bRa imply a = b( R is antisymmetric)","A Linear Order or Total Older on a set S is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.","The sorting problem","Given a sequence of n elements a_1, a_2, ..., a_n drawn from a set having a linear order $\\preceq $","find a permutation \\Pi = (\\pi_1, \\pi_2, ..., \\pi_n) of (1,2,...,n) that will map the sequence into a nondecreasing sequence a_{\\pi_1}, a_{\\pi_2},...,a_{\\pi_n} such that a_{\\pi_1} \\preceq a_{\\pi_i+1} for $1 \\leq i < n $","Ex: \\leq on \\mathbb{Z}, $ $\\subseteq $ on sets","Sorting on data with partial order?","ref. 이산수학 내용"]}],[{"i":"311-merge-sort","l":"3.1.1. Merge Sort"},{"l":"1. Merge Sort","p":["-","1","10","10 12","10 12 13","10 12 13 15","10 12 13 15 20","10 12 13 15 20 22","10 12 13 15 20 22 25","10 12 13 15 20 22 25 27","10 12 20 27","13 15 22 25","2","3","4","5","6","7","A simple implementation","An example of merging two arrays","Combine the solutions to the subarrays by merging them into a single sorted array.","Conquer each subarray by sorting it recursively.","Divide the array into two subarrays each with ~$ \\frac n 2$ items.","image","Inputs: positive integer n, array of keys S indexed from 1 to n.","k","left","merged","Outputs: the array S containing the keys in nondecreasing order. 배열 S는 감소하지 않는 순서로 정렬된 key를 갖는다","Problem: Sort n keys in nondecreasing sequence.","right"]},{"l":"Worst-case time complexity","p":["편의상 $n=2m$이라 할 경우 ( m \\in Z^+ \\cup \\{0\\}","T(n) = 2T(\\frac {n} {2}) + cn, n \\geq 2","2 : Number of subproblems","\\frac n 2: Subproblem size","T(1) =1\\rightarrow T(n) = O(nlogn)","Merge Sort Complexity Analysis| Merge Sort | | || ---------- | --------------- | ------- || Divide | Conquer | Combine || O(1)| 2T(\\frac n 2)| O(n)|","n개의 원소를 $k$개와 $l$개로 나누어 진행한다고 가정하면 ( n=k+l),","T(n) = T(k) + T(l) + cn (k \\approx l)","n = 2^m 이 아닌 일반적인 경우에도 같은 시간 복잡도를 가짐을 증명할 수 있음."]},{"l":"Solving Recurrence Equations","p":["Solve the following recurrences T(n) for given T(1)=1","T(n) = aT(n-1) + bn","T(n) = T(\\frac n 2) + bn \\log n","T(n) = aT(n-1) + bn^2","T(n) = aT(n/2) + bn^2","T(n) = T(\\frac n 2) + c \\log n","T(n) = T(\\frac n 2) + cn","T(n) = 2T(\\frac n 2) + cn","T(n) = 2T(\\frac n 2) + cn \\log n","T(n) = T(n-1) + T(n-2), for T(1) = T(2) = 1"]},{"l":"Some Derivations","p":["T(n) = 2 T(n/2) + cn, T(1) = 1","assume n=2^m, i.e., m = log_2 m for some m \\geq 0, m \\in \\mathbb{Z}","T(2^m) = 2T(2^{m-1})+c \\cdot 2^m\\\\= 2 \\{2T(2^{m-2})+c \\cdot 2^{m-1} \\}+c \\cdot 2^m\\\\=2^2 \\cdot T(2^{m-2})+2 \\cdot c \\cdot 2^m\\\\= 2^2 \\{2 \\cdot T(2^{m-3})+c \\cdot 2^{m-2} \\}+2 \\cdot c \\cdot 2^m$\\ ... \\= 2 m \\cdot T(2 0) + m \\cdot c \\cdot 2^ m $\\\\= n \\cdot 1 + (log_2 n) \\cdot c \\cdot n = O(n \\log n )","T(n) = T(n-1) + cn, T(1) = 1","T(n) = 2 T(n/2) + cn^2, T(1) = 1","Assume n=2^m for some m \\in \\mathbb{Z} - \\mathbb {Z^-}","2 \\cdot T (2^{m-1}) + c \\cdot 2 ^2m$\\ = 2 { 2 \\cdot T(2^) + c \\cdot 2 {2(m-1)} } + c \\cdot 2 2m $ $\\= 22 \\cdot T(2) + c { 2^{2m-1} + 2 {2m}} $ $\\ = 2 { 2 \\cdot T(2) + c \\cdot 2 {2(m-2)} } + c { 2{2m-1} + 2^{2m} } $$\\= 2 3 \\cdot T(2)+ c { 2^{2m-2} + 2^{2m-1} + 2 ^{2m}} $\\\\ … \\\\= 2^m + 2 \\cdot c \\cdot 2^{2m} - 2 \\cdot c \\cdot 2^m\\\\ =2 \\cdot c \\cdot n^2 - (2 \\cdot c -1) n = O(n^2)"]},{"l":"Another Implementation of Merge Sort","p":["ref. [Horowitz 7.6.3]","rmerge returns an integer that points to the start of the sorted list. start = rmerge(list, 0, n-1);","listmerge takes two sorted chains, first and second, and returns an integer that points to the start of a new sorted chain that includes the first and second chains.","listmerge 함수 수행 예 start","image"]}],[{"i":"312-quick-sort","l":"3.1.2. Quick Sort"},{"i":"312-quick-sort-1","l":"3.1.2. Quick Sort","p":["Pivot strategy","Divide","Select a pivot element, and then divide the array into two subarrays such that ....","Conquer","sort each subarray recursively.","Combine","do nothing.","image","A simple implementation"]},{"l":"Cost Analysis","p":["Cost","T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1) if n>1","T(1) = 1","Analysis|Quick Sort ||||---|---|---||Divide| Conquer| Combine|| O(n)| T(m_1)+T(m_2)| O(1)|","Worst-case time complexity","매 단계에서 선택한 pivot element가 가장 크거나 가장 작을 경우,","T(n) = T(0) + T(n-1) + cn, T(1) = 1 then T(n) = O(n^2)","Skewed vs well-balanced trees","Average-case time complexity","T(n) = \\sum_{p=1}^n {T(p-1) + T(n-p)} + cn","T(0) = 1 \\rightarrow","\\therefore T(n) = O(n log n)"]},{"l":"직관적인 시간 복잡도 추정","p":["T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1) if n>1","T(1) = 1","image"]},{"l":"Average Case Time Complexity"},{"l":"첫 번째 사실","p":["n \\leq 0, \\forall n \\in \\mathbb{Z}, T_{ave}(n) 을 n 개의 원소를 가지는 배열을 퀵 정렬 방법을 사용하여 정렬하는데 걸리는 평균 수행시간이라고 하자. 그러먼 어떤 양의 정수 b와 c에 대해 다음과 같은 재귀 관계 존재","T_{ave} (n) \\geq cn + \\frac {1}{n} \\sum_{p=1}^{n} \\{ T_{ave} (p-1) + T_{ave} (n-p) \\}\\\\= cn + \\frac{2}{n} {\\sum_{p=0}^{n-1} {T_{ave}(p)}}\\forall n \\geq 2","T_{ave} (1) \\leq b","T_{ave} (0) \\leq b","Cost_{ave} = \\sum_{p=1}^n {P_r (p) \\cdot Cost(p)} = \\frac {1}{n} \\sum_{p=1}^n {... + ...}"]},{"l":"두 번째 사실","p":["k=2(b+c) 라 할 때, 2보다 같거나 큰 모든 정수 n 에 대하여 T_{ave} (n) \\leq kn \\log_e n 과 같은 관계 존재","증명: 위의 부등식을 수학적 귀납법을 사용하여 증명하자.","n=2","첫 번째 사실로부터 다음과 같은 관계 성립\\\\ T_{ave}(2) \\leq 2c + T_{ave} (0) + T_{ave} (1) \\leq 2(b+c) \\leq k \\cdot 2 \\ log_e 2","\\therefore 따라서 두 번째 사실 성립","3보다 같거나 큰 임의의 n 이 given","Assume that : m<n 인 모든 m 에 대하여 두 번째 사실 성립한다고 가정하자.","그러면 첫 번째 사실과 이 과정을 사용하여 다음과 같은 관계 유도 가능","T_{ave} (n) \\leq cn + \\frac {2} {n} \\sum_{m=0}^{n-1} {T_{ave} (m)}\\\\ = cn + \\frac 2 m \\{ T_{ave} (0)+T_{ave} (1) \\} + \\frac {2} {n} \\sum_{m=2}^{n-1} {T_{ave} (m)}\\\\ \\leq cn + \\frac {4b} n + \\frac {2k} n \\sum_{m=2}^{n-1} {m log_e m}","그러므로 T_{ave} (n) \\leq cn + \\frac {2} {n} \\sum_{p=0}^{n-1} {T_{ve} (p)}\\forall n \\geq 2","함수 $x \\log_e x$가 $x$에 대하여 아래로 볼록한 함수이어서 m log_e m \\leq \\int_m^{m+1} x \\log_e x dx 라는 사실을 이용하면 다음과 같은 관계식을 얻는다.","T_{ave} (n)= cn + \\frac {4b}n + \\frac {2k}n \\int_2^n x log_e x dx\\\\ \\leq cn + \\frac {4b}{n} + \\frac{2k}{n} \\{ \\frac{n^2 log_e n}{2} - \\frac {n^2} 4 \\}\\\\= knlog_e n + \\{ cn + \\frac{4b} n - \\frac {kn} 2\\}","$\\int_2 n x log_e x dx =[\\frac 1 2 x 2 log_e x - \\frac {x 2} 4]_2 n $","= (\\frac {n^2} 2) log_e n - \\frac {n^2} 4 - (2log_e 2 - 1) \\leq \\frac {n^2} {2} {log_e n} - \\frac {n^2} {4}","이 때, $ cn + \\frac{4b} n - \\frac 2 = (c-\\frac k 2 )n + \\frac {4b} n = b(\\frac 4 n -n)$ 과 같고 이 값은 2보다 같거나 큰 n에 대해 항상 0보다 같거나 작으므로 T_{ave} (n) \\leq kn log_e n 이 되어 3보다 같거나 큰 임의의 n에 대해서도 두 번째 사실이 성립한다. 따라서 2보다 같거나 큰 모든 정수 n에 대해 다음과 같은 두 번째 사실이 성립한다."]},{"l":"Anther Implementation"},{"l":"Improving the Performance of Quick Sort","p":["How can you select a “good” pivot element?","Choose a random element in the list.","Choose the median of the first, middle, and final elements in the list.","Choose the median of the entire elements in the list. (bad idea)","Etc.","Program 7.4. improved quicksort","Choosing the median of the first, middle, and final elements as the partitioning element and cutting off the recursion for small subfiles can significantly improve the performance of quicksort.","This implementation partitions on the median of the first, middle, and final elements in the array (otherwise leaving these elements out of the partitioning process).","Files of size 11 or smaller are ignored during partitioning; then, insertion from is used to finish the sort.","How can you minimize the bookkeeping cost involved in the recursive calls?","Much of the pushing and popping of the frame stack is unnecessary.","Lists of size smaller than M are ignored during quick sort, then do a single sorting pass at the end.","Avoid making the recursive call on the larger subrange. \uF050 The depth of recursion <= O(log n)"]},{"i":"example-quick-sort","l":"Example: Quick Sort","p":["By courtesy of David R. Musser","Average-case: O(n log n)","Worst-case: O(n^2)","image"]},{"i":"quicksort-implementation-2-k-loudon","l":"Quicksort: Implementation 2 [K. Loudon]"}],[{"i":"313-insertion-sort","l":"3.1.3. Insertion Sort","p":["Insertion Sort: Example 1","image","Insertion Sort: Example 2","Insertion : O(n+d) in the worst case over sequences that have d inversions","When does the insertion sort run fast?","이러한 insertion sort의 성질을 quick sort의 성능 향상에 활용하자."]},{"l":"Implementation","p":["Sort a list of elements by iteratively inserting a next element in a progressively growing sorted array.","}"]},{"l":"Run-Time Analysis","p":["Worst case","No. of comparisons:","1+2+ ...+n-1 = O(\\frac {n^2}{2})","No. of record assignments:","Average case","No. of comparisons","\\sum_{i=1}^{n-1} {\\frac{1+2+...+i+i}{i+1} } =\\sum_{i=1}^{n-1} {(\\frac{i}{2}+1-\\frac{1}{i+1})}\\\\\\approx \\frac{(n-1)(n+4)}{4} - \\ln n = O(\\frac{n^2} 4)","No. of record assignments","\\sum_{i=1}^{n-1} {\\frac{0+1+2+...+i}{i+1} +2} = \\frac{n(n-1)}{4}+2(n-1) = O(\\frac{n^2}4)","image"]},{"l":"Example","p":["image"]}],[{"i":"314-selection-sort","l":"3.1.4. Selection Sort"},{"l":"Implementation","p":["T(n) = O(n^2)"]},{"l":"Example","p":["image"]},{"l":"Run-Time Analysis","p":["Worst case","No. of comparisons","\\sum_{i=0}^{n-2} (n-i-1) = \\frac {n(n-1)} 2 = O (\\frac {n^2} {2})","No. of record assignments","3(n-1) = O(3n)","Average case","[생각해보기] If we code like “if (i != cur) SWAP(A[i], A[cur]);”, what is the average cost?"]}],[{"i":"315-bubble-sort","l":"3.1.5. Bubble Sort"},{"l":"Example","p":["image"]},{"l":"Implementation"},{"l":"Run-Time Analysis","p":["Refer to The Art of Computer Programming (Vol. 3)","Worst Case","No. of comparisons","\\sum_{i=1}^{n-1} (n-1-i) = \\frac {n(n-1)} 2 = O (\\frac {n^2} {2})","No. of record assignments","$\\sum_ 3i = \\frac 3 2 n(n-1)= O (\\frac {3} {2} n 2) $","Average case","$\\frac 1 2 \\sum_ 3i = \\frac 3 2 n(n-1)= O (\\frac {3} {4} n 2) $"]}],[{"i":"316-cost-comparison","l":"3.1.6. Cost Comparison","p":["Selection","Insertion","Bubble","# of comparisons","\\frac{n^2}2","\\frac {n^2} 4(average)","\\frac{n^2}{2}(average)","\\frac{n^2} 2(worst)","\\frac{n^2}2(worst)","# of record assignments","3n","$\\frac{n^ 2}4 $(average)","\\frac{3n^2} 4(average)","\\frac{3n^2}2(worst)"]},{"l":"Comparison Sorts","p":["image","https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms","-"]},{"l":"Performance Comparisons","p":["By courtesy of David R. Musser","image"]}],[{"i":"321-selection-algorithm","l":"3.2.1. Selection Algorithm"},{"l":"1. Selection of Both Maximum and Minimum Elements","p":["Problem- Find both the maximum and the minimum elements of a set containing n elements (assume n = 2m for some integer m).","[Aho 2.6]","T(n) = (n-1) + (n-2) = 2n-3 comparisons","T(n) = 2T(n/2) + 2 for n > 2, T(n) = 1 for n = 2","→ T(n) = (3/2)n - 2 comparisons","This is the minimum!"]},{"l":"2. Multiplication of Two n-bit Numbers","p":["The traditional method requires O(n^2) bit operations.","A divide-and-conquer approach","image","xy = (a2^{\\frac n 2} + b)(c2^{\\frac n 2} + d) = ac2^n + (ad+bc)2^\\frac n 2 + bd","[Aho 2.6]","T(n) = 1 for n = 1","T(n) = 3T(n/2) + cn for n > 1→ T(n) = O(nlog3)","O(n^2) → O(n^{1.59})","Read [Neapolitan 2.6]."]}],[{"i":"322-selection-of-the-k-th-smallest-element","l":"3.2.2. Selection of the k-th Smallest Element","p":["[A. Aho, J. Hopcroft, and J. Ullman, Design and Analysis of Algorithms, Addison-Wesley, 1974. 3.6]","Problem","Given a sequence of S of n elements and an integer k (1 <= k <= n), find the k^{th} smallest element of S.","Solution 1:","Choose the smallest element repeatedly k times.","C = c(n-1)+c(n-2)+c(n-3)+...+c(n-k) = c \\cdot k \\cdot n - c \\cdot \\frac {k(k+1)} 2","if k= \\frac n 2 then C = c \\cdot \\frac {n^2} 2 - c \\cdot \\frac {n^2 + 2n} 8 = O(n^2)","Solution 2:","Build a min-heap, and then extract the smallest element repeatedly k times.","C = c \\cdot n + d \\cdot k \\cdot log n","if k= \\frac n 2 then C = c \\cdot n + d \\cdot \\frac n 2 \\cdot log n = O(n log n)","Can we design an O(n)-time algorithm?"]},{"i":"31-observation","l":"3.1. Observation","p":["At least O(n) time is necessary.","If we use a divide-and-conquer scheme like the merge sort,","What about T(n) = 3T(n/3) + cn?","image","Can we design an O(n)-time algorithm for this selection problem?","What about T(n) = T(an) + T(bn) + cn with a + b < 1?","cost : cn\\{1+(a+b)+(a+b)^2+...\\} \\leq cn \\frac 1 {1-a+b}","so O(n)"]},{"i":"32-algorithm","l":"3.2. Algorithm","p":["|S1| <= 3n/4 and |S3| <= 3n/4","At least one-fourth of the elements of S are greater than or equal to m.","At least one-fourth of the elements of S are less than or equal to m.","else find the (k – |S1| - |S2|)^{th} smallest element of S3.","else if (|S1| + |S2| >= k), then m is the k^{th} smallest element of S.","Facts","If |S1| >= k, then find the k-th smallest element of S1.","image","S1: the set of all elements less than m","S2: the set of all elements equal to m","S3: the set of all elements greater than m","Step 1: Divide S into floor(|S|/5) sequence of 5 elements each with up to four leftover elements.","Step 2: Sort each 5-element sequence.","Step 3: Let M be the sequence of medians of the 5-element sets. Then, let m be the median of the elements in M.","Step 4: Let S1, S2, and S3 be the sequences of elements in S less than, equal to, and greater than m, respectively."]},{"i":"33-time-complexity","l":"3.3. Time Complexity","p":["Input size n = |S|","|M| <= ceil(n/5)","|S1| <= 3n/4","|S3| <= 3n/4"]}],[{"i":"323-selection-algorithm-complexity-analysis","l":"3.2.3. Selection Algorithm: Complexity Analysis","p":["\\forall c, d \\in \\mathbb{R^+}, if the following recurrence relation holds:","\\leq k \\frac n 5 + k \\frac {3n} 4+ cn = \\frac {19}{20}kn +cn","= kn + (c-\\frac k {20})n \\leq kn if k \\geq 20c","$T(n) \\leq d $ for n \\leq 49","$T(n) \\leq T(\\frac n 5) + T (\\frac {3n} 4) + cn $ for n \\geq 50","assume that n \\geq 5 and T(m) \\leq km\\forall m < n","Base case","Inductive step","Proof","So if we choose k s.t. k = max(d, 20c), T(n) \\leq kn for all n \\geq 50.","T(n) \\leq d \\leq dn\\forall n \\geq1","then T(n) = O(n)","Then, $T(n) \\leq T(\\frac n 5) + T (\\frac {3n} 4) + cn $","Theorem","Therefore, $T(n) \\leq kn $ \\forall 1 \\leq n \\leq 49 if we select k such that k \\geq d","We want to prove that T(n) \\leq kn for some constant k, \\forall n \\geq 1"]}],[{"i":"333-master-theorem","l":"3.3.3. Master Theorem"},{"l":"Master Theorem 1","p":["[Neapolitan 2.8]","Let a, b, and c be nonnegative constants.","The solution to the recurrence T (1)=1, and T(n)=aT(n/c)+bn, for $n>1$for n a power of c is","T(n)=O(n), if a<c","T(n)=O(nlogn), if a=c","T(n) = O(nlogca), if a > c","Prove this by induction!","Avoid divided-and-conquer if, for example–","An instance of size n is divided into two or more instances each almost of size n.","An instance of size n is divided into almost n instance of size \\frac n c, where c is a constant.","The divide-and-conquer strategy often leads to efficient algorithms, although not always!"]},{"l":"Master Theorem 2","p":["212p"]}],[{"i":"34-miscellaneous","l":"3.4. Miscellaneous"},{"l":"Finding the Closest Pair of 2D Points"},{"l":"1. 내용","p":["[J. Kleinberg and E. Tardos, Algorithm Design, Addison Wesley, 2005. 5.4]","Problem","Given n points in the plane, find the pair that is closest together.","Notation","Naïve algorithm","Compute the distance between each pair of points","take the minimum → O(n^2) time"]},{"l":"2. Applying the Divide-and-Conquer Strategy","p":["[code]","[Combine] Use this information to get the closest pair in P→ O(n)","[Conquer] Find the closest pairs in Q and R, respectively→ 2T(n/2)","[Divide] Partition P into two subsets Q and R→ O(n)","[Fact 1] (Why?)","[Fact 2]","[Fact 3]","[merge] : O(n)","[photo]","[Preprocessing]","[Recursion for P with |P| = n]","[Shamos and Hoey]","\\delta=min(d(q_0^*,q_1^*),d(r_0^*,r_1^*))","\\exists q \\in Q, r\\in R for which d(q,r)<\\delta\\iff\\exists s, s^{'} \\in S for which d(s,s^{'})<\\delta","✓ Can be done in O(n)","Build a list P_x in which all the points in P have been sorted by increasing x- coordinate→ O(n \\log n)","Build another list P_y in which all the points in P have been sorted by increasing y-coordinate→ O(n \\log n)","Can be done in 2T(\\frac n 2).","Compare d(s, s^{'}) with \\delta","Create Q and R, where","Each box contains at most one point of S. (Why?)","For each s \\in S_y, compute its distance to each of the next 15 pts in S_y","Furthermore, create Q_x, Q_y, R_x, and R_y, where","General idea","How can we answer this question in linear time?","if s, s^{' } \\in S have the property that d(s, s^{'})<\\delta, then s, s^{'} re within 15 positions of each other in the sorted list S_y","if there \\exists q \\in Q , r \\in R for which d(q,r)<\\delta","If two points in S are at least 16 positions apart in S_y, ...","Let s, s^{'} be the pair achieving the minimum of these distances","No two points in P have the same x-coordinate or the same y- coordinate.","Q_x consisting of the points in Q sorted by increasing x-coordinate,","Q_y consisting of the points in Q sorted by increasing y-coordinate,","Q: the set of points in the first \\lceil(n/2)\\rceil positions of the list P_x(the “left half”),","Question : are there points q \\in Q, r \\in R for which d(q,r)<\\delta?","R_x consisting of the points in R sorted by increasing x-coordinate,","R: the set of points in the final \\lfloor(n/2) \\rfloor positions of the list P_x(the “right half”).","Recursively determine a closest pair (q_0, q_1) of points in Q.","Recursively determine a closest pair (r_0, r_1) of points in R.","Ry consisting of the points in R sorted by increasing y-coordinate.","S_y: the list consisting of the points in S sorted by increasing y-coordinate.","Simple assumption for an easy explanation","The stage [Combine]: Use the obtained info. to get the closest pair in P.","The stage [Conquer]: Find the closest pairs in Q and R, respectively.","The stage [Divide]: Partition P into two subsets Q and R.","then each of q,r lies within a distance \\delta of$ L$","Time-complexity O(n \\log n) + T(n) where T(n) = cn +2T(n/2) → O(n \\log n)","x^*: the x-coordinate of the rightmost point in Q"]}],[{"l":"4. DP"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Dynamic programming 기법에 대한 이해 및 응용 능력","Greedy approach에 대한 이해 및 응용 능력","Graph 구조 표현 기법 구현 및 관련 알고리즘 응용 능력","Intractable Problem과 근사 알고리즘에 대한 이해 (희망 사항)"]}],[{"i":"40-algorithm-design-techniques","l":"4.0. Algorithm Design Techniques","p":["Divide-and-Conquer Method","Dynamic Programming Method","Greedy Method","Backtracking Method","Local Search Method","Branch-and-Bound Method","Etc."]},{"i":"41-dynamic-programming-overview","l":"4.1. Dynamic Programming: Overview","p":["From Wikipedia: Dynamic programming is both a","mathematical optimization method and","a computer programming method.","A complicated problem is broken down into simpler sub-problems in a recursive manner.","Overlapping subproblems","A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.","Optimal substructure","A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.","When applicable, the method takes far less time than other methods that don't take advantage of the subproblem overlap like the divide- and-conquer technique."]}],[{"i":"42-approaches-for-recursive-formulation","l":"4.2. Approaches for Recursive Formulation"},{"i":"421-top-down-approach","l":"4.2.1. Top Down Approach","p":["T(i,j) = T(i-1,j) + T(i, j-1) + C \\cdot (2i + j) for i,j \\geq 1","T(i,0) = T(0,j) = 1 for i,j \\geq 0","Easily becomes exponential!"]},{"i":"422-bottom-up-approach","l":"4.2.2. Bottom Up Approach","p":["T(i,j) = T(i-1,j) + T(i, j-1) + C \\cdot (2i + j) for i,j \\geq 1","T(i,0) = T(0,j) = 1 for i,j \\geq 0","Often much more efficient!"]},{"i":"423-examples","l":"4.2.3. Examples"},{"i":"4231-ex1-world-series-odds","l":"4.2.3.1. [ex1] World Series Odds","p":["Problem","Dodgers and Yankees are playing the World Series in which either team needs to win n games first.","Suppose that each team has a $50%$chance of winning any game.","Let P(i,j) be the probability that if Dodgers needs i games to win, and Yankees needs j games, Dodgers will eventually win the Series.","Ex: P(2, 3) = \\frac {11}{16}","Compute P(i,j) 0 \\leq i,j \\leq n\\forall n"]},{"i":"4232-worse-a-divide-and-conquer-approach","l":"4.2.3.2. [Worse] A Divide-and-Conquer Approach","p":["Recursive formulation$P(i,j) = $\\\\ = 1 if i=0, j>0\\\\ = 0 if i=0, j=0\\\\ = \\frac{P(i-1,j)+P(i,j-1)}{2} if i>0, j>0","If we solve this recurrence relation in the divide-and-conquer way,","Let T( n) be the maximum time taken by a call to P( i),where i+ j= n. Then we can prove that T( n) is exponential!","T(1)=1, T(n) = 2T(n-1) + c \\rightarrow O(2^n)","What is the problem of this approach?"]},{"i":"4323-better-a-dynamic-programming-approach","l":"4.3.2.3. [Better] A Dynamic Programming Approach","p":["Instead of computing the same repeatedly, fill in a table as suggested below:","Time Complexity","For input size (m, n), computing P(m, n) takes O(mn)-time.","By far better than the Divide-and-Conquer approach."]}],[{"i":"43-concepts-of-dynamic-programming","l":"4.3. Concepts of Dynamic Programming","p":["Top-down → Bottom-up","When the divide-and-conquer approach produces an exponential algorithm where the same sub-problems are solved iteratively,","Take the recursive relation from the divide-and-conquer algorithm, and","replace the recursive calls with table lookups by recording a value in a table entry instead of returning it.","Three elements to consider in designing a dynamic programming algorithm","Recursive relation","Optimal substructure","Table setup","Table fill order","B(i,j)=B(i-1,j-1) + B(i-1,j) if 0<j<i","B(i,j)=1 if j=0 or j=i"]},{"l":"Application of DP"},{"i":"431-the-manhattan-tourist-problem","l":"4.3.1. The Manhattan Tourist Problem","p":["(0, 0)","다음 강의 주제","A brute force approach","A formal description of this problem","A given optimization problem can be constructed efficiently from optimal solutions of its subproblems.→ optimal substructure","A greedy approach","A possible selection determined by a greedy approach","An example grid of size (4, 4)","Assume that a tourist may move either to east or to south only","Basic idea","Courtesy of [Jones & Pevzner 6.3]","Given a (n, m) grid, what is the time complexity T(n, m)?","Given a weighted graph (grid) G of size (n, m) with two distinguished vertices, a source (0, 0) and a sink (n, m), find a longest path between them in its weighted graph.","Given two street corners in the borough of Manhattan in New York City, find the path between them with the maximum number of attractions, that is, a path of maximum overall weight.","How can you use the solutions of smaller problems to build a solution of a problem?","i,j \\geq 1","i=0, j=1,2,...,n","i=j=0","j=0, i=1,2,...,m","Optimal substructure : S_{n,m} =?","Problem:","Pseudocode","S_{0,0} = 0","S_{0,j} = S_{0,j-1}+W({(0,j-1)},{(0,j)})","S_{i,0} = S_{i-1,0}+W({(i-1,0)},{(i,0)})","S_{i,j} = \\max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))","Search among all paths in the grid for the longest path!","So far, we have found the cost of the longest path from source to each vertex in the grid.","Table setup and fill","Then, how can you print out the actual optimal path from source to sink?"]},{"i":"432-chained-matrix-multiplication","l":"4.3.2. Chained Matrix Multiplication","p":["[Neapolitan 3.4]","In general, to multiply an a x b matrix with a b x c matrix using the standard method, it is necessary to do abc elementary multiplications.","Problem","Determine the minimum number of elementary multiplications, needed to multiply n matrices where $ A_i \\in R^{d_\\times d_i}$","Examples: A_1 (20 \\times 2) \\bullet A_2 (2 \\times 30) \\bullet A_3 (30 \\times 12) \\bullet A_4 (12 \\times 8)","A_1: 20 \\times 2, A_2: 2 \\times 30","$A_1(A_2(A_3 A_4)) : 30 \\times 12 \\times 8 + 2 \\times 30 \\times 8 + 20 \\times 2 \\times 8 = 3,680 $ multiplications","(A_1 A_2)(A_3 A_4) : = 8,880 multiplications","A_1((A_2 A_3 )A_4) : = 1,232 multiplications","((A_1 A_2)A_3 )A_4 := 10,320 multiplications","(A_1(A_2 A_3 ))A_4 := 3,120 multiplications","The order of multiplication is very important!","(a \\times b) \\times c = a \\times (b \\times c)"]},{"i":"433-dynamic-programming-approach","l":"4.3.3. Dynamic programming approach","p":["→ O(n) time","0","1","2","3","4","5","6","7","8","Chained matrix multiplication problem","Definition","Example: M(2, 7)","j/ i","j/i","M(2,7) = \\min_{2\\leq k \\leq 6}{\\{ M(2,k) + M(k+1,7)+d_1 d_k d_7}\\}","M(i, j): the minimum number of multiplications needed to multiply A_i through A_j (i \\leq j )","n + (n-1) \\cdot 1 + (n-2) \\cdot 2 + ... + (n-(n-1))\\cdot (n-1)\\\\= n + \\Sigma_{g=1}^{n-1}{(n-g)g}\\\\= O(n^3)","O(n log n) by Hu and Shing (1982, 1984)","O(n^2) by Yao (1972)","O(n^3) by Godbole (1973)","Optimal subtructure","Printing optimal order","Table fill order","Time complexity"]}],[{"i":"44-principles-of-dynamic-programming","l":"4.4. Principles of Dynamic Programming","p":["C_{ij}= the cost of the shortest path from (0,0) to (i,j)","Then C_{ij} = min \\{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \\}","Recursive formulation","Optimal substructure","Overlapping subproblems","Bottom-up approach"]},{"i":"441-optimal-substructure-wiki","l":"4.4.1. Optimal Substructure (wiki)","p":["Dynamic programming algorithms are often used for optimization.","A problem is said to have optimal substructure","if a solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.","Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure.","Such optimal substructures are usually described by means of recursion.","C_{ij} = min \\{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \\}"]},{"i":"442-overlapping-subproblems-wiki","l":"4.4.2. Overlapping Subproblems (wiki)","p":["To solve a problem, we often need to solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution.","A problem is said to have overlapping subproblems if","the problem can be broken down into subproblems which are reused several times or","a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.","C_{ij} = min \\{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \\}","The dynamic programming approach seeks to solve each subproblem only once, thus reducing the number of computations:","(i) once the solution to a given subproblem has been computed, it is stored or \" memoized\":","(ii) the next time the same solution is needed, it is simply looked up.","This approach is especially useful when the number of repeating subproblems grows exponentially as a function of the size of the input.","If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called \"divide-and- conquer\" instead. This is why merge sort and quick sort are not classified as dynamic programming problems."]},{"i":"443-the-checkerboard-problem","l":"4.4.3. The Checkerboard Problem","p":["Courtesy of Wikipedia","Restrictions","A checker can start at any square on the first row (i= 1).","It can move only diagonally left forward, diagonally right forward, or straight forward.","It must pay the cost c[i] when visiting the (i, j)-position.","Cost table c [i] [j]","Problem","Given a checkerboard with n \\times n squares, and a cost function c[i][j], find the minimum-cost path from the first row to the last row.","Optimal substructure","code"]}],[{"i":"45-응용1-longest-common-subsequence-lcs","l":"4.5. [응용1] Longest Common Subsequence (LCS)","p":["[T. Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009. 16.3]","A subsequence of a given sequence is just the given sequence with some elements (possibly none) left out.","Definitions","Enumerate all subsequences of X and check each subsequence to see if it is also a subsequence of Y, keeping track of the longest subsequence found.→ Exponential algorithm!","Ex: \\\\ X=<A,B,C,B,D,A,B>, \\\\ Z=<B,C,D,B>(<2,3,5,7>)","Ex: X = <A, B, C, B, D, A, B>, \\\\ X_4 = <A, B, C, B>,\\\\ X_0 = null sequence","Ex: X = <A, B, C, B, D, A, B>, \\\\ Y = <B, D, C, A, B, A>,\\\\ Z_1 = <B, C, A>,\\\\ Z_2 = <B, C, B, A>,\\\\ Z_3 = <B, D, A, B>","find a longest common subsequence of X and Y.","Given a sequence X = <x_1, x_2, ..., x_m >, X_i = <x_1, x_2, ..., x_i > is the ith prefix of X, for i = 0, 1, ..., m.","Given a sequence X = <x_1, x_2, ..., xm > another sequence Z = <z_1, z_2, ..., zk > is a subsequence of X if there exists a strictly increasing sequence <_i1, i_2, ..., i_k > of indices of X such that \\forall j = 1, 2, ..., k, we have x_{ij} = z_j.","Given two sequences X = <x_1, x_2, ..., x_m > and Y = <y_1, y_2, ..., y_n >","Given two sequences X and Y, we say that a sequence Z is a common subsequence of X and Y if Z is a subsequence of both X and Y.","If x_m \\neq y_n, then an LCS of X and Y is either an LCS of X_{m-1} and Y or an LCS of X and Y_{n-1}.","If x_m = y_n, then z_k = x_m = y_n, and Z_{k-1} is an LCS of X_{m-1} and Y_{n-1}.","Let c[i, j] be the length of an LCS of the sequences X_i and Y_j","Let X = <x_1, x_2, ..., x_m > and $Y = <y_1, y_2, ..., y_n > $be sequences, and let Z = <z_1, z_2, ..., z_k > be any LCS of X and Y.","Naïve approach","Optimal substructure for computing c[i, j]","Optimal substructure of an LCS","Problem","The LCS problem can be solved efficiently using dynamic programming."]},{"i":"451--algorithm","l":"4.5.1. O(mn) Algorithm","p":["Filling the table","Printing the LCS"]},{"i":"452-c-implementation","l":"4.5.2. C Implementation","p":["Courtesy of link"]}],[{"i":"46-응용2-the-gapped-alignment-problem","l":"4.6. [응용2] The Gapped Alignment Problem","p":["Problem","Given two sequences, find a gapped alignment that maximize the score!","Compare two sequences if they are similar (related).","Gapped alignment","Example:","A possible alignment scoring scheme","Ex: match score = 2, mismatch penalty = -1, gap penalty = -2","Optimal substructure"]}],[{"i":"47-응용3-longest-increasing-subsequence-lis","l":"4.7. [응용3] Longest Increasing Subsequence (LIS)","p":["Problem","Given a sequence A=(a[0], a[1],...,a[n-1]), find the length of the longest subsequence such that all elements of the subsequence are sorted increasing order.","Example","(10, 22, 9, 33, 21, 50, 41, 60, 80)→(10, 22, 33, 50, 60, 80)","(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)→(0, 2, 6, 9, 11, 15), \\\\(0, 4, 6, 9, 11, 15) \\\\...","Algorithm","Let d[i] be the length of the LIS that ends in the element at index i. Then, the answer to the LIS problem is the maximum value of d[i], i=0,1,...,n-1","Optimal substructure","d[i] = \\max(1, \\max_{j=0,...,n-1 / a[j]<a[i]}{(d[j]+1)}) when i=0,1,..., n-1","code"]},{"l":"Minimal Triangulation","p":["[A. Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983. 10.2]","Problem","Given a set of n vertices for convex polygon, find a triangulation such that no two chords cross each other, and the total length of the chords selected is a minimum.","Counting all possible selections of chords in an inefficient way results in an exponential algorithm."]}],[{"i":"48-응용4-the-0-1-knapsack-problem","l":"4.8. [응용4] The 0-1 Knapsack Problem","p":["Problem","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i \\in A} p_i subject to \\Sigma_{i \\in A} w_i \\leq W","Example","\\{w_1, w_2, ..., w_5\\} = \\{6,5,10,3,4\\}","\\{p_1, p_2, ..., p_5\\} = \\{9,7,11,6,8\\}, W=15","\\rightarrow \\{1,2,5\\}","An intuitive interpretation","There are n items in a store.","The i th item weighs w_i kilograms and is worth p_i wons, where w_i and p_i are positive integers.","A thief has a knapsack that can carry at most W kilograms, where W is a positive integer.","What items should the thief take to maximize his “profit”?"]},{"l":"0. A 0-1 Knapsack Problem in Real Life","p":["10M","20M","22M","2M","3M","4M","500K","50K","600K","75M","800K","80M","City top paper network","Cost (dollars)","Expected reach (people)","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i \\in A} p_i subject to \\Sigma_{i \\in A} w_i \\leq W","Option","Problem","Radio ad campaign for 40 metro areas","ref","Super bowl","TV non peak hour campaign","Viral marketing campaign","Web advertising","Which marketing campaigns would you choose to maximize the total expected reach under the condition that, for each of these marketing campaigns, you either select it or you don’t?","You have a marketing budget of 5 million dollars.","You have the following marketing options and their paybacks in new potential customers:"]},{"l":"1. How to Solve the 0-1 Knapsack Problem","p":["\\{p_1, p_2, ..., p_4\\} = \\{3,2,4,4\\}, W=6","\\{w_1, w_2, ..., w_4\\} = \\{4,3,2,3\\}","\\max \\{(P(i-1,w), p_i+P(i-1,w-w_i))\\} if i>0 || w_i \\geq w","0","0 if i=0 || w = 0","1","2","3","4","5","6","7","8","Dynamic programming approach","Example","If we let A* be an optimal subset of \\{1, 2, ..., n\\},","Let P(i,w) be the maximized profit obtained when choosing items * only from the first i items under the restriction that the total weight cannot exceed w.","n \\in A* : P(n,W) = p_n + P(n-1, W-w_n)","n \\notin A* : P(n,W) = P(n-1, W)","Naïve approach","Optimal substructure","P(2,4) = \\max{(P(1,4), p_2 + P(1, 4-w_2))} = 3","P(3,5) = \\max{(P(2,5), p_3 + P(2,5-w_3))} = 6","P(4,2) = P(3,2) = 4","P(i-1,w) if i>0 || w_i >w","P(i,w)=","There are 2^n subsets of \\{1, 2, ..., n\\}!"]},{"l":"3. How to Reconstruct the Solution","p":["P(4,6) = \\max{(P(3,6), p_4 + P(3, 6-w_4))} = 8","P(3,3) = \\max{(P(2,3), p_3 + P(2, 3-w_3))} = 4","P(2,1) = P(1,1) = 0","P(1,1) = P(0,1) = 0","0","1","2","3","4","5","6","7","8"]},{"l":"4. Implementation and Time Complexity","p":["O(nW) Time"]},{"i":"5-0-1-knapsack-ex-1-","l":"5. 0-1 Knapsack Ex. 1: n = 6, W = 10","p":["?","0","1","10","11","12","13","14","15","16","18","19","2","3","4","5","6","7","8","9","A problem is that W is not bounded with respect to n.","Is the time-complexity O(nW) an efficient one?","No one has ever found an algorithm for the 0-1 Knapsack problem whose worst-case time complexity is better than exponential, yet no one has proven that such an algorithm is not possible!","Obtained profit: 19","P","p_i","Q","Selected items: i = 2, 3, 4, 6","This algorithm can be improved so that the worst-case number of entries computed is O(2^n).","This is not a linear-time algorithm!","w_i","What if n = 20 and W = 20!? → O(n*n!)","When W is extremely large in comparison with n, this algorithm is worse than the brute-force algorithm that simply considers all subsets."]},{"l":"6. A Variation of the 0-1 Knapsack Problem","p":["Problem","Decision Problem","Given n items of length l_1, l_2, ..., l_n, is there a subset of these items with total length exactly L?","Example\\{ 1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808, 17206, 117705, 117993 \\}, \\\\ L = 138457","→ \\{1, 2, 7, 98, 343, 686, 2409, 17206, 117705\\}","Dynamic programming approach","Let P(i,w) be the maximized profit obtained when choosing items * only from the first i items under the restriction that the total weight cannot exceed w.","If we let A* be an optimal subset of \\{1, 2, ..., n\\},","n \\in A* : P(n,W) = p_n + P(n-1, W-w_n)","n \\notin A* : P(n,W) = P(n-1, W)","\\rightarrow fill (i, j)"]},{"l":"7. A Divide-and-Conquer Approach","p":["Let fill(i,j) return TRUE \\iff\\exists subset of the first i items that has total length j.","When fill(i,j) returns TRUE,","If the $i$th item is used, fill(i - 1, j - l_i) must return TRUE.","If the $i$th item is not used, fill(i - 1, j) must return TRUE.","To solve fill(int n, int L),","T(n) \\geq c if n=0","T(n) \\geq 2T(n-1) +d if n>0","\\rightarrow T(n) = \\Theta(2^n)"]},{"l":"8. A Dynamic Programming Approach","p":["0","1","10","11","12","13","14","15","2","3","4","5","6","7","8","9","Example","F","F(i,j)= F(i-1,j) || ((l_i \\geq j) || F(i-1, j-l_i)) if i>0","F(i,j)= FALSE if i=0, j!=0","F(i,j)= TRUE if i=0, j=0","L = 15, (l_1, l_2, l_3, l_4, l_5, l_6, l_7)= (1, 2, 2, 4, 5, 2, 4)","O(nL) time implementation","T","The optimal substructure :"]},{"l":"9. Subset Sum","p":["Problem","Given a set of positive integers \\{w_1, w_2, ..., w_n\\} of size n and a postivie integer W, Find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i\\in A}{w_i} subject to \\Sigma_{i\\in A}{w_i} \\geq W","Example","\\{w_1, ..., w_9\\} = \\{20,30,14,70,40,50,15,25,80,60,10,95\\}, W=99 \\rightarrow \\{20,14,40,25\\}","Application","There are n jobs, each of which takes w_i time.","Now we have a CPU with W free cycles, and want to choose the set of jobs that minimizes the number of idle cycles.","Relation to the 0-1 Knapsack problem","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i \\in A} p_i subject to \\Sigma_{i \\in A} w_i \\geq W","\\iff","참고","If it is possible to solve the 0-1 knapsack problem in polynomial time, the subset sum problem can be solved in polynomial time too.","Somebody has already proven that the subset sum problem is very hard.","In other words, the subset sum problem is NP-complete. \\rightarrow Hence, the 0-1 knapsack problem is also a very hard problem. In other words, the 0-1 knapsack problem is also NP-complete."]},{"l":"10. The Fractional Knapsack Problem","p":["\\rightarrow Could be faster if only a small number of items are necessary to fill the knapsack.","A greedy approach","Choose all of the 1st item: (5, 50)","Choose all of the 3rd item: (20, 140)","Choose half of the 2nd item: (\\frac {10}{2}, \\frac{60}{2})","Choose the items, possibly partially, one by one until the knapsack is full.","Does the greedy approach always find an optimal solution to the 0- 1 Knapsack problem?","Example: \\{w_1, w_2, w_3\\} = \\{5, 10, 20\\},\\\\ \\{p_1, p_2, p_3\\} = \\{50, 60, 140\\}, w = 30\\\\ \\frac{p_1}{w_1} = 10, \\frac{p_2}{w_2} = 6, \\frac{p_3}{w_3} = 7","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a set of ratios of \\{r_1, r_2, ..., r_n\\}(0 \\leq r)i \\geq 1) that maximizes \\Sigma_{i} r_i \\cdot p_i subject to \\Sigma_{i} r_i \\cdot w_i \\leq W","Implementation 1 : $O(n \\log n +n) = O(n \\log n) $","Implementation 2 : O(n + k \\log n) = ?","Problem","Put the items in a heap → O(n)","Repeat the choice → O(k \\log n)","Repeat the choice → O(n)","Sort the items → $O(n \\log n) $","Sort the items in nonincreasing order by profits per unit weight \\frac{p_i}{w_i}.","The greedy method always find an optimal solution to the fractional Knapsack problem! \\leftarrow Correctness"]},{"i":"0-1-knapsack-example-2-","l":"0-1 Knapsack Example 2: n = 6, W = 10","p":["0-1 knapsack (dynamic programming)","0-1 knapsack (greedy 1)","0-1 knapsack (greedy 2)","0.667","1","1.000","1.333","1.500","12","2","2.500","3","3.000","4","5","6","9","Fractional knapsack (greedy)","Obtained profit: 11","Obtained profit: 12","Obtained profit: 15","Obtained profit: 17.67","p_i","p_i/w_i","Selected items: $i = 4, 2, 6 $","Selected items: i = 3","Selected items: i = 3, 4","Selected items: i = 4, 2, 6, 3(5)","Time Complexity: O(n \\log n)","Time Complexity: O(nW)","w_i"]}],[{"l":"5. Greedy"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Greedy approach에 대한 이해 및 응용 능력"]}],[{"i":"50-the-greedy-method","l":"5.0. The Greedy Method"},{"l":"0. Algorithm Design Techniques","p":["Divide-and-Conquer Method","Dynamic Programming Method","Greedy Method","Backtracking Method","Local Search Method","Branch-and-Bound Method","Etc."]},{"l":"1. The Greedy Method","p":["A technique to follow the problem-solving heuristic of making the locally optimal choice at each stage.","각 단계에서 휴리스틱적으로 최적의 선택을 하는 PS 기술","Strategy","Make the choice that appears best at each moment!","It is hoped to arrive at a globally optimal solution by making a locally optimal choice.","Pros and cons","wiki","Simple and straightforward to design an algorithm.","Does not guarantee the optimal solution to all problems","Local maximum versus global maximum"]}],[{"i":"52-prefix-codes","l":"5.2. Prefix Codes","p":["No codeword can be a prefix of any other code.","Otherwise, decoding is impossible!","Uniquely decodable!","☺ Example 1","a = 00, b = 1110, c = 110, d = 01, e = 1111, f = 10","Example 2","a = 00, b = 1100, c = 110, d = 01, e = 1111, f = 10","Binary trees corresponding to prefix codes","The code of a character c is the label of the path from the root to c.","Decoding of an encoded file is trivial.","Problem","Given a file F to be encoded with a character set V = \\{v_1, v_2, ..., v_n \\}, find an optimal prefix binary code with a corresponding binary tree T that minimizes the cost function","bits(T) = \\Sigma_{i=1}^n{freq(v_i) \\cdot depth(v_i)}","where freq(v_i) is the number of times v_i occurs in F, and depth(v_i) is the depth v_i of in T.","A Greedy approach successfully finds an optimal code."]}],[{"i":"53-huffmans-algorithm","l":"5.3. Huffman’s Algorithm"},{"l":"1. Contents","p":["Idea","Put the rarest characters at the bottom of the tree.","A greedy approach","Repeat the following until only one tree is left:","Start from a set of single node trees.","Pick up two trees u and v with the lowest frequencies.","Merge them by adding a root node w where the frequency of the new node is the sum of those of u and v.","Replace u and v by w."]},{"l":"2. Implementation and Time Complexity","p":["\\log n + \\log (n-1) + ... + \\log(2) = \\log n! = O (n \\log n)","→ O (n\\log n) time","✓ The answer is to use the priority queue based on (min) heap.","Delete the elements with the highest priority from the list.","Deletion","Heap","How can you manage a dynamic set to which the following operations occur frequently:","Implementation issues","Insert an element with some priority into the list.","insert the n single-node trees : O(n)","Insertion","O(\\log n)","O(1)","O(n)","Representation","Sorted array","Sorted linked list","The answer is to use Priority Queue.","The priority queue can be implemented in many ways. Which one would you use?","Unordered array","Unordered linked list"]},{"i":"3-correctness-of-the-huffmans-algorithm","l":"3. Correctness of the Huffman’s Algorithm","p":["(Base step) When k = 0, each tree is trivially a branch of an optimal tree.","(Induction step) Suppose that the proposition is true when k = i, that S is the set of trees that exist after the $i$th step, and that T is the corresponding optimal tree. Let u and v be the root of the trees combined in the $(i+1)$st step.","(Proof by mathematical induction)","\\rightarrow (i+1)-th step","Case 1: If u and v are siblings in T, we are done.","Case 2: Otherwise, assume that u is at a level in T at least as low as v, and that w is the u’s sibling in T.","i-th step","If the set of trees obtained in the i-th step are branches in a binary tree corresponding to an optimal code, then the set of trees obtained in the $(i+1)$st step are also branches in a binary tree corresponding to an optimal code.","If we create a new tree T’ by swapping the two branches with root v and w, then bits(T’) = bits(T) + (depth(w) – depth(v))(freq(v) – freq(w)) ≤ bits(T).","Optimal binary tree","siblings, branch","Since bits(T) ≤ bits(T’), T’ is also optimal. Hence, the proposition also holds when k = i+1.","The branch in T with root w is one of the trees in S or contains one of those trees as a subtree.","Therefore, freq(w) ≥ freq(v) and depth(w) ≥ depth(v) in T","What happens if all the steps are done?","why?"]}],[{"i":"54-maximum-non-overlapping-intervals","l":"5.4. Maximum Non-overlapping Intervals","p":["` if (s_j \\geq f_k)","`` k=j","`` S = S \\cup \\{a_j\\}","→ O(n \\log n + n) = O(n \\log n) time","귀류법 (Proof by contradiction)","A = \\{a_1, ..., a_n\\} with a_i = [s_i, f_i) for 0 \\leq s_i <f_i < \\infty","Assertion 1: For any set A of n activities, there always exists an optimal solution S that contains a_1 with the earliest finish time.","Assertion 2: If S is an optimal solution for A containing a_1, S^* = S \\ \\{a_1\\} is an optimal solution for A^* = \\{a_i \\in A | s_i \\geq f_1\\}","Correctness of “Earliest-finish-first”-based algorithm","Earliest finish first","Earliest start first","Example","for j=2 to n","Greedy algorithm","if selected, activity a_i takes place during the time interval [s_i, f_i).","Input: A = \\{a_1, ..., a_n\\} with a_i = [s_i, f_i) for 0 \\leq s_i < f_i <\\infty","k=1;","Let A = \\{a_1, a_2, ..., a_n\\} be a set of n activities, where a_i has start time s_i and finish times f_i (0 \\leq s_i < f_i < \\infty ).","Longest one first","Now, select a largest set S of mutually compatible activities. (We assume that the activities are given in such a way that f_1 \\leq f_2 ... \\leq f_{n-1} \\leq f_n)","Possible strategies for choosing activities","Problem","return S;","S = \\{a_1\\}","Selecting a_1 reduces the problem to finding an optimal solution for activities not overlapping with a_1.","Shortest one first","Sort the activities so that f_1 \\leq f_2 \\leq ... \\leq f_n","Two activities a_i, a_j are called compatible if the time intervals [s_i, f_i) and [s_j, f_j) do not overlap."]}],[{"i":"55-scheduling-minimizing-total-time-in-the-system","l":"5.5. Scheduling: Minimizing Total Time in the System","p":["[1, 2, 3]","[1, 3, 2]","[2, 1, 3]","[2, 3, 1]","[3, 1, 2]","[3, 2, 1]","→ O(n!)","☞ 4 + (4 + 5) + (4 + 5 + 10) = 32","10 + (10 + 5) + (10 + 5 + 4) = 44","33","37","43","5 + (5 + 10) + (5 + 10 + 4) = 39","A greedy approach","A naïve approach","Algorithm","C(S) = s_1 + (s_1 +s_2) + (s_1 + s_2 + s_3) + ... + (s_1 + s_2 + ... + s_n) \\\\ = n \\cdot s_1 + (n-1) \\cdot s_2 + ... + 2 \\cdot s_{n-1} + 1 \\cdot s_n \\\\ = \\Sigma_{i=1}^{n}{(n+1-i)\\cdot s_i} \\\\ = (n+1) \\Sigma_{i=1}^{n}{s_i}-\\Sigma_{i=1}^{n}{i \\cdot s_i}","Consider a system in which a server is about to serve n clients. Let T = {t_1, t_2, ..., t_n} be a set of positive numbers, where ti is the estimated time-to-completion for the ith client. What is the optimal order of service where the total (wait+service) time in the system is minimized?","Correctness : 귀류법 (Proof by contradiction)","Does the greedy approach always find a schedule that minimizes the total time in the system?","Enumerate all possible schedules of service, and select the optimal one.","Example","Hair stylist with waiting clients, pending operations on a shared hard disk, etc.","If they are not scheduled in nondecreasing order, then, for at least one i(1≤i≤n-1), s_i >s_{i+1}.","Let S = [s_1, s_2, ..., s_n] be an optimal schedule, and C(S) be the total time for S.","Now consider the schedule S’ = [s_1, s_2, ..., s_{i+1}, si, ..., sn] that is obtained by interchanging s_i and s_{i+1}.","Problem","Schedule","Sort T in nondecreasing order to get the optimal schedule. - → O(n \\log n)","T = {t_1, t_2, t_3} = {5, 10, 4}","Then, C(s) - C(s') \\\\ = (i \\cdot s_{i+1} + (i+1) \\cdot s_i) - (i \\cdot s_i + (i+1) \\cdot s_{i+1}) \\\\ = s_i - s_{i+1} >0.","Therefore, ...","Total Time in the System"]}],[{"i":"56-scheduling-minimizing-lateness","l":"5.6. Scheduling: Minimizing Lateness"},{"l":"Problem","p":["Let J = {1, 2, ..., n} be a set of jobs to be served by a single processor.","The $i$th job takes t_i units of processing time, and is due at time d_i.","When the $i$th job starts at time s_i, its lateness l_i = \\max{0, s_i + t_i - d_i }.","Goal: Find a schedule S so as to minimize the maximum lateness","L = \\max{l_i}."]},{"l":"Example","p":["S = {3, 2, 6, 1, 5, 4}→ maximum lateness = 6","Job","t_i","d_i","1","3","6","2","8","9","4","5","14","15"]},{"l":"Possible greedy approaches","p":["→ maximum lateness = 1","1","14","15","2","3","4","5","6","8","9","An optimal schedule S = \\{1, 2, 3, 4, 5, 6\\}","di","Earliest Deadline First (O)","Job","Shortest Jobs First (?)","Smallest Slack-Time First (?)","Sort jobs in nondecreasing order of deadline d_i:","Sort jobs in nondecreasing order of processing time ti","Sort jobs in nondecreasing order of slack d_i - t_i:","ti"]},{"i":"correctness-of-earliest-deadline-first-based-algorithm","l":"Correctness of “Earliest-deadline-first”-based algorithm","p":["사실","만약 주어진 schedule에 inversion이 있을 경우, 최소한 연달아 schedule된 두 개의 inversion된 job이 있음.","Inversion이란 deadline 관점에서 봤을 때 서로 순서가 뒤 바뀐 두 개의 job의 쌍 을 말함.","연달아 있는 inversion 상태의 두 개의 job의 순서를 서로 바꿀 경우, maximum lateness를 증가시키지 않음.","증명","$S$를 최소 개수의 inversion을 가지는 최적의 schedule이라 가정.","만약 $S$에 inversion이 없다면, 위의 방법으로 구한 schedule과 동일.","만약 $S$에 inversion이 있다면, 이 경우 연달아 있는 inversion된 두 job의 순서를 서로 바꾸면, 결과로 발생하는 schedule $S’$는 maximum lateness를 증가시키지 않음으로 역시 또 다른 최적의 schedule임.","그러나 $S’$는 S 보다 inversion의 개수가 적음. 이는 S에 대한 가정에 대한 모순. 따라서 $S$에는 inversion이 없고 따라서 이는 위의 방법으로 구한 schedule과 동일함."]}],[{"i":"57-scheduling-with-deadlines","l":"5.7. Scheduling with Deadlines"},{"l":"Problem","p":["Let J = \\{1, 2, ..., n\\} be a set of jobs to be served.","Each job takes one unit of time to finish.","Each job has a deadline and a profit.","If the job starts before or at its deadline, the profit is obtained.","Schedule the jobs so as to maximize the total profit (not all jobs have to be scheduled)."]},{"i":"example","l":"Example:"},{"l":"A greedy approach","p":["Sort the jobs in non-increasing order by profit.","Scan each job in the sorted list, adding it to the schedule if possible."]},{"i":"example-1","l":"Example","p":["-->","1","10","15","2","20","25","3","30","35","4","40","5","6","7","Deadline","Is S = {1, 2, 3} OK?","Is S = {1, 2, 4, 5} OK?","Is S = {1, 2, 4, 6} OK?","Is S = {1, 2, 4, 7} OK?","Is S = {1, 2, 4} OK?","Is S = {1, 2} OK?","Is S = {1} OK?","Job","No.","Profit","S = EMPTY","Yes: S \\leftarrow{1, 2, 4} ([2, 1, 4] or [2, 4, 1])","Yes: S \\leftarrow{1, 2} ([2, 1])","Yes: S \\leftarrow{1} ([1])"]},{"i":"example-2","l":"Example"},{"l":"Implementation Issues","p":["A key operation in the greedy approach","An $O(n^ 2)$implementation","at most i comparisons are needed to check if the new sequence is feasible.","at most i-1 comparisons are needed to add a new job in the sequence, and","Determine if a set of jobs S is feasible.","Example","Fact","For each job in the sorted order,","If yes, add it to the list of feasible sequence.","Is S = \\{1, 2, 4, 7\\} OK?→$[2(1), 7(2), 1(3), 4(3)]$→No","Is S = \\{1, 2, 4\\} OK?→$[2(1), 1(3), 4(3)]$→Yes!","Is the time complexity always O(n^2)?","Is this complexity achievable when a max heap data structure is employed?","O(n \\log n) + \\Sigma_{i=2}^{n}{\\{(i-1)+i\\}} = O(n^2)","O(n \\log n+n d_{max})","O(n + k_{scanned} \\log n + k_{scanned} d_{max}) = O(n)","Otherwise, reject it.","S is feasible if and only if the sequence obtained by ordering the jobs in S according to nondecreasing deadlines is feasible.","See if the current job can be scheduled together with the previously selected jobs, using a linked list data structure.","Sort the jobs in non-increasing order by profit.","Time complexity","What if n >> d_{max} and n >> k_{scanned}?","What if n >> d_{max}?","When there are i-1 jobs in the sequence,"]},{"l":"Correctness of the Greedy Method","p":["Left as an exercise."]}],[{"i":"58-data-structures-for-disjoint-sets","l":"5.8. Data Structures for Disjoint Sets","p":["{a, c} = Find(a);","A partition of a set X is a set of non-empty subsets of X such that every element x in X is in exactly one of these subsets.","Always attach the smaller tree to the root of the larger tree.","Applications","Basic operations on disjoint sets","Classifying a set of atoms into molecules or fragments.","Computing shorelines of a terrain","Connected component labeling in image analysis","Decide if two vertices belong to the same component, or if adding an edge between them would result in a cycle.","Determine which set the particular element x is in.","Disjoint set의 path compression 연산에 대해서도 알아볼 것.","Disjoint-set data structure (union-find data structure)","Example","Example: X = \\{1, 2, 3, 4, 5, 6\\}→\\{ \\{1, 3, 5\\}, \\{2\\}, \\{4, 6\\} \\}","For (each x\\in U)","Implementation of disjoint sets using reversed trees","Make a set containing only the given element x.","Makeset( x); → { a}, { b}, { c}, { d}, { e}","Makeset(x)","May be used to determine if two elements are in the same subset.","Merge two subsets into a single subset.","Partition","ref","S = Find(x)","Scheduling with deadlines","The maximum possible rank of a tree with n elements is O(\\log n).","The number of elements in a tree of rank r is at least 2^r(Proof by induction)","The rank increases by one only if two trees of the same rank are merged.","The rank of a one-element tree is zero.","The Union and Find operations can be done in O(\\log n) in the worst case.","Time complexity: 2 Find op’s + O (1)","Time complexity: O(\\log n)","Time complexity: O(1)","Time complexity: O(depth of x in the tree)","Time complexity: O(n)","Tracking the connected components of an undirected graph","Two ways of implementing the Union Operation","Typically return an element that serves as the subset’s representative.","U=\\{a,b,c,d,e\\}","Union by rank","Union( a, c); → { a, c}, { b}, { d}, { e}","Union( c, e); → { a, c, e}, { b}, { d}","Union(x, y)","Union(x, y)(or Merge(x, y))","Used to effectively manage a collection of subsets that partition a given set of elements.","Useful for implementing the Kruskal’s algorithm for finding minimum spanning tree"]},{"l":"Another Algorithm Based on Disjoint Sets","p":["Method","d_{max}: the maximum of the deadlines for n jobs.","Add a job as late as possible to the schedule being built, but no later than its deadline.","Sort the jobs in non-increasing order by profit.","Initialize d_{max}+1 disjoint sets, containing the integers 0, 1, 2, ..., d_{max}","For each job in the sorted order,","Find the set S containing the minimum of its deadline and n.","If small(S) = 0, reject the job.","Otherwise, schedule it at time small(S), and merge S with the set containing small(S)-1.","Time complexity","O(n \\log m) for the disjoint set manipulation, where m is the minimum of n and d_{max}","O(n \\log n) for sorting the profits.","Example"]}],[{"i":"5","l":"5."},{"i":"1-huffman-coding","l":"1) Huffman Coding","p":["Data compression","Data compression can save storage space for files.","Huffman coding is just one of many data compression techniques.","Problem","Given a file, find a binary character code for the characters in the file, which represents the file in the least number of bits.","Example","Original text file: ababcbbbc","Huffman codes: a=10,b=0,c=11","→ Compressed file: 1001001100011","Is it possible to have a code set where a = 01, b = 0, and c = 11?"]}],[{"l":"6. Graph"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Graph 구조 표현 기법 구현 및 관련 알고리즘 응용 능력","Intractable Problem과 근사 알고리즘에 대한 이해 (희망 사항)"]}],[{"l":"0. Basic Things to Know about Graph as a CSE Undergraduate","p":["All-pairs shortest path algorithm","Biconnected component algorithms","Biconnectivity","Breadth-first search","Connectivity","Definitions and representations","Depth-first search","Graph traversal algorithms","Kruskal’s minimum spanning tree algorithm","Minimum spanning tree algorithm","Prim’s minimum spanning tree algorithm","Shortest path algorithm","Simple connectivity","Single-source shortest path algorithm","Strong connectivity","Transitive closure"]},{"l":"1. Definitions","p":["An (undirected, simple) graph G is defined to be a pair of (V, E), where V is a non-empty finite set of elements called vertices, and E is a finite set of unordered pairs of distinct elements of V called edges.","G = (V, E) = (V(G), E(G))","Graphs that allow loops and multiple edges are often called a general graphs.","A (simple) digraph D is defined to be a pair (V, A), where V is a non-empty finite set of elements called vertices, and A is a finite set of ordered pairs of distinct elements of V called (directed) edges or (directed) arcs.","A weighted graph is a graph in which a number, called the weight, is assigned to each edge.","V = \\{ 1, 2, 3, 4, 5, 6 \\}\\\\ E = \\{ (1, 2), (1, 5), (2, 3), (2, 5), (3, 4), (4, 5), (4, 6) \\}","From Wikipedia","A subgraph of a graph G is simply a graph, all of whose vertices belong to V(G) and all of whose edges belong to E(G)."]},{"l":"Adjacency and incidence","p":["Two vertices v and w of a graph G are said to be adjacent if there is an edge joining them.","Two distinct edges of G are adjacent if they have at least one vertex in common.","The vertices v and w are then said to be incident to such an edge.","The degree of a vertex v of G is the number of edges incident to v."]},{"i":"walk-trail-circuit-path-and-cycle","l":"Walk, trail, circuit, path, and cycle","p":["-->","A circuit is a trail that is closed.","A cycle is a path containing at least one edge with an exception that the first and last vertices coincide.","A Hamiltonian cycle is a Hamiltonian path that is a cycle.","A Hamiltonian path is a path that visits each vertex exactly once.","A path is a walk in which all the vertices are distinct from one another.","A trail is a walk in which all the edges are distinct from one another.","A walk is closed if it starts and ends at the same vertex.","A walk(or edge-sequence) is an alternating sequence of vertices and edges, starting and ending at a vertex, in which each edge is adjacent in the sequence to its two endpoints.","Allowed","An Eulerian circuit exists in a connected graph G if the degree of every vertex is even, and can be found in O(|E|) time.","An Eulerian circuit is an Eulerian trail that starts and ends on the same vertex.","An Eulerian trail is a trail that visits every edge exactly once.","Circuit","Closed","Cycle","Determining whether such paths and cycles exist in graphs is the Hamiltonian path problem, which is NP-complete.","Disallowed","Edge repetition","Open","Open/Closed","Openness","Path","The definitions differ by various textbooks!!!","The length of a walk is the number of edges in it.","Trail","Vertex repetition","Walk"]},{"l":"Examples of graphs","p":["A null graph is a graph whose edge-set is empty.","A regular graph is a graph in which each vertex has the same degree.","A complete graph is a graph in which each pair of vertices is joined by an edge.","A bipartite graph is a graph in which its vertex set can be partitioned into two sets V_1 and V_2, in such a way that every edge of the graph joins a vertex of V_1 to a vertex of V2.","A connected graph is an undirected graph, in which, given any pair of vertices v and w, there is a path from v to w.","An arbitrary graph can split up into disjoint connected subgraphs called connected components.","A tree is a connected graph with no cycles.","A forest is a graph with no cycles.","Graph isomorphism","Two graphs G1 and G2 are isomorphic if there is a one-to-one correspondence between the vertices of G1 and those of G2 with the property that the number of edges joining any two vertices of G1 is equal to the number of edges joining the corresponding vertices of G2."]},{"l":"Graph Representation"},{"l":"1. Adjacency List","p":["In mathematics"]},{"l":"2. Adjacency Matrix","p":["In mathematics","Various Costs for a Graph G = (V, E)"]}],[{"i":"62-graph-search","l":"6.2. Graph Search"},{"l":"Some Problems Related to Graph Search","p":["Cycle detection","Does a given graph have a cycle of odd length?","Does a given graph have any cycle?","Find a path that uses all the edges in a graph exactly twice – once in each direction.","Find a shortest path in the graph from v to w.","Find shortest paths connecting a given vertex v with each other vertex in the graph.","General connectivity","Given a connected graph with n vertices, find a set of n-1 edges that connects the vertices.","Given two vertices, is there a path in the graph that connects them?","How many vertices are in the same connected component as a given vertex?","Is a given graph bipartite?","Is a given graph k-edge connected?","Is a graph connected?","Is a graph k-connected?","Is there a way to assign one of two colors to each vertex of a graph such that no edge connects two vertices of the same color?","Shortest path","Simple connectivity","Simple path","Single-source shortest paths","Spanning tree","st-connectivity","Two-colorability, bipartiteness, odd cycle","Two-way Euler tour","Vertex search","What is the edge connectivity and the vertex connectivity of a given graph?","What is the minimum number of edges whose removal will separate two given vertices s and t in a graph?"]},{"i":"1-graph-search-1-depth-first-search-dfs","l":"1) Graph Search 1: Depth-First Search (DFS)","p":["자료구조 과목에서 배웠음"]},{"i":"depth-first-search-review","l":"Depth-First Search: Review","p":["A graph structure definition","A Recursive implementation in C","parent = predecessor","entry time = discovery time","exit time = finish time"]},{"l":"An Abstract Implementation Using a Stack","p":["편의상 connected graph로 가정 (아닐 경우에는?)","어떤 연산이 전체 탐색을 dominate하는가?","각 꼭지점은 unvisited 상태에서 스택에 몇 번 push되는가?","전체적으로 각 edge는 몇 번 access되는가?","Time complexity","Adjacency list: O(|V|+|E|)","Adjacency matrix: O(|V|2)","기존에 배운 recursion 기반 구현과 비교할 것"]},{"i":"3-graph-search-2-breadth-first-search-bfs","l":"3) Graph Search 2: Breadth-First Search (BFS)","p":["자료구조 과목에서 배웠음"]},{"l":"An Abstract Implementation Using a Queue","p":["편의상 connected graph로 가정 (아닐 경우에는?)","어떤 연산이 전체 탐색을 dominate하는가?","각 꼭지점은 unvisited 상태에서 스택에 몇 번 push되는가?","전체적으로 각 edge는 몇 번 access되는가?","Time complexity","Adjacency list: O(|V|+|E|)","Adjacency matrix: O(|V|^2)"]}],[{"i":"63-shortest-path-algorithm","l":"6.3. Shortest Path Algorithm"},{"l":"Floyd-Warshall All-Pairs Shortest Path Algorithm","p":["A dynamic programming approach","An in-place implementation is possible.","cost[i][j]= \\infty if (i,j) \\notin E(G)","cost[i][j]= 0 if i=j","cost[i][j]= c_{ij} if (i,j) \\in E(G)","Example: k = 4 (A_k[i][j] \\leftarrow A_{k-1}[i][j])","Given a weighted graph G = (V, E) with cost function cost[i][j], find the shortest paths between all pairs of vertices. V = \\{v_0, v_1, v_2, ..., v_{n-1} \\} with |V| = n","If the shortest path from i to j going through no vertex with index greater than k does go through the vertex with index k A^k [i][j]= $A^[i][k] + A^ [k][j] $","If the shortest path from i to j going through no vertex with index greater than k does not go through the vertex with index k A^k [i][j]= A^{k-1} [i][j]","In general, the cost(weight) may be negative, but there must not exist a negative cycle in the graph.","Initialization / Table traversal order","Let A^k [i][j] be the cost of the shortest path from i to j, using only those intermediate vertices with an index ≤ k.","O(n^3) time","Optimal substructure for computing A^k [i][j] from A^{k-1} [i][j]","Path reconstruction","Problem","ref","The goal is to compute A^{n-1} [i][j] \\forall i,j = 0,1,2,...,n-1","The table computation"]}],[{"i":"641-minimum-spanning-trees","l":"6.4.1. Minimum Spanning Trees","p":["A forest is a graph with no cycles.","A minimum spanning tree for a weighted graph G = (V, E) is a spanning tree of least cost.","A naïve approach","A spanning tree for a graph G = (V, E) is a tree that contains all the vertices of G.","A tree is a connected graph T that contains no cycle.","Any two vertices of T are connected by exactly one path.","Buy-Two-Get-One-Free Theorem","Examine all the spanning trees of G, and take one having least cost.","For a graph G = (V, E) with n vertices, any two of the following three properties imply the third one:","Forest","G has n-1 edges.","G is acyclic.","G is connected.","Given a weighted graph G = (V, E), find a minimum spanning tree of G.","https://en.wikipedia.org/tree","https://www.mathreference.org/","Minimum spanning tree","Other equivalent statements ( T = (V, E) where |V| = n)","Problem","references","T contains no cycles, and has n-1 edges.","T contains no cycles, but the addition of any new edge creates exactly one cycle.","T is connected, and has n-1 edges.","The cost of a spanning tree of a weighted graph G = (V, E) is the sum of the weights of the edges in the spanning tree.","There are n^{n-2} spanning trees in K_n!","Tree","wiki"]}],[{"i":"642-kruskals-algorithm-vs-prims-algorithm-greedy","l":"6.4.2. Kruskal’s Algorithm vs Prim’s Algorithm (Greedy!)","p":["ref. Courtesy of T. Cormen et al.","Kruskal’s algorithm","In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest.","Prim’s algorithm","In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex."]},{"l":"Generic MST Algorithm and its Correctness","p":["Generic algorithm for a graph G = (V, E) with a weight function w","For an edge set A that is a subset of some MST, an edge (u, v) is called a safe edge for A if A \\cup \\{(u, v)\\} is also a subset of some MST.","Loop invariant for a set of edges A• Prior to each iteration, A is a subset of some minimum spanning tree.","Some definitions","Courtesy of T. Cormen et al.","A cut(S, V-S) of G is a partition of V.","An edge (u, v) of G crosses a cut (S, V-S) if u \\in S and v \\in V-S→ cut-set.","A cut respects a set A of edges if no edge in A crosses the cut.","An edge is a light edge crossing a cut if its weight is the minimum of any edge crossing the cut."]},{"l":"Cut Property","p":["For any cut C of the graph, if the weight of an edge e in the cut-set of C is strictly smaller than the weights of all other edges of the cut-set of C, then this edge belongs to all MSTs of the graph.","Proof:","Assume that there is an MST T that does not contain e.","Adding e to T will produce a cycle, that crosses the cut once at e and crosses back at another edge e'.","Deleting e' we get a spanning tree T∖\\{e'\\} \\cup \\{e\\} of strictly smaller weight than T. This contradicts the assumption that T was a MST.","By a similar argument, if more than one edge is of minimum weight across a cut, then each such edge is contained in some minimum spanning tree.","Loop invariant for the set A","Prior to each iteration, A is a subset of some minimum spanning tree.","Theorem","Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E.","Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A."]},{"i":"selection-of-next-edge-kruskals-algorithm","l":"Selection of Next Edge: Kruskal’s Algorithm","p":["In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest."]},{"i":"selection-of-next-edge-prims-algorithm","l":"Selection of Next Edge: Prim’s Algorithm","p":["In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.","Theorem","Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A."]},{"i":"kruskals-minimum-spanning-tree-algorithm","l":"Kruskal’s Minimum Spanning Tree Algorithm","p":["Idea","Finds an edge of the least possible weight that connects any two trees in the forest.","Implementation using disjoint-set data structure","매 단계 forest를 어떻게 관리할 것인가?","두 tree를 어떻게 병합할 것인가?","매 단계 $(u, v)$를 어떻게 선택할 것인가?","Complexity","Sort the edges by weight: O(E \\log E)","Process the edges until a tree is built: O(E \\log V)","O(E \\log E + E \\log V) = O(E \\log V)","why?","0 \\leq E \\leq O(V^2), \\log E \\leq \\log V^2"]},{"i":"an-implementation-of-the-kruskals-algorithm","l":"An implementation of the Kruskal’s algorithm","p":["geeksforgeeks"]},{"i":"prims-minimum-spanning-tree-algorithm","l":"Prim’s Minimum Spanning Tree Algorithm","p":["Idea","In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.","Algorithm","A key issue in implementation","Tree vertices와 non-tree vertices들을 어떻게 관리할 것인가?","Tree vertices와 non-tree vertices들 간의 최소 비용 edge를 어떻게 (효율적으 로) 찾을 것인가?","From Prof. Kenji Ikeda's Home Page"]},{"i":"inductive-description-of-the-prims-algorithm","l":"Inductive Description of the Prim’s Algorithm","p":["$ V={ v_0,v_1,v_2,...,v_} with|V| = n$","T^k →T^{k+1}","매번 가장 비용이 낮은 fringe edge를 선택하여 T^k 로 옮긴 후 그에 따른 처리를 함."]},{"i":"an--implementation-adjacency-matrix-사용","l":"An O(n^2) Implementation: Adjacency Matrix 사용","p":["a = 0, b = 1, c = 2, d = 3, e = 4, \\\\f = 5, g = 6, h = 7, i = 8, j = 9","st[i]: T 로 선택된 vertex i의 parent vertex 번 호 저장","fr[i]: NT 에 있는 vertex i에서 T 에 있는 vertex 중 가장 가까운 vertex의 번호","wt[i]: NT 에 있는 vertex i에 대해 그 vertex 에서 fr[i] 까지의 거리","n=|V|","모든 계산이 끝난 후 wt[i]는 어떤 정보를 가지고 있을까?"]},{"i":"an--implementation-adjacency-list-사용","l":"An O(e \\log n) Implementation: Adjacency List 사용","p":["n = | V |, e = | E |","Observations","The inner for-loop in the O(n^2) implementation visits all the vertices to update wt[] array and to find the minimum.","An O(e \\log n) time implementation is possible.","If the graph is dense, n^2 \\log n","If the graph is sparse, n \\log n","0 \\leq e \\leq \\frac{n(n-1)}{2}, O(n) \\leq e\\sim \\frac {n^2}{\\log n} \\leq O(n^2)","We need to employ the priority queue that allows","to insert a new item ( PQinsert(w))","to delete the minimum item ( w = PQdelmin())","to change the priority of an arbitrary specified item ( PQdec(w))."]}],[{"i":"643-shortest-paths-problems","l":"6.4.3. Shortest-Paths Problems","p":["dijstra@datascience","Single-source shortest-paths problem","Dijkstra’s algorithm","Only nonnegative-weight edges are present.","Bellman-Ford algorithm","Negative-weight edges may be present, but there are no negative-weight cycles.","Single-destination shortest-paths problem","Singe-pair shortest-path problem","All-pairs shortest-paths problem","Floyd-Warshall algorithm","Johnson’s algorithm for sparse graphs","The optimal-substructure property of shortest paths","Subpaths of shortest paths are shortest paths!"]},{"l":"Single-Source Shortest Path","p":["Problem","Given a weighted directed graph G = (V, E) with a weighting function w(e) (w(e) ≥ 0 for the edges in G), and a source vertex v_0, find a shortest path from v_0 to each of the remaining vertices of G.","Note","The case of an undirected graph can be handled by simply replacing each undirected edge e = (u, v) of length w(e) by two directed edges (u, v) and (v, u), each of the same length.","Only the case of a directed graph whose weights are positive (or nonnegative) is handled by the Dijkstra’s algorithm. For a graph that allows a negative weight, the Bellman-Ford algorithm is one to be used.","Before learning the single-source shortest path algorithm that builds some tree, recall how the breadth first search tries to build a BFS tree.","A breadth first search tree","A tree built by the Dijkstra’s algorithm"]},{"i":"dijkstras-single-source-shortest-path-algorithm","l":"Dijkstra’s Single-Source Shortest Path Algorithm","p":["A greedy approach","Generate the shortest paths in non-decreasing order of lengths!","$S^ 1={ v_0 }$로 설정하고 시작.","($i=k$일 때) $S k$의 꼭지점들만 사용할 경우에 대한 $v_0$에서 $v$까지의 shortest path가 구해져 있음. ($v$는 $S k$의 꼭지점)","$S k$상황에서 가장 짧은 path에 대한 꼭지점 $v$를 $S k$로 옮긴 후 적절한 처리를 수행 → S^{k+1}","($i = k+1$일 때) S^{k+1} 의 꼭지점들만 사용할 경우에 대한 $v_0$에서 $v$까지의 shortest path가 구해져 있음. ($v$는 $S^{k+1}$의 꼭지점)","다시 2. 로 감","S_n 이 다 구해졌을 경우"]},{"i":"from-prof-kenji-ikedas-home-page","l":"From Prof. Kenji Ikeda's Home Page"},{"i":"dijkstras-algorithm","l":"Dijkstra’s Algorithm","p":["(from Introduction to Algorithms by T. Cormen)","A directed graph with nonnegative weight G(V, E) with w: E→ [0,∞) and source s","Two components for each vertex v","v.d: an upper bound on the weight of a shortest path from s to v(a shortest path estimate)","v.π: the predecessor of v in the (current) shortest path","Relaxation","The process of relaxing an edge (u, v) consists of testing whether we can improve the shortest path to v found so far by going through u and, if so, updating v.d and v.π.","아직 shortest path를 찾지 못한 vertex v에 대해","새롭게 선택된 vertex u에 adjacent한 vertex v에 대해"]},{"i":"dijkstras-single-source-shortest-path-algorithm-1","l":"Dijkstra’s Single-Source Shortest Path Algorithm","p":["계산과정 예","A key in the proof","adds u to S","At the start of each iteration of the while loop of lines 4-8, v.d = \\delta(s,v) for each vertex v \\in S","Correctness of Dijkstra’s algorithm","Dijkstra algorithm, run on a weighted, directed graph $ G=(V,E)$ with nonnegative weight function w : E \\rightarrow R and source s, terminates with v.d = \\delta(s,v)\\forall vertices v \\in V","Dijkstra’s algorithm","Loop invariant","Maintains a set S of vertices whose final shortest-path weight from the source s have already been determined.","relaxes all edges leaving u.","s --- x -y 가 shortest path이므로, $x$가 $S$에 add 되면서 x-y 에 relaxation할 때, y.d 에 $δ(s, y)$가 저장. 따라서 $u$가 $S$에 add 가 될 때에도 y.d= δ(s, y).","Select repeatedly the vertex u in V-S with the minimum shortest-path estimate","Suppose for contradiction that u be the first vertex for which u.d \\neq \\delta(s,u) when it is added to set S","Theorem","to show that for each vertex u \\in V, we have u.d = \\delta(s,u) at the time when u is added to set S","u.d \\leq \\delta(s,y) \\leq u.d \\rightarrow \\delta(s,u) = u.d","u.d \\leq y.d","When the algorithm adds a vertex u to the set S, u.d is the final shortest-path weight from s to u.","y.d = \\delta(s,y)","y.d = \\delta(s,y) \\leq \\delta (s,u) \\leq u.d"]},{"i":"an--implementation--adjacency-matrix-사용","l":"An O(n^2) Implementation : Adjacency Matrix 사용","p":["S: the set of vertices, including v_0, whose shortest paths have been found","distance[w]: the length of the shortest path starting from v_0, going through vertices only in S, and ending in w( w \\notin S)","Observations","When the shortest paths are generated in nondecreasing order of length,","If the next shortest path is to vertex u, then the path from v_0 to u goes through only those vertices that are in S.","Vertex u is chosen so that it has the minimum distance distance[u] among all the vertices \\notin S.","Adding u to S may change the distance of shortest paths starting at v_0 going through vertices only in the new S, and ending at a vertex w that is not currently in the new S.","distance[w] = \\min \\{distance[w], distance[u] + length(<u, w>) \\}","V = \\{ v_0, v_1, ..., v_{n-1}\\} with |V| = n","distance[i]: the length of the SP from vertex v to i","found[i]","FALSE if the SP from vertex i has not been found,","TRUE otherwise","cost[i][j]: cost adjacency matrix","code in [Horowitz]"]},{"i":"an--implementation-adjacency-list-사용","l":"An O(e \\log n) Implementation: Adjacency List 사용","p":["매 순간 $wt[w]$에는 항상 S_k 의 꼭지점들만 사용할 경우에 대한 $v_s$에서 $w$까지의 shortest path의 길이가 저장되어 있음.","wt[] 는 앞의 프로그램에서의 distance[] 에 해당","n = |V|, e = |E|","MO ̈HRING et at., Partitioning Graphs to Speedup Dijkstra’s Algorithm, ACM Journal of Experimental Algorithmics, 2006.","Standard Dijkstra’s Algorithm","Acceleration Algorithm"]}],[{"l":"고급생명과학 정리"},{"l":"BIOLOGY_hyper","p":["고급생명과학 @ Chungnam Science High School Prof. Sujeong Ryu"]},{"l":"Contents","p":["image","고급생명과학","세포의 에너지","세포의 구성분자","광합성, 외호흡과 내호흡","세포 호흡","생물의 조절과 방어","신경에 의한 조절","호르몬에 의한 조절","면역 1, 2","유전자의 구조와 발현","염색체","유전자의 발현"]}],[{"l":"Computer Vision"},{"l":"Computer Vision"},{"l":"CNN Architecture","p":["AlexNet: ImageNet Classification with Deep Convolutional Neural Networks","DenseNet:","EfficientNet:( note)","GoogLeNet: Going Deeper with Convolutions","Inception-v1: GoogLeNet","Inception-v2, v3: Rethinking the Inception Architecture for Computer Vision ( note, code)","Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning","InceptionNet:","NASNet: Learning Transferable Architectures for Scalable Image Recognition ( note, code)","NIN: Network in Network","ResNet-v1: Deep Residual Learning for Image Recognition ( note)","ResNet-v2: Identity Mappings in Deep Residual Networks","ResNet:","VggNet: Very Deep Convolutional Networks for Large-Scale Image Recognition","Wide Residual Networks ( note, code)","ZFNet (DeconvNet): Visualizing and Understanding Convolutional Networks ( pdf, note, code)"]},{"l":"Visualizing CNNs","p":["DeconvNet","BP: Deep inside convolutional networks: Visualising image classification models and saliency maps ( note)","Guided-BP (DeconvNet+BP): Striving for simplicity: The all convolutional net ( note, code)","Understanding Neural Networks Through Deep Visualization"]},{"l":"Weakly Supervised Localization","p":["From Image-level to Pixel-level Labeling with Convolutional Networks (2015)","GMP-CAM: Is object localization for free? - Weakly-supervised learning with convolutional neural networks (2015) ( note, code)","GAP-CAM: Learning Deep Features for Discriminative Localization (2016) ( note, code)","c-MWP: Top-down Neural Attention by Excitation Backprop","Grad-CAM: Visual Explanations from Deep Networks via Gradient-based Localization (2017) ( note, code)"]},{"l":"Object Detection","p":["OverFeat - Integrated Recognition, Localization and Detection using Convolutional Networks ( note, code)"]},{"l":"Semantic Segmentation","p":["3D / Point Cloud","DeepLabv3+ (2018) ( note)","DeepMask","EncNet (2018)","FastFCN (2019)","FCN + 모든 레이어에서 skip 사용: U-Net (2015) ( note)","FCN + atrous convolution과 CRF를 사용: DeepLap V2 (2016)","FCN + Dilated convolutions 사용: Multi-Scale Context Aggregation by Dilated Convolutions (2015)","FCN + global context 반영 위해 global pooling 사용: ParseNet (2015)","FCN + max-pooling indices를 사용: SegNet V2 (2015) ( note)","FCN + Multi-scale: Predicting Depth, Surface Normals and Semantic Labels with a Common Multi-Scale Convolutional Architecture (2015)","FCN 개선: Fully Convolutional Networks for Semantic Segmentation (FCN_V2, 2016) ( note, code)","FCN_V1 (2014)에서 직접적인 영향을 받은 모델들:","Instance Segmentation","Mask R-CNN (2017) ( note)","PointNet (2017)","PSPNet (2016) ( note)","SGPN (2017)","SharpMask","Weakly-supervised Segmentation","x"]},{"l":"Style Transfer","p":["A Neural Algorithm of Artistic Style (2015)","Image Style Transfer Using Convolutional Neural Networks (2016)","Perceptual Losses for Real-Time Style Transfer and Super-Resolution (2016)","Instance Normalization:","Instance Normalization: The Missing Ingredient for Fast Stylization (2016)","Improved Texture Networks: Maximizing Quality and Diversity in Feed-forward Stylization and Texture Synthesis (2017)"]},{"i":"siamese-triplet-network","l":"Siamese, Triplet Network","p":["Triplet Network","FaceNet: A Unified Embedding for Face Recognition and Clustering ( note, code)","Learning Fine-grained Image Similarity with Deep Ranking ( note, code)","Siamese Network"]},{"l":"Mobile","p":["Shufflenet: An extremely efficient convolutional neural network for mobile devices","Mobilenets: Efficient convolutional neural networks for mobile vision applications"]},{"i":"etc","l":"Etc.","p":["A guide to convolution arithmetic for deep learning ( note)"]}],[{"l":"Contact"},{"l":"How to reach me","p":["link"]}],[{"l":"Retype Software License Agreement"},{"i":"version-182","l":"Version 1.8.2","p":["THIS DOCUMENT IS A LEGAL AGREEMENT (the \"License Agreement\") BETWEEN OBJECT.NET, INC. (\"We,\" \"Us\") AND YOU OR THE ORGANIZATION ON WHOSE BEHALF YOU ARE UNDERTAKING THE LICENSE DESCRIBED BELOW (\"You\",\"Your\") IN RELATION TO THE RETYPE SOFTWARE LIBRARY(IES) (THE \"Software\"), IN BOTH SOURCE AND OBJECT CODE FORM, AND/OR ALL RELATED MATERIALS.","BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING THE SOFTWARE, YOU ACCEPT THE FOLLOWING TERMS AND CONDITIONS. IF YOU DO NOT AGREE WITH ANY OF THE TERMS OR CONDITIONS OF THIS LICENSE AGREEMENT, DO NOT PROCEED WITH THE DOWNLOADING, COPYING, INSTALLATION OR ANY OTHER USE OF THE SOFTWARE OR ANY PORTION THEREOF AS YOU HAVE NO RIGHTS TO DO SO. THE SOFTWARE IS PROTECTED BY UNITED STATES COPYRIGHT LAWS AND INTERNATIONAL COPYRIGHT LAWS, AS WELL AS OTHER INTELLECTUAL PROPERTY LAWS AND TREATIES. THE SOFTWARE IS LICENSED, NOT SOLD.","THIS LICENSE AGREEMENT DESCRIBES YOUR RIGHTS AND RESTRICTIONS WITH RESPECT TO THE SOFTWARE AND ITS COMPONENTS."]},{"l":"1. DEFINITIONS","p":["\"Application\" means any software, application, or elements that Your Designated Users develop using the Software or Modifications in accordance with this Agreement; provided that any such Application(i) must have substantially different functionality than the Software, and (ii) must not allow any third party to use the Software or Modifications, or any portion thereof, for software development or application development purposes.","\"Designated User\" shall mean a single distinct person for whom You have purchased a license to use the Software, whether such person is an employee acting within the scope of their employment with You or Your consultant or contractor acting within the scope of the services they provide for You. A Designated User can be replaced with a new Designated User only after being a Designated User for a minimum of six (6) months.","\"End User\" means an end user of Your Application who acquires a license to such solely for their own internal use and not for distribution, resale, user interface design, or software development purposes.","\"Modification\" means: a) any addition to or deletion from the contents of a file included in the original Software or previous Modifications created by You, and/or b) any new file that leverages any part of the original Software or previous Modifications.","\"Sample Code\" means sample source code included with the Software and designated as \"sample code,\"\"samples,\" \"sample application code,\" and/or \"snippets,\" and/or found in directories labeled\"samples\", \"learn\", \"docs\", \"examples\" or \"examples explorer\"."]},{"l":"2. LICENSE GRANT","p":["Subject to the payment of the fee required, and subject to your compliance with all of the terms and conditions of this Agreement, We grant to You a revocable, non-exclusive, non-transferable and non-sublicensable license (i) for Designated User(s) to use the Software to create Modifications and Applications; (ii) for You to distribute the Software and/or Modifications to End Users solely as integrated into the Applications; and (iii) for End Users to use the Software as integrated into Your Applications in accordance with the terms of this Agreement.","In addition to the other terms contained herein, We grant to You a revocable, non-exclusive, non-transferable and non-sublicensable license to install and use the Software (the \"Free License\") for Your internal evaluation, review, and production purposes. The Free License may contain restricted functionality. You are explicitly not permitted to distribute the Software to any user outside the Organization on whose behalf you have undertaken this license. We reserve the right to terminate Your License at any time in Our absolute and sole discretion. Without the purchase and inclusion of a License Key, the Software may contain restricted functionality, which from time-to-time may differ in its limitations. If you wish to remove these restrictions, you are required to purchase a Retype License Key; otherwise you must leave this limitation intact and not attempt to modify or circumvent it in any way.","In addition to the other terms contained herein, in the event You have downloaded or received beta or pre-release versions of the Software (the \"Beta Software\") from Us, We grant to You a revocable, non-exclusive, non-transferable and non-sublicensable license to install and use the Beta Software strictly for Your internal evaluation and review purposes and not for production purposes (the\"Beta License\"). You are explicitly not permitted to distribute the Software to any user outside the Organization on whose behalf you have undertaken this license. Your rights to use the Beta Software will immediately terminate upon the earlier of (i) the expiration of the evaluation period established by Us, or (ii) such time that You purchase a license to a non-evaluation version of the Software. We reserve the right to terminate Your Beta License at any time in Our absolute and sole discretion.","YOU ACKNOWLEDGE THAT TRIAL AND/OR BETA SOFTWARE MIGHT PLACE WATERMARKS ON OUTPUT, CONTAIN LIMITED FUNCTIONALITY, FUNCTION FOR A LIMITED PERIOD OF TIME, OR LIMIT THE FUNCTIONALITY OR TIME OF FUNCTIONING OF ANY OUTPUT. ACCESS TO AND/OR USE OF ANY FILES OR OUTPUT CREATED WITH SUCH SOFTWARE IS ENTIRELY AT YOUR OWN RISK. WE ARE LICENSING THE SOFTWARE ON AN \"AS IS\" BASIS AT YOUR OWN RISK AND WE DISCLAIM ANY WARRANTY OR LIABILITY TO YOU OF ANY KIND.","You may modify the \"Sample Code\" solely for the purposes of designing, developing and testing Your own Applications. However, You are permitted to use, copy and redistribute Your modified Sample Code only if all of the following conditions are met: (a) You include Our copyright notice (if any) with Your Application, including every location in which any other copyright notice appears in such Application; and (b) You do not otherwise use Our name, logos or other of Our trademarks to market Your Application, unless otherwise agree by Us in writing."]},{"l":"3. OWNERSHIP","p":["This is a license agreement and not an agreement for sale. We reserve ownership of all intellectual property rights inherent in or relating to the Software, which include, but are not limited to, all copyright, patent rights, all rights in relation to registered and unregistered trademarks(including service marks), confidential information (including trade secrets and know-how) and all rights other than those expressly granted by this Agreement.","We may provide You with source code so that You can create Modifications and Applications. While You retain all rights to any original work authored by You as part of the Modifications, We continue to own all copyright and other intellectual property rights in the Software.","You must not remove, obscure or interfere with any copyright, acknowledgment, attribution, trademark, warning or disclaimer statement affixed to, incorporated in or otherwise applied in connection with the Software."]},{"l":"4. PROHIBITED USES","p":["You may not redistribute the Software or Modifications other than by including the Software or a portion thereof within Your Application. You may not redistribute the Software or Modifications as part of any Application that can be described as a development toolkit or library, an application builder, a website builder or any Application that is intended for use by software, application, or website developers or designers. You may not redistribute any part of the Software documentation. You may not change or remove the copyright notice from any of the files included in the Software or Modifications.","UNDER NO CIRCUMSTANCES MAY YOU USE THE SOFTWARE FOR AN APPLICATION THAT IS INTENDED FOR SOFTWARE OR APPLICATION DEVELOPMENT PURPOSES.","UNDER NO CIRCUMSTANCES MAY YOU USE THE SOFTWARE (INCLUDING WITHOUT LIMITATION THE SOURCE CODE THEREOF) AS THE BASIS FOR OR IN CONNECTION WITH A PRODUCT THAT CONTAINS THE SAME, OR SUBSTANTIALLY THE SAME, FUNCTIONALITY AS THE SOFTWARE.","You are required to ensure that the Software is not reused by or with any applications other than those with which You distribute it as permitted herein. For example, if You install the Software on a customer's server, that customer is not permitted to use the Software independently of Your Application, and must be informed as such."]},{"l":"5. TERMINATION","p":["This Agreement and Your right to use the Software and Modifications will terminate immediately if You fail to comply with any of the terms and conditions of this Agreement. Upon termination, You agree to immediately cease using and destroy the Software or Modifications, including all accompanying documents. The provisions of sections 4, 5, 6, 7, 8, 9, and 11 will survive any termination of this Agreement."]},{"l":"6. DISCLAIMER OF WARRANTIES","p":["TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, WE AND OUR RESELLERS DISCLAIM ALL WARRANTIES AND CONDITIONS, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND TITLE AND NON-INFRINGEMENT, WITH REGARD TO THE SOFTWARE. WE DO NOT GUARANTEE THAT THE OPERATION OF THE SOFTWARE OR THE CODE IT PRODUCES WILL BE UNINTERRUPTED OR ERROR-FREE, AND YOU ACKNOWLEDGE THAT IT IS NOT TECHNICALLY PRACTICABLE FOR US TO DO SO."]},{"l":"7. LIMITATION OF LIABILITIES","p":["TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL WE OR OUR RESELLERS BE LIABLE UNDER ANY LEGAL OR EQUITABLE THEORY FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION OR ANY OTHER PECUNIARY LAW) ARISING OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE OR THE CODE IT PRODUCES OR ANY OTHER SUBJECT MATTER RELATING TO THIS AGREEMENT, EVEN IF WE OR OUR RESELLERS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY CASE, OUR ENTIRE LIABILITY WITH RESPECT TO ANY SUBJECT MATTER RELATING TO THIS AGREEMENT SHALL BE LIMITED TO THE GREATER OF (I) THE AMOUNT ACTUALLY PAID BY YOU FOR THE SOFTWARE OR (II) ONE HUNDRED DOLLARS ($100)."]},{"l":"8. PAYMENT AND TAXES","p":["If credit has been extended to You by Us, all payments under this Agreement are due within thirty(30) days of the date We mail an invoice to You. If We have not extended credit to You, You shall be required to make payment concurrent with the delivery of the Software by Us. Any value added tax, use tax, sales tax or similar tax (\"Transaction Taxes\") shall be your sole responsibility. Each party shall pay all taxes (including, but not limited to, taxes based upon its income) or levies imposed on it under applicable laws, regulations and tax treaties as a result of this Agreement and any payments made hereunder (including those required to be withheld or deducted from payments); provided that You shall be responsible for all Transactions Taxes and shall pay or reimburse Us for the same upon invoice. Each party shall furnish evidence of such paid taxes as is sufficient to enable the other party to obtain any credits available to it, including original withholding tax certificates. Notwithstanding the foregoing, Software ordered through Our resellers is subject to the fees and payment terms set forth on the applicable reseller invoice."]},{"l":"9. MISCELLANEOUS","p":["The license granted herein applies only to the version of the Software available when purchased in connection with the terms of this Agreement, and to any updates and/or upgrades to which you may be entitled. Any previous or subsequent license granted to You for use of the Software shall be governed by the terms and conditions of the agreement entered in connection with purchase or download of that version of the Software. You agree that you will comply with all applicable laws and regulations with respect to the Software, including without limitation all export and re-export control laws and regulations.","While redistributing the Software or Modifications thereof as part of Your Application, You may choose to offer acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this Agreement. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on our behalf. You shall indemnify Us and our resellers, or at Our option, defend Us and our resellers against any claim, suit or proceeding brought against Us or our resellers (i) arising by reason of Your accepting any such support, warranty, indemnity or additional liability; or (ii) arising out of the use, reproduction or distribution of Your Application, except to the extent such claim is solely based on the inclusion of the Software therein. Further, You agree only to distribute the Software pursuant to an enforceable written agreement for Our benefit that includes all the limitations and restrictions of this Agreement and is as protective of Us and Software as is this Agreement. For clarity, You must purchase Designated User licenses for each contractor or consultant who uses the Software to create an Application on your behalf (including system integrators), whether or not such contractor or consultant has its own license to the Software.","You agree to be identified as a customer of ours and You agree that We may refer to You by name, trade name and trademark, if applicable, and may briefly describe Your business in our marketing materials and web site.","You may not assign or transfer this Agreement without Our prior written consent. This Agreement may be assigned by Us in whole or part and will inure to the benefit of Our successors and assigns. Notwithstanding the foregoing, in any instance in which You transfer ownership of an Application on a work for hire basis, You may assign licenses for the total Designated Users that have used the Software to develop said Application under this Agreement to another party (Assignee) provided (i) you provide written notice to Us prior to the effective date of such assignment; and(ii) there is a written agreement, wherein the Assignee accepts the terms of this Agreement. Upon any such transfer, the Assignee may appoint new Designated Users.","You acknowledge that this Agreement is complete and is the exclusive representation of our agreement. No oral or written information given by Us, Our resellers, or otherwise on Our behalf shall create a warranty or collateral contract, or in any way increase the scope of this Agreement in any way, and You may not rely on any such oral or written information. No term or condition contained in any purchase order shall have any force or effect.","There are no implied licenses or other implied rights granted under this Agreement, and all rights, save for those expressly granted hereunder, shall remain with Us and our licensors. In addition, no licenses or immunities are granted to the combination of the Software and/or Modifications, as applicable, with any other software or hardware not delivered by Us or Our resellers to You under this Agreement. Your rights under this Agreement apply only to Software, Modifications, and/or Applications for which all Designated Users are duly licensed hereunder.","If any provision in this Agreement shall be determined to be invalid, such provision shall be deemed omitted; the remainder of this Agreement shall continue in full force and effect. If any remedy provided is determined to have failed for its essential purpose, all limitations of liability and exclusions of damages set forth in this Agreement shall remain in effect.","This Agreement may be modified only by a written instrument signed by an authorized representative of each party. The failure of either party to enforce any provision of this Agreement may not be deemed a waiver of that or any other provision of this Agreement.","This Agreement is governed by the law of the Province of Alberta, Canada and all parties irrevocably submit to the jurisdiction of the courts of the Province of Alberta and further agree to commence any litigation which may arise hereunder in the courts located in the judicial district of Edmonton, Alberta, Canada.","If the Software or any related documentation is licensed to the U.S. Government or any agency thereof, it will be considered to be \"commercial computer software\" or \"commercial computer software documentation,\" as those terms are used in 48 CFR 12.212 or 48 CFR 227.7202, and is being licensed with only those rights as are granted to all other licensees as set forth in this Agreement."]}],[{"l":"Roadmap","p":["The entire package release history of Retype is available on NPM or NuGet.","Need a new feature in Retype? Start a discussion and let's chat. \uD83D\uDCAC"]},{"i":"v200","l":"v2.0.0","p":["Expected: 2022","Full support for C# API reference doc generation","Early support for TypeScript API reference doc generation","Many more features planned"]},{"i":"v1100","l":"v1.10.0","p":["Expected: Early Q4 2021","New partials support","New variables support","Another beta release of building C# project reference documentation","Any feature requests? Please let us know"]},{"l":"v1.9.0","p":["Expected: Mid Q3 2021","Improved link resolution","Improved handling of Docusaurus, MkDocs, and GitBook config files","New page dependecy graph to improve incremental build performance ⚡ \uD83D\uDCAF ⚡","Any feature requests? Please let us know"]},{"l":"v1.8.2","p":["Released: 2021-08-06","Update expired NPM Access Token to fix broken NPM package publishing from v1.8.1"]},{"i":"v181","l":"v1.8.1","p":["Released: 2021-08-05","Add broader checks for unresolved links, see #112. For instance, if a link to ../components is created, Retype will now try to resolve the path to any of the following:","Allow inline Markdown components for author, title, and label page configs, see #114. Block-level Markdown components will be ignored for those configs.","This release failed to run properly if the NPM package was installed. \uD83E\uDDD0 We didn't notice that our NPM Access Token had expired between the v1.8.0 and v1.8.1 releases. The expired NPM token caused our automated release process to fail. Sorry about that. \uD83D\uDE29 Once we figured out what was going wrong, a new NPM Access Token was set and v1.8.2 was released. We have added NPM token pre-checks and verifications to the automated release process to hopefully prevent the issue from ever happening again."]},{"i":"v180","l":"v1.8.0","p":["Fix excessive bottom padding on blockquotes, see #74","Improve the CLI experience, see #103","New /blog summary for any .md page added to a /blog folder","New author, category, and date page configs","New auto-generate a robots.txt file","New auto-generate a sitemap.xml file to inform search engines which pages to crawl","New automated process to check for new Octicons release and merge update","New Open Graph and Twitter meta tags generated for every page","New process to handle the manual creation of a CNAME file and copy to output","New redirect page config","New retype.yml project configuration file format","New server.host and server.port project configs","New url project config for setting your website URL","New visibility page config","Released: 2021-08-03","Update to latest Octicons icon release"]},{"i":"v170","l":"v1.7.0","p":["Released: 2021-06-24","New Column component","New stacking Panels component","New Open Graph and Twitter card support","New Mermaid diagram and visualization support","New target config for all links within retype.yml","New default page support for default.md","New hover style on Badge component when links","Super improved handling of áccënt characters"]},{"i":"v160","l":"v1.6.0","p":["Released: 2021-06-09","New tags config for pages","New :icon-shortcode: component","New include project config","New exclude project config","Improved table styling","Performance boost for components","Dozens of enhancements, optimizations, and adjustments"]},{"i":"v150","l":"v1.5.0","p":["Released: 2021-05-12","New Badge component","New syntax highlighting support for all code block languages","New route page config","New port project config","Larger font-size for h1, h2, and h3 headers","Improved handing of special characters within file names","Improved handling of .md pages created by GitHub Wiki"]},{"i":"v140","l":"v1.4.0","p":["Released: 2021-04-12","Even cleaner upgrade to Retype from GitBook experience","New super fast retype watch incremental build process","New image alignment and captions","New exclude config for retype.yml","New blog layout and /blog folder defaults","New [!file] component","New [!ref] component","Many other minor enhancements and bug fixes"]},{"i":"v130","l":"v1.3.0","p":["Released: 2021-03-30","New GitHub Actions for Retype","New expanded config on folder configuration","New icon and iconAlign configs on links","Several important bug fixes"]},{"i":"v120","l":"v1.2.0","p":["Released: 2021-03-25","New central layout","New page layout","New Edit this page link","New Previous | Next footer navigation buttons for pages","New order Page level config","New ~~ hidden visibility Page level config","New favicon Project config available in retype.yml","New beta release of building C# project reference documentation"]},{"i":"v110","l":"v1.1.0","p":["Released: 2021-03-12","New Tab component","New Button component","New Panel component with expand/collapse","New retype watch command","New Live Reload when using retype watch","New .yml option for Page or Folder configs","New code block title","Enable line numbering in code blocks"]},{"i":"v100","l":"v1.0.0","p":["Released: 2021-02-11","Publish to NPM","Publish to NuGet","Initial v1.0.0 release"]}]]