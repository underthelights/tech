---

# title: 1.4. MSS 
tags: alg
category: alg
picture_frame: shadow
use_math: true

---
> ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•© Maximum Subsequence Sum

# Maximum Subsequence Sum (MSS) Problem

-  $Ref.$ **[M. Weiss,** **Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]** 

   - Given $N$ (possiblly negative) $A_0, A_1, ..., A_{N-1} \in \mathbb{Z}$ 
   - find the maximum value of $\sum_{k=i}^{j} {A_k }$ for $0 \leq i \leq j \leq N-1$ 
   - for convenience, the max subseuqence sum is 0 if all the integers 're <0


-  Example

   - (-2, 11, -4, 13, -5, -2).  â†’  MSS = 20
    
      <img width="395" alt="ìŠ¤í¬ë¦°ìƒ· 2021-06-13 ì˜¤í›„ 4 00 54" src="https://user-images.githubusercontent.com/46957634/121798325-9abdf880-cc60-11eb-915f-e6c439a2810c.png">
-  Maximum Subarray Problem
-  Maximum Positive Sum Subarray Problem
-  Max. Sum Subsequence versus Max. Subsequence Sum


# Alg of Maximum Subsequence Sum

- ê¸¸ì´ $n$ì¸ ì •ìˆ˜ì˜ ìˆ˜ì—´ $a_0, a_1, ..., a_{n-1}$ ì´ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì ¸ ìˆë‹¤.
- ì—¬ê¸°ì„œ ë¶€ë¶„ ìˆ˜ì—´ [i, j]ë¼ëŠ” ê²ƒì€ $a_i, a_{i+1}, a_{i+2}..., , a_{j}$ ë¥¼ ë§í•œë‹¤.

- ë³¸ ë¬¸ì œëŠ” ì£¼ì–´ì§„ ìˆ˜ì—´ì˜ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©,ì¦‰ $\sum_{i \leq k \leq j} {a_k}$ ì˜ ìµœëŒ€ê°’ì„ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤. (ì´ë•Œ ì£¼ì–´ì§„ ìˆ˜ì—´ì˜ ì •ìˆ˜ê°€ ëª¨ë‘ ìŒìˆ˜ì´ë©´ ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©ì€ 0 ì´ë¼ê³  ê°„ì£¼í•œë‹¤)
  - ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒê³¼ ê°™ì€ ìˆ˜ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ,
    $+ 31, âˆ’41, +59, +26, âˆ’53, +58, +97, âˆ’93, âˆ’23, +84$
    ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì€ $[2,6]$ì´ë©° ìˆ˜ì—´ì˜ í•©ì€ $187$ ì´ ëœë‹¤. 


- ì´ ë¬¸ì œëŠ” ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ì˜ í•©ì„ êµ¬í•˜ëŠ” ê²ƒì´ì§€ë§Œ, ì•ìœ¼ë¡œ ì†Œê°œí•  ì•Œê³ ë¦¬ì¦˜ì„ ì¡°ê¸ˆë§Œ ìˆ˜ì •í•˜ë©´ ìµœëŒ€ ë¶€ë¶„ ìˆ˜ì—´ë„ ì‰½ê²Œ êµ¬í•  ìˆ˜ ìˆë‹¤. 

  > Algorithm1 : ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ ì°¾ê¸° - $O(N^3)$
  > Algorithm2 : Sumêµ¬í•  ë•Œ ì¤‘ë³µ ì¡°ê¸ˆ í”¼í•˜ê¸° - $O(N^2)$
  > Algorithm3 : Divide n Conquer - $O(N log N)$
  > Algorithm4 : Dynamic Programming - $O(N)$
  - ![image](https://user-images.githubusercontent.com/46957634/122639250-de6aa380-d133-11eb-9a3a-b43a8519b070.png)

# MSS Algorithm 1

- Strategy
  - Enumerate all possibilities one at a time.
  - No efficiency is considered, resulting in a lot of unnecessary computation!

    ```
    Maxsum = 0
    for (i=0; i < n; i++){
        for (j=i; j < n; j++){
            Thissum = sum(A[i:j])
          	Maxsum = max(Thissum, Maxsum)
        }
    }
    ```
    
  - ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ í•˜ë‚˜í•˜ë‚˜ ëª¨ë‘ ë”°ì ¸ë³´ëŠ” ë°©ë²•.

    ```c++
    int MaxSubsequenceSum(const int A[], int N){
    int ThisSum, MaxSum, i, j, k;
      //i = ë¦¬ìŠ¤íŠ¸ ì™¼ìª½ ë ì¸ë±ìŠ¤, j = ë¦¬ìŠ¤íŠ¸ ì˜¤ë¥¸ìª½ ë ì¸ë±ìŠ¤, ThisSum = ê³ ë ¤ ëŒ€ìƒ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ í•©, MaxSum = ë¬¸ì œ ìµœì¢…ê²°ë¡ 
    MaxSum = 0;
    for (i = 0; i < N; i++)
        for (j = i; j < N; j++)
        {
            ThisSum = 0;
            for (k = i; k <= j; k++)
                ThisSum += A[k];
            if (ThisSum > MaxSum)
                MaxSum = ThisSum;
        }
    return MaxSum;
    }
    
    ```

  - Is this for-loop OK for you?
  - Time Complexity : $O(N^3)$
    - ğ‘–ì™€ ê´€ë ¨ëœ ë°˜ë³µë¬¸ì€ ğ‘›në²ˆ, ğ‘—ì™€ ê´€ë ¨ëœ ë°˜ë³µë¬¸ì€ ìµœëŒ€ ğ‘›ë²ˆ, Thissumì„ êµ¬í•  ë•Œ ìµœëŒ€ ğ‘›ê°œì˜ ìš”ì†Œë¥¼ ê³„ì‚°í•´ì•¼ í•˜ê¸°ì—
    - $\sum_{i=0}^{N-1} \sum_{j=i}^{N-1} \sum_{k=i}^{j} 1 = \frac{N^3 + 3N^2 + 2N}{6}$
    - $\sum_{j=i}^{N-1}\ (j-i+1) = \frac{(N-i+1)(N-i)}{2}$
    - $\sum_{k=i}^{j} 1 = j-i+1$

# MSS Algorithm 2 

- Strategy
  - Get rid of the inefficiency in the innermost for-loop. Algorithm 1ë³´ë‹¤ ì¤‘ë³µì„ ì¤„ì´ëŠ” ë°©ë²•

  - ```
    Maxsum = 0
    for (i=0; i < n; i++){
	      for (j=i; j < n; j++){
	          Thissum = sum(A[i:j])
	        	Maxsum = max(Thissum, Maxsum)
	        }
	    }
	  ```
	
	  
	
	- Notice that $\sum_{k=i}^{j } {A_k} = A_j + \sum_{k=i}^{j-1} {A_k}$
	
	- ```c++
	  int MaxSubsequenceSum(const int A[], int N)
	  {
	    int ThisSum, MaxSum, i, j;
	    MaxSum = 0;
      for (i = 0; i < N; i++){
        ThisSum = 0;
  	    for (j = i; j < N; j++){
  		    ThisSum += A[j];
  	  	  if (ThisSum > MaxSum)
  	        MaxSum = ThisSum;
  	    }
  	  }return MaxSum;
  	}
    ```
    
  - time complexity : $O(N^2)$

# MSS Algorithm 3 

- Strategy

  - Use the Divide-and-Conquer strategy.

    - ì› ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ  í’€ê³ , ê·¸ ê²°ê³¼ë¥¼ í•©ì³ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

  - The maximum subsequence sum can be in one of three places.

    ```c++
    int MaxSubSum(const int A[], int Left, int Right){
    int MaxLeftSum, MaxRightSum;
    int MaxLeftBorderSum, MaxRightBorderSum;
    int LeftBorderSum, RightBorderSum;
    int Center, i;
      //ì¢…ë£Œì¡°ê±´
    if (Left == Right){
        if (A[Left] > 0)
    				return A[Left];
        else
            return 0;
    }
    //divide n conquer 
    Center = (Left + Right) / 2;
    //ì™¼ìª½, ì˜¤ë¥¸ìª½, ì¤‘ê°„
    MaxLeftSum = MaxSubSum(A, Left, Center);
    MaxRightSum = MaxSubSum(A, Center + 1, Right);
    MaxLeftBorderSum = 0;
    LeftBorderSum = 0;
      
    //1. left ending ëìœ¼ë¡œ í•˜ëŠ” mss
    for (i = Center; i >= Left; i--){
        LeftBorderSum += A[i];
        if (LeftBorderSum > MaxLeftBorderSum)
            MaxLeftBorderSum = LeftBorderSum;
    }
    MaxRightBorderSum = 0;
    RightBorderSum = 0;
    //2. right ending ì‹œì‘ìœ¼ë¡œ í•˜ëŠ” mss
    for (i = Center; i <= Right; i++){
        RightBorderSum += A[i];
        if (RightBorderSum > MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum;
    }
    return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
    }
    int MaxSubsequenceSum(const int A[], int N) { 
    	return MaxSubSum(A, 0, N - 1); 
    }
    
    ```

- cost : $T(n) = 2T(n/2) + cn$, $T(1) = d$

- why $O(N log N)$ ?
  - $T(n) = 2T(\frac n 2) + cn$, $T(1) = d$
    $ = 2 [ 2T(\frac n {2^2}) + c \frac n 2 ] + cn$
    $= 2^2 T [ \frac n {2^2}] + 2cn$
    $= 2^3 T [ \frac n {2^3}] + 3cn =...$
    $= 2^i T [ \frac n {2^i}] + icn$
    $= 2^{log_2 n} T(1) + log_2 n \cdot cn$
    $=nT(1) + log_2 n \cdot cn$
    $= O(n) + O(n log_2 n) = O(n log_2 n)$ 



# MSS Algorithm 4; Kadaneâ€™s algorithm 

- Strategy
  - Use the Dynamic Programming strategy. 
  - subsequence sum<0ì¸ ê²½ìš°, ë…¼ë¦¬ì ìœ¼ë¡œ ìµœëŒ€ê°’ì´ ë  ìˆ˜ ì—†ìŒì— ì°©ì•ˆí•œ ì „ëµ
  - ë§Œì•½ì— sumì´ ìŒìˆ˜ë¼ë„ ë¬´ë°©í•˜ê³  1ê°œ ì´ìƒì˜ ì›ì†Œë¡œ êµ¬ ì„±ëœ Subsequence (subarray)ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œë¼ë©´?

    ```c++
    int MaxSubsequenceSum(const int A[], int N){
        int ThisSum, MaxSum, i;
    
        ThisSum = 0; MaxSum = 0;
        for(i = 0; i < N; i++){
            ThisSum += A[i];
            if(ThisSum > MaxSum)
                MaxSum = ThisSum;
            else if(ThisSum < 0)
                ThisSum = 0;
        }
        return MaxSum;
    }
    ```
    
  - Time Complexity : $O(n)$ 
    - for i, iteration n times, and $O(1)$ for 1 calculation

  - C Implementation
    - Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks

```c++
int kadane(int *arr, int *start, int *finish, int n)
{
    int sum = 0, maxSum = INT_MIN;

    *finish = -1;
    int local_start = 0;
    for (int i = 0; i < n; ++i)
    {
        sum += arr[i];
        if (sum < 0)
        {
            sum = 0;
            local_start = i + 1;
        }
        else if (sum > maxSum)
        {
            maxSum = sum;
            *start = local_start;
            *finish = i;
        }
    }
    if (*finish != -1)
        return maxSum; 
    // at least one non-negative number.
    
    // When all numbers in the array are negative
    maxSum = arr[0];
    *start = *finish = 0;
    for (int i = 1; i < n; i++)
    {
        if (arr[i] > maxSum)
        {
            maxSum = arr[i];
            *start = *finish = i;
        }
    }
    // Empty subsequenceë¥¼ í—ˆìš©í•˜ë©´ 0ì„ ë¦¬í„´ (ì›ë˜ ë¬¸ì œ)
    // Empty subsequenceë¥¼ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©´ ìŒìˆ˜ ì¤‘ ê°€ì¥ í° ì›ì†Œë¥¼ ë¦¬í„´
    return maxSum;
}

```



##### So, why do we bother with the time complexity?
