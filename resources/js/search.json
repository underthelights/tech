[[{"l":"KyuHwan Shim","p":["Undergraduate student at Sogang University, studying Computer Science & Engineering.","My primary research goal is to develop an Human Centered AI to augment human lifestyles. I'm focusuing on studying mathematics and Deep Learning to make my skills go beyond the fundamentals and take root deeply. Nowadays i'm interested in understanding human explanations for designing AI explanations.","Currently, I'm working as a research & operating officer at OCONNECT, based on UNIST Startup. We create new products that anyone can relate to, but have easily passed, and solve the inconvenience of the underprivileged. we've developing OneStep, which is easy to plug in everywhere, everytime, anyhow."]},{"l":"Research Area","p":["My research focuses on designing a Human Centered AI system"]},{"l":"Featured Project","p":["TBA"]},{"l":"Education"},{"i":"bs--sogang-u-2019--2023","l":"B.S. @ Sogang U. 2019 ~ 2023","p":["Major in Computer Science, Deep interest in Mathematics"]},{"i":"high-school-diploma--chungnam-science-high-school","l":"High School Diploma, @ Chungnam Science High School","p":["2016 - 2018","The Informatica, Informatics student research group"]},{"l":"Military Service"},{"l":"Government Issued FIreFighter","p":["Yeongdong-gun, Chungcheongbuk-do"]},{"l":"Scholarships","p":["Alumni Scholarship, Sogang U. Alumni :: 2020","1-semester full scholarship from Sogang U. Alumni","Albatross Scholarship, Sogang U. :: 2019","1-year full scholarship for freshman who passed the application of Albatross Specialist Decision","KAIST Scholarship, Chungnam Science HS. :: 2018","from KAIST emeritus professor","MyungHak Scholarship, Chungnam Science HS. :: 2016","Myunghak scholarship"]},{"l":"Research Experience"},{"l":"Work Experience"},{"i":"oconnect-as-cheif-research-officer-201903--present","l":"OCONNECT as Cheif Research Officer (2019.03 ~ Present)","p":["UNIST UNISPART","with friends","OX Tab"]},{"l":"Contact","p":["Facebook","Instagram","LinkedIn","GitHub","Google Scholar"]}],[{"l":"1. Introduction"},{"i":"what-is-intelligence","l":"What is Intelligence?","p":["A wish-list of general characteristics of intelligence","Perception: manipulation, interpretation of data provided by sensors","Action: control, and use of effectors to accomplish a variety of tasks","Reasoning: adapting behavior to better cope with changing environments, discovery of patterns, learning to reason, plan, and act","Communication: with other intelligent agents including humans using signals, signs, icons, · · ·","Planning: formulation of plans – sequences or agenda of actions to accomplish externally or internally determined goals. . ."]},{"i":"what-is-artificial-intelligence-ai","l":"What is Artificial Intelligence (AI)?","p":["The exciting new effort to make computers think.. machines with minds","AI is the art of creating machines that perform functions that require intelligence when performed by humans","AI is the study of the computations that make it possible to perceive, reason, and act","AI is the enterprise of design and analysis of intelligent agents","Weak AI: machines could act as if they ere intelligent","Strong AI: machines that do so are actually consciously thinking (not just simulating thinking); shifted to “human-level” or “general” AI that can solve an arbitrarily wide variety of tasks, and do so as well as a human","image","Are you concerned with thought process/reasoning or behavior?","Do you want to model humans or measure against an ideal concept of intelligence, rationality?"]},{"i":"acting-humanly-turing-test","l":"Acting humanly: Turing Test","p":["Alan Turing (1950) “Computing machinery and intelligence”:","“Can machines think?” → “ Can machines behave intelligently?”","Operational test for intelligent behavior: the Imitation Game","img","Predicted that by 2000, a machine might have a 30% chance of fooling a lay person for 5 minutes","Annual Loebner prize competition (since 1990): the first prize of $100,000 to be awarded to the first program that passes the \"unrestricted\" Turing test","Suggested major components of AI: knowledge, reasoning, language understanding, learning, etc."]},{"i":"thinking-humanly-cognitive-science","l":"Thinking humanly: Cognitive Science","p":["1960s “cognitive revolution”: information-processing psychology replaced prevailing orthodoxy of behaviorism","Cognitive science brings together computer models from AI and experimental techniques from psychology to construct precise and testable theories of human mind","AI and cognitive science fertilize each other","Incorporation of neurophysiological evidence into computational models in computer vision","Combination of neuroimaging methods with machine learning techniques led to the beginnings of a capacity to “read minds” (i.e. to ascertain the semantic content of a person’s inner thoughts), shed further light on how human cognition works"]},{"i":"thinking-rationally-laws-of-thought","l":"Thinking rationally: Laws of Thought","p":["Aristotle: what are correct arguments/thought processes?","Several Greek schools developed various forms of logic: notation and rules of derivation for thoughts","Direct line through philosophy, mathematics and logic to AI, so-called logicist","Problems:","Not all intelligent behavior is mediated by logical deliberation","What is the purpose of thinking? What thoughts should I have out of all the thoughts (logical or otherwise) that I could have?"]},{"i":"acting-rationally-rational-agent","l":"Acting rationally: Rational agent","p":["This course is about designing rational agents","An agent is an entity that perceives and acts","Rational behavior: doing the right thing","The right thing: that which is expected to maximize goal achievement, given the available information","A rational agent is one that acts so as to achieve the best outcome","Caveat: computational limitations make perfect rationality unachievable → design best program for given machine resources"]},{"l":"Foundations","p":["Philosophy: logic, methods of reasoning, mind as physical system, foundations of learning, language, rationality","Mathematics: formal representation and proof, algorithms, computation, (un)decidability, (in)tractability, probability","Economics: formal theory of rational decisions","Neuroscience: physical substrate for mental activity","Psychology: experimental techniques (psychophysics, etc.), behaviorism (percept/stimulus and action/response), cognitive psychology/science (views brain as info-processing device)","Computer engineering: building efficient computers","Control theory and cybernetics: homeostatic systems, stability, simple optimal agent designs","Linguistics: knowledge representation, grammar"]},{"l":"Brief history of AI","p":[". . .","1943:","1950:","1952-69:","1956:","1965:","1966-73:","1969-79:","1980-88:","1985-95:","1988-93:","1988–:","2001–: Big data","2011–: Deep learning","agile manufacturing systems","AI discovers computational complexity;","autonomous vehicles","bioinformatics","Collapse in AI research: Progress was slower than expected;","customized software systems","data mining and knowledge discovery","Early development of knowledge-based systems","Early enthusiasm, great expectations, optimism fueled by early success on some problems thought to be hard (e.g. theorem proving);","Expert systems industry booms","Expert systems industry busts: “AI Winter”","information retrieval","internet tools: search engines, recommender systems","McCarthy, Minsky, Rochester, Shannon, et al., Dartmouth workshop: “Artificial Intelligence” adopted","McCulloch & Pitts: model of artificial neurons","Mid 1990s–present: The emergence of intelligent agents in various applications","Neural networks return to popularity","NN flourished – Hebb’s learning and its enhancement in Widrow’s adalines, Rosenblatt’s perceptrons with convergence theorem","NN research almost disappears","Resurgence of probability; general increase in technical depth, “Nouvelle AI”: ALife, GAs, soft computing","Robinson’s complete algorithm for logical reasoning (resolution)","smart devices (e.g. homes, automobiles)","Turing’s “Computing Machinery and Intelligence” introduced Turing test, ML, GA, RL","Unrealistic predictions, Herbert Simon (1957) chess champion in 10 years;"]},{"l":"State of the art","p":["AI100 st Stanford produces AI Index (aiindex.org) tracking progress","AlphaGo/AlphaGoZero/AlphaZero (for Go, chess, shogi)/AlphaStar beat human champions","Amazon, Facebook, Netflix, Spotify, YouTube, Walmart, Coupang, . . .","Atlas walks, jumps, and backflips (2016)","Autonomous planning and scheduling:","Boston Dynamics’ BigDog (2008) resembles an amimal;","Chinook defeated human checkers champion (1994), can’t lose at checkers (2007);","Climate science, . . .","DARPA Grand Challenge and Urban Challenge(2005, 2007);","DARPA’s DART (Dynamic Analysis and Replanning Tool) for automated logistic planning and scheduling for transportation, deployed during the Gulf war (1991);","Deep Blue defeated the world chess champion Garry Kasparov (1997);","Dynamic driving directions provided by Uber and Google Maps","EUROPA planning toolkit for daily operation of NASA’s Mars rovers;","Game playing:","human-level, Alexa, Siri, Cortana, Google","Image understanding:","ImageNet object recognition task, image captioning, etc.","Legged locomotion:","Machine translation:","Medicine: disease diagnosis with multimodal data","online MT systems produce adequate results","Recommendation:","Robotic vehicles:","SAXTANT system for autonomous navigation in deep space;","Speech recognition:","The IBM supercomputer Watson beat human champions on ‘Jeopardy!’ (2011);","Waymo passed landmark of 10 million miles on public roads (2018), followed by commercial robotic taxi service"]}],[{"l":"AI","p":["Book","Russell, S. and Norvig, P. (2021). Artificial Intelligence: A Modern Approach (4th edition). Pearson.","Duda, R., Hart, P., and Stork, D. (2001). Pattern Classification. Wiley.","Mitchell, T. (1997). Machine Learning. McGraw-Hill.","Schedule","Introduction","Intelligent Agents","Problem-solving thru Search","Knowledge Representation and Reasoning","Planning","Representing and Reasoning with Uncertain Knowledge","Decision-Making","Machine Learning"]}],[{"l":"Algorithm","p":["2학년 1학기까지 습득한 C/C++ 프로그래밍 능력과 자료구조 이론의 이해 및 구현 능력을 바탕으로, 컴퓨터를 통한 추상적인 문제의 효과적인 해결에 기초가 되는 알고리즘의 설계/분석/구현 기법을 익힘을 목표로 한다.","이를 위하여,","① 문제 분석/풀이 기법 도출/풀이 기법의 비용 분석 ß 주요 내용② C/C++ 언어를 통한 자신의 풀이 기법의 최적의 구현,③ 자신의 소프트웨어 구현물에 대한 분석 과정에 대하여 익히도록 한다"]},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Algorithm에 대한 정의와 complexity와 computability 개념에 대한 이해","Asymptotic analysis of time/space complexity 개념에 대한 이해","Worst-case versus average-case","Recursion 개념의 활용","(Mathematical induction을 통한) algorithm correctness 증명 능력","Dynamic set의 표현 및 응용 능력","Priority queue 구조","Disjoint set 구조","Divide-and-conquer 기법에 대한 이해 및 응용 능력","Sorting 방법에 대한 이해 및 구현 기법 습득","Dynamic programming 기법에 대한 이해 및 응용 능력","Greedy approach에 대한 이해 및 응용 능력","Graph 구조 표현 기법 구현 및 관련 알고리즘 응용 능력","Intractable Problem과 근사 알고리즘에 대한 이해 (희망 사항)"]},{"i":"예상-진도-2020학년도-2학기","l":"예상 진도 (2020학년도 2학기)","p":["W1: 9/1, 9/3 Introduction to Design and Analysis of Algorithm","W2: 9/8, 9/10 Priority Queues and Applications (Review)","W3: 9/15, 9/17 Practice of Complexity Analysis through Example Problems","W4: 9/22, 9/24 Divide-and-Conquer Techniques","W5: 9/29, 10/1추석 Divide-and-Conquer Techniques and Sorting","W6: 10/6, 10/8 Dynamic Programming Techniques","W7: 10/13, 10/15 Dynamic Programming and Applications","W8: 10/19 ~ 10/23 정확한 시험 시간은 추후 공지 예정 MIDTERM","W9: 10/27, 10/29 Greedy Techniques","W10: 11/3, 11/5 Greedy Techniques and Scheduling Algorithms","W11: 11/10, 11/12 Introduction to Graph Data Structures","W12: 11/17, 11/19 Graph Algorithms and Applications I","W13: 11/24, 11/26 Graph Algorithms and Applications II","W14: 12/1, 12/3 Introduction to NP-Completeness","W15: 12/8, 12/10 Intractable Problems and Approximation Algorithms 또는 진도 보충"]},{"l":"교재 및 참고 도서","p":["8 적절한 교재를 선택하여 관련된 내용을 자세하게 읽기를 권장함","Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983.","Aho, J. Hopcroft, and J. Ullman, Design and Analysis of Algorithms, Addison-Wesley, 1974.","Baase and A. Van Gelder, Computer Algorithms: Introduction to Design and Analysis, Addison Wesley, 2000.","Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009.","Dasgupta et al., Algorithms, McGraw-Hill Education, 2006.","Horowitz et al., Fundamentals of Data Structures in C, Computer Science Press, 1993.","Horowitz, S. Sahni and S. Rajasekaran, Computer Algorithms/C++, Computer Science Press, 1997.","Kleinberg and E. Tardos, Algorithm Design, Addison Wesley, 2005.","Levitin, Introduction to the Design and Analysis of Algorithms, Addison Wesley, 2003.","Neapolitan, Foundations of Algorithms (5th ed.), Jones & Bartlett, 2015.","Roughgarden, Algorithms Illuminated, Part 1~3, Soundlikeyourself Publishing, 2018.","Sedgewick and K. Wayne, Algorithms (4th ed.), Addison-Wesley, 2011.","Sedgewick, Algorithms in C: Parts 1-4 (3rd ed), Addison-Wesley, 1998.","Sedgewick, Algorithms in C: Parts 5 (3rd ed), Addison-Wesley, 2002.","Skiena, The Algorithm Design Manual (2nd ed.), Springer, 2008.","Weiss, Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997."]},{"l":"강의 자료 순서","p":["[주제 1] Introduction to Algorithms and Complexity","[주제 2] Heap-based Priority Queues and Heap Sort (Review)","[주제 3] Divide-and-Conquer Techniques and Sorting Techniques","[주제 4] Dynamic Programming","[주제 5] Greedy Methods","[주제 6] Graph Algorithms","[주제 7] Intractable Problems and Approximation Algorithms","[주제 8] More on Priority Queues and Hashing"]},{"l":"목표"}],[{"i":"1-intro--complexity","l":"1. Intro & Complexity"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Algorithm에 대한 정의와 complexity와 computability 개념에 대한 이해","Asymptotic analysis of time/space complexity 개념에 대한 이해","Worst-case versus average-case","Recursion 개념의 활용","(Mathematical induction을 통한) algorithm correctness 증명 능력"]}],[{"i":"10-computational-thinking","l":"1.0. Computational Thinking"},{"l":"Definition of computational thinking","p":["The thought processes involved in(i) formulating a problem and(ii) expressing its solutions in such a way that a computer --human or machine- can effectively carry out.","Problem formulation (abstraction)","Solution expression (automation)","Solution execution & evaluation (analyses)"]},{"l":"Characteristics of computational thinking","p":["Formulating problems in a way that enables us to use a computer and other tools to help solve them","Logically organizing and analyzing data → Data structure","Representing data though abstractions such as models and simulations → Data Structure","Automating solutions through algorithmic thinking (a series of ordered steps) → Algorithm","Identifying, analyzing, and implementing possible solutions with the goal of achieving the most efficient and effective combination of steps and resources → time and space complexity","Generalizing and transferring the problem solving process to a wide variety of problems"]},{"l":"Problem Solving in Computer Science and Engineering","p":["문 제 (Problem) \\rightarrow 해 (Solution)","Problem : 가상 현실, 문서작성, 홈뱅킹, 인터넷 신문, 문서 번역, 회로 설계, 유전자 분석, 무인 자동차, 온라인 게임, 비디오 편집, 자료 검색, 영화 제작, 음성 인식, 가상 수술, 건축 설계, 기상 예측, 주가 예측, 인공 지능, 대용량 과학 계산, …"]},{"l":"Problem Solving Pipeline"},{"l":"도강 문제","p":["한 어부(M)가 늑대(W), 염소(G), 양배추(C)를 강 한 쪽에서 다른 쪽으로 옮기려 한다. 어부가 배를 타고 강을 건널 때 어부 자신 외에 늑대, 염 소, 양배추 중 하나만 배에 가지고 갈 수가 있는데, 문제는 어부가 늑대 를 싣고 가는 동안, 염소가 양배추를 같은 쪽에 남겨두면 염소가 양배 추를 먹어버리게 되고, 양배추를 싣고 갈 때 늑대와 염소를 같은 쪽에 남겨둘 경우 늑대가 염소를 잡아 먹게 된다. 과연 어떻게 하면 어부가 가장 적은 회수로 강을 건너면서 세 가지를 모두 안전하게 옮길 수 있을까?"]},{"l":"문제 분석"},{"l":"해법 고안","p":["Graph, search, and so on → Which data structures and algorithms?","Cost, time, space, and so on → What complexities?","[연습] 이 문제에 대한 알고리즘과 시간/공간 복잡도를 컴퓨터학의 용 어를 써서 기술한다면, ???","무슨 말인지 전혀 모르겠으면 [43-080 자료구조]를 재수강한 후 이 과목을 들을 것!"]},{"i":"구현---programming-is-an-art","l":"구현 : ✓ Programming is an art!","p":["어떻게 하면 주어진 알고리즘을 가장 효과적으로 구현을 할 수 있을까?","어떻게 하면 C/C++ 를 사용하여 주어진 알고리즘을 가장 최적으로 구현할 수 있을까?","원시 코드 레벨의 측면","어셈블러 레벨의 측면","시스템 레벨의 측면","기타","✓ 과연 내가 http://acm.uva.es/problemset/에 있는 문제들을 스스로 “문제 분석 \\rightarrow 해법 고안 \\rightarrow 구현” 과정을 통하여 효과적으로 해결할 수 있을까???","Programming Challenges by S. Skiena and M. Revilla, Springer, 2003.","어떻게 하면 좋은 구현 결과를 얻을 수 있는가?","동일한 프로세서 상에서 더 빠르게","적은 메모리만 사용하게","안정적이게","구현 예","19 0.265968초 4.862961초 3.4GHz Intel Core i7 CPU"]},{"i":"data-structure--algorithm--theory-of-computation","l":"Data Structure → Algorithm → Theory of Computation","p":["어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?","[Data Structure] 주어진 추상적인 문제를 어떠한 자료 구조를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?","[Algorithm] 주어진 추상적인 문제를 어떠한 알고리즘을 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까?","[Complexity] 과연 컴퓨터가 주어진 문제를 효율적으로 해결할 수 있을까 ?","[Computability] 과연 컴퓨터가 세상의 모든 문제를 해결할 수 있을까?","✓ 이 과목에서는 [CSE3080 자료구조] 과목에 이어, 1번과 2번을 집중적으로 살펴보 고, 3번 문제에 대하여 어느 정도 살펴볼 예정임.","4번 문제는 [CSE3085 자동장치이론] 과목에서 다룸."]}],[{"i":"11---12-solve-with-alg","l":"1.1 - 1.2 Solve with Alg"},{"l":"1. How to think and solve problems with computer"},{"i":"data-structurealgorithmtheory-of-computation","l":"Data Structure→Algorithm→Theory of Computation","p":["어떻게 하면 주어진 복잡한 문제를 이진수 형태의 낮은 수준의 명령어만 이해하는 ‘단순한’ 컴퓨터 상에서 효율적으로 해결할 수 있을까?","[Data Structure] 주어진 추상적인 문제를 어떠한 자료 구조 를 사용하여 컴 퓨터의 구조에 최적화된 형태로 표현할 수 있을까?","[Algorithm] 주어진 추상적인 문제를 어떠한 알고리즘을 사용하여 컴퓨터를 사용하여 가장 효율적으로 해결할 수 있을까","[Complexity] 과연 컴퓨터가 주어진 문제를 효율적으로 해결할 수 있을까 ?","[Computability] 과연 컴퓨터가 세상의 모든 문제를 해결 할 수 있을까?","Data Structure & Algorithm \\rightarrow 1, 2, 3","Automata Theory \\rightarrow 4"]},{"l":"2. Def. of Algorithm"},{"l":"Definition of Algorithm","p":["An algorithm is a finite set of instructions that, if followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:","At least one quantity is produced.","Definiteness.","Each instruction is clear and unambiguous.","Effectiveness.","Every instruction must be basic enough to be carried out, in principle, by a person using only pencil and paper.","Finiteness.","from [Horowitz 1.2]","If we trace out the instructions of an algorithm, then for all cases, the algorithm terminates after a finite number of steps.","Input.","it also must be feasible. 또한 실현 가능하여야 한다.","It is not enough that each operation be definite as in (3);","Output.","Zero or more quantities from the outside.","각 지침은 모두 명확하며, 애매하게 쓰여 있지 않다.","손으로 풀 수 있을 만큼 효과적이어야 한다.","외부로부터 0개 이상의 수량이 입력으로서 들어온다.","제한된 수의 단계 후 종료된다.","하나 이상의 결과값이 수행된다."]},{"i":"thoughts-on-4-finiteness-computability","l":"Thoughts on 4) Finiteness: [Computability]","p":["Problem ( Post’s correspondence problem 포스트 대응 문제)","결정 불가능한 결정 문제의 예시, 1946년 emil post 에 의해 고안","Consider a finite set P of ordered pairs of nonempty strings such as P = \\{(a, ab), (b, ca), (ca, a), (abc, c)\\}","A match of P is any string w such that, for some m > 0 and some pairs (u_1, v_1), (u_2, v_2), ..., (u_m, v_m) \\in P, w = u_1 u_2...u_m = v_1 v_2...v_m.","Design an algorithm that determine, given P, whether P has a match.","Cheolsu’s algorithm","Can this be regarded as an algorithm?"]},{"i":"thoughts-on-efficiency-complexity","l":"Thoughts on Efficiency: [Complexity]","p":["An algorithm is regarded as efficient or good if there exist a polynomial P(n) such that the time required for solving any instance of size n is bounded above by P(n).","NP-Complete problems:","Nobody has found so far any good algorithm for any problem in this class.","It has been proved that if a good algorithm exists for some algorithm in this class, then a good algorithm exists for all NP-Complete Problem.","Examples","Suppose a CD-ROM can store up to 720MBytes of data. You have a sequence of n files of sizes s_1, s_2, ..., s_n Mbytes, to dump into backup CDs. What is the minimum number of necessary CDs to store all the files?","Consider n tasks to be executed on CPU. All the tasks must be finished within the time requirement L (seconds). If the i-th task takes s_i seconds, and you can harness multiple processors, what would be the minimum number of processors needed to accomplish this?","Ex. L = 10, n = 6, and $(s_1, s_2, s_3, s_4, s_5, s_6) = (5, 6, 3, 7, 5, 4) $","then (5, 5), (6, 4), (7, 3)","어떻게 하면 좀 더 “효율적으로” 문제를 해결할까?"]},{"l":"Efficient Algorithm Design"},{"l":"Example 1","p":["Sequential search vs binary search","Problem: Determine whether x is in the sorted array S of n keys.","Inputs: positive integer n, sorted (nondecreasing order) arrays of keys S indexed from 0 to n - 1, a key x.","Outputs: the location of x \\in S(-1 if x \\notin S).","Sequential search: T(n) = O(n)","Binary search: T(n) = O(log n)","[From Neapolitan] The number of comparisons done by Sequential & Binary Search when x is larger than all the array items","40억 개의 element가 array에 있을 때, Sequential Search는 40억 개 항목과 비교하는 반면에 Binary Search는 단 33개의 항목만을 비교한다.","컴퓨터가 1ns에 whlie loop를 통과할 수 있다고 가정한들 Binary search는 즉각적으로 결정을 내리는 반면 Sequential Search는 4s가 걸린다.","Why is the binary search more efficient? 왜 이진검색이 더 효율적인가?"]},{"i":"example-2the-fibonacci-sequence","l":"Example 2:The Fibonacci Sequence","p":["Problem: Determine the n-th term in the Fibonacci sequence.","Inputs: a nonnegative integer n","Outputs: the nth term of the Fibonacci sequence.","f_0 = 0 f_1 = 1 f_n = f_{n-1} + f_{n-2} for n \\geq 2","Recursive: $T(n) = O(2^ n) $","Iterative: T(n) = O(n)","Why is the iterative version more efficient?","T(n) > 2 ^{\\frac n 2} for n \\geq 2","Mathematical induction을 써서 증명해볼 것!","Linear versus exponential","[From Neapolitan] This table compares these expressions for various values of n. The execution times are based on the simplifying assumption that one term can be computed in 10^{−9} second.","The table shows the time it would take 'Iterative Algorithm' to compute the nth term on a hypothetical computer that could compute each term in a nanosecond, and it shows a lower bound on the time it would take to execute 'Iterative Algorithm'.","By the time n is 80, 'Recursive Algorithm' takes at least 18 minutes. When n is 120, it takes more than 36 years, an amount of time intolerable compared with a human life span. Even if we could build a computer one billion times as fast, 'Recursive Algorithm' would take over 40,000 years to compute the 200th term. This result can be obtained by dividing the time for the 200th term by one billion.","We see that regardless of how fast computers become, 'Recursive Algorithm' will still take an intolerable amount of time unless n is small. On the other hand, 'Iterative Algorithm' computes the nth Fibonacci term almost instantaneously.","This comparison shows why the efficiency of an algorithm remains an important consideration regardless of how fast computers become"]}],[{"i":"13-order-of-algorithms","l":"1.3. Order of Algorithms"},{"i":"-big--notation","l":"O (Big O Notation)","p":["for given two functions f(n) and g(n),","g(n) = O(f(n))\\iff \\exists c \\in \\mathbb{R}, N \\in \\mathbb{N}\\quad","s.t. \\quad g(n)\\leq c\\cdot f(n)\\forall n \\geq N","then we say that : g(n) is big O of f(n)","정답 : g(n) = c_0 + c_1 n + c_2 n^2","예 : g(n) = 5 + 6 + 7n^2 \\leq 8n^2 \\quad \\forall n \\geq 8","g(n) = O(n^2)"]},{"l":"Notes for big O","p":["(Tight) upper bound","[Note 1] The big O puts an asymptotic upper bound on a function.","[Note 2] Given a cost function g(n), how do you find the proper complexity function f(n) such that g(n) = O(f(n))?","$4(log n)^ 2 + nlog n + 100n = O(nlog n) $","10^3 + 10^3n + 10^-3 n^2 = O(n^2)","2^{5n} = O(2^n)??","2^{n+5} = O(2^n)??","3(log_2 n)^2+ 0.1n = O(?)","37log n + 0.1n = O(n)","5nlog_3 n + 3(log_2 n)^2 + n + 6n^2 = O(n^2)","Asymptotic analysis (from Wikipedia)","Example:","Growth Rates of Some Common Complexity Functions","If f(n) = n^2 + 3n, then as n becomes very large, the term 3n becomes insignificant compared to n^2. The function f(n) is said to be \"asymptotically equivalent to n^2, as n → ∞\". This is often written symbolically as f(n) ~ n^2, which is read as \" f(n) is asymptotic to n^2\".","n^2 + 10n = O(n^200)???","n2 + 10n = O(n^2)","Suppress lower-order terms and constant factors!","then lim_{n \\to \\infty} \\frac{n}{log_en} = lim _{n \\to \\infty} = \\infty","then lim_{n \\to \\infty} \\frac{n^2}{n} = \\infty","계산 비용이 0.01n^2 과 100n 알고리즘 중 어떤 것이 더 효율적인가?"]},{"l":"Comparing Orders of Growth","p":["How do you compare orders of growth of two functions?","One possible way is to compute the limit of the ratio of two functions in question.","x = lim_{n \\to \\infty } \\frac{f_1(n)}{f_2(n)}","if x=0, f_1 has a smaller order of growth than f_2","if x=c, f_1 has a same order of growth than f_2","if x=\\infty, f_1 has a larer order of growth than f_2","Ex.1: log_2 n vs \\sqrt{n}","$lim_{n \\to \\infty} \\frac{\\sqrt(n)} = lim_{n \\to \\infty} \\frac{(log_2 n)'}{(\\sqrt(n))'} = lim_{n \\to \\infty} \\frac{(log_2 e)\\frac{1}}{\\sqrt\\frac{1}{2\\sqrt(n)}} = $","Ex.2: n! vs 2^n","lim_{n \\to \\infty} \\frac{ n!}{2^n} = lim_{n \\to \\infty} \\frac{\\sqrt{2 \\pi n} (\\frac {n}{e})^n}{2^n}=lim_{n \\to \\infty }\\sqrt{2 \\pi n} \\frac{({n})^n}{2^n e^n}","stirling's formula : n! \\approx \\sqrt{2 \\pi n} (\\frac {n}{e})^n"]},{"i":"-big-omega-notation","l":"\\Omega (Big Omega Notation)","p":["for two given functions f(n), g(n)","g(n) = \\Omega(f(n))\\iff\\exists c \\in \\mathbb{R} and N \\in \\mathbb{Z^+ \\cup {0}}","s.t. g(n) \\geq cf(n)\\forall n \\geq N","We say that g(n) is \\omega of f(n).","The \\Omega puts an asymptotic lower bound on a function.","Ex:","37logn+0.1n=\\Omega(n)","n^2 + 10n = \\Omega(n^2)","4(logn)^2 +nlogn+100n=\\Omega(nlogn)","n^{200} +10n=\\Omega(n^2)..."]},{"i":"-big-theta-notation","l":"\\Theta (Big Theta Notation)","p":["\\Theta(1)<\\Theta(log n)<\\Theta(n)<\\Theta(n log n)<\\Theta(n^2)<\\Theta(n^3)<\\Theta(n^j)<\\Theta(n^k)<\\Theta(a^n)<\\Theta(b^n)<\\Theta(n!)","$g(n) = \\Theta (f(n)) $ \\iff\\exists c,d \\in \\mathbb{R} and N \\in \\mathbb{Z^+ \\cup {0}} s.t. g(n) \\geq cf(n)$ \\forall n \\geq N$","$g(n) = 0.000001 \\cdot n $","37logn+0.1n=\\Theta(n)","4(logn)^2 +nlogn+100n=\\Theta(nlogn)","Ex:","for $ k>j>3$ and b>a>1","for two given functions f(n), g(n)","g(n) = \\Theta(f(n))$\\iff $ $g(n) = O(f(n)) $ and g(n) = \\Omega (f(n))","g(n) = 1000000","n^2 + 10n = \\Theta(n^2)","O(1) or O(c): constant","Ref. Neapolitan Ex. (pp.42) 19, 24, 26, 28]","that is,","The \\Theta puts an asymptotic bound on a function.","We say that g(n) is order of f(n)."]},{"i":"big-o-omega-and-order","l":"Big O, Omega, and Order","p":["Ref.[Neapolitan Chapter 1.]","Execution Times for Algorithms with the Given Time Complexities"]},{"l":"Worst-Case versus Average-Case Time Complexity","p":["= \\sum_{k=0}^{n-1} (k+1)P_k + n (1 - \\sum_{k=0}^{n-1} P_k)","$T_A (n) = \\sum_{I \\in S_n} p(I) c(I) $","Average-case complexity","Average-Case O(n log n)","Cost for a linear search algorithm","Ex.1. n = 10^9, P_0 + P_1 + ...+ P_{10^3} = 1 so g(n) = O(1)","Ex.2. n = 10^9, P_0 + P_1 + ...+ P_{\\frac n {100} }= 1 so g(n) = O(n)","Expected value (from Wikipedia)","Find the index of a given value a in a givven array (a_0, a_1, ...,a _{n-1}). if a doesn't exist in the array return -1","g(n) = 1 \\cdot P_0 + 2 \\cdot P_1 + 3 \\cdot P_2 + ...+ n \\cdot P_{n-1} + n (1 - \\sum_{k=0}^{n-1} P_k)","let P_i be the probability such that a= a_i","let X be a random variable with a finite number of finite outcomes x_1, x_2, ..., x_k occuring with probabilities p_1, p_2, ... p_k respectively.","Problem","since the sum of all probabilities p_i is 1 (\\sum_{i=1}^{k} {p_i}=1) , the expected value is the weighted sum of the x_i values, with the p_i values being the weights","T_W (n) = max \\{ c(I)| I \\in S_n \\}","the Expectation of X is defined as : E(X) = \\sum_{i=1}^{k }{x_i p_i} = x_1p_1+ x_2 p_2 + ... + x_k p_k","then the average cost is :","Worst-case complexity","Worst-case O(n^2),","참고: Quick sort 알고리즘 →"]},{"l":"Reviews"},{"l":"Summation","p":["\\sum_{i=1}^{n} \\frac 1 i \\in \\Theta(log n)","\\sum_{i=1}^{n} c^i \\in \\Theta( n \\cdot log(n)^{c+1}) for real c greater than 1","\\sum_{i=1}^{n} i = \\frac {n(n+1)} {2}","\\sum_{i=1}^{n} i^{-s} = \\prod_{p prime} \\frac {1} {1 - p^{-s}} = \\zeta(s)","\\sum_{i=1}^{n} i^2 = \\frac {n(n+1)(2n+1)} {6}","\\sum_{i=1}^{n} i^3 = (\\frac {n(n+1)} {2})^2","\\sum_{i=1}^{n} i^4 = \\frac {n(n+1)(2n+1)(3n^2+3n-1)} {30}","\\sum_{i=1}^{n} i^c \\in \\Theta(n^{c+1}) for real c greater than -1","\\sum_{i=1}^{n} i^s = \\frac {(n+1)^{s+1}} {s+1} + \\sum_{k=1}^{s} \\frac {B_k} {s-k+1} {s \\choose k} (n+1)^{s-k+1}","\\sum_{i=1}^{n} log(i)^c \\cdot i^d \\cdot b^i \\in \\Theta(n^{d} \\cdot log(n)^{c} \\cdot b^n) for nonnegative real b>1, c, d","\\sum_{i=1}^{n} log(i)^c \\cdot i^d \\in \\Theta(n^{d+1} \\cdot log(n)^{c}) for nonnegative real c, d","\\sum_{i=1}^{n} log(i)^c \\in \\Theta(n \\cdot log(n)^{c}) for nonnegative real c","\\zeta_k is the Riemann zeta function","B_k is the k^{th} Bernoulli Number.","Growth rates","Read Summation, Mathematical Series","Sums of powers"]},{"l":"Run Time Analysis","p":["(1)","(1) Matrix Addition","(2)","(3)","(3) Could this be faster?","(4)","(4) Magic square : Could this be faster?","(5)","(5) O(\\log n)","(6) \\rightarrow O(N^4)","1","10","11","12","13","14","15","16","17","18","19","2","20","21","22","23","24","25","3","4","5","6","7","8","9","time complexity. : ??= O( \\sqrt n)","time complexity. : c_0 + c_1 n + c_2 n^2 = O(n^2)","time complexity. : c( ⌊{log_2 n}⌋+1) \\cdot n^2 = O(n^2)","What is the worst-case time complexity of each loop?"]}],[{"i":"14-mss","l":"1.4. MSS","p":["최대 부분 수열의 합 Maximum Subsequence Sum"]},{"i":"maximum-subsequence-sum-mss-problem","l":"Maximum Subsequence Sum (MSS) Problem","p":["Ref.[M. Weiss, Data Structure and Algorithm Analysis in C (2nd ed.), Pearson, 1997. 2.4.3]","Given N(possiblly negative) A_0, A_1, ..., A_{N-1} \\in \\mathbb{Z}","find the maximum value of \\sum_{k=i}^{j} {A_k } for 0 \\leq i \\leq j \\leq N-1","for convenience, the max subseuqence sum is 0 if all the integers 're <0","Example","(-2, 11, -4, 13, -5, -2). → MSS = 20","Maximum Subarray Problem","Maximum Positive Sum Subarray Problem","Max. Sum Subsequence versus Max. Subsequence Sum"]},{"l":"Alg of Maximum Subsequence Sum","p":["길이 $n$인 정수의 수열 a_0, a_1, ..., a_{n-1} 이 입력으로 주어져 있다.","여기서 부분 수열 [i, j]라는 것은 a_i, a_{i+1}, a_{i+2}..., , a_{j} 를 말한다.","본 문제는 주어진 수열의 부분 수열의 합,즉 \\sum_{i \\leq k \\leq j} {a_k} 의 최대값을 구하는 문제이다. (이때 주어진 수열의 정수가 모두 음수이면 최대 부분 수열의 합은 0 이라고 간주한다)","예를 들어 다음과 같은 수열이 주어졌을 때,+ 31, −41, +59, +26, −53, +58, +97, −93, −23, +84 최대 부분 수열은 $[2,6]$이며 수열의 합은 187 이 된다.","이 문제는 최대 부분 수열의 합을 구하는 것이지만, 앞으로 소개할 알고리즘을 조금만 수정하면 최대 부분 수열도 쉽게 구할 수 있다.","Algorithm1 : 모든 경우의 수 찾기 - O(N^3) Algorithm2 : Sum구할 때 중복 조금 피하기 - O(N^2) Algorithm3 : Divide n Conquer - O(N log N) Algorithm4 : Dynamic Programming - O(N)","image"]},{"l":"MSS Algorithm 1","p":["Strategy","Enumerate all possibilities one at a time.","No efficiency is considered, resulting in a lot of unnecessary computation!","모든 경우의 수를 하나하나 모두 따져보는 방법.","Is this for-loop OK for you?","Time Complexity : O(N^3)","\uD835\uDC56와 관련된 반복문은 \uD835\uDC5Bn번, \uD835\uDC57와 관련된 반복문은 최대 \uD835\uDC5B번, Thissum을 구할 때 최대 \uD835\uDC5B개의 요소를 계산해야 하기에","\\sum_{i=0}^{N-1} \\sum_{j=i}^{N-1} \\sum_{k=i}^{j} 1 = \\frac{N^3 + 3N^2 + 2N}{6}","\\sum_{j=i}^{N-1}\\ (j-i+1) = \\frac{(N-i+1)(N-i)}{2}","\\sum_{k=i}^{j} 1 = j-i+1"]},{"l":"MSS Algorithm 2","p":["Strategy","Get rid of the inefficiency in the innermost for-loop. Algorithm 1보다 중복을 줄이는 방법","Notice that \\sum_{k=i}^{j } {A_k} = A_j + \\sum_{k=i}^{j-1} {A_k}","}","time complexity : O(N^2)"]},{"l":"MSS Algorithm 3","p":["Strategy","Use the Divide-and-Conquer strategy.","원 문제를 작은 문제로 나눠 풀고, 그 결과를 합쳐 문제를 해결하는 알고리즘","The maximum subsequence sum can be in one of three places.","cost : T(n) = 2T(n/2) + cn, T(1) = d","why O(N log N)?","T(n) = 2T(\\frac n 2) + cn, T(1) = d$ = 2 [2T(\\frac n {2^ 2}) + c \\frac n 2 ] + cn$= 2^2 T [ \\frac n {2^2}] + 2cn= 2^3 T [ \\frac n {2^3}] + 3cn =...= 2^i T [ \\frac n {2^i}] + icn= 2^{log_2 n} T(1) + log_2 n \\cdot cn=nT(1) + log_2 n \\cdot cn= O(n) + O(n log_2 n) = O(n log_2 n)"]},{"i":"mss-algorithm-4-kadanes-algorithm","l":"MSS Algorithm 4; Kadane’s algorithm","p":["Strategy","Use the Dynamic Programming strategy.","subsequence sum<0인 경우, 논리적으로 최대값이 될 수 없음에 착안한 전략","만약에 sum이 음수라도 무방하고 1개 이상의 원소로 구 성된 Subsequence (subarray)를 구하는 문제라면?","Time Complexity : O(n)","for i, iteration n times, and O(1) for 1 calculation","C Implementation","Maximum sum rectangle in a 2D matrix (DP-27) by GeeksforGeeks"]},{"i":"so-why-do-we-bother-with-the-time-complexity","l":"So, why do we bother with the time complexity?"}],[{"i":"15-maximum-sum-subrectangle-in-2d-array","l":"1.5. Maximum Sum Subrectangle in 2D Array","p":["-1","-2","-4","-6","-7","[1D case] for an m * n rectangle,","\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} \\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} 1","= (\\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} 1)(\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} 1)","= { \\sum_{k=0}^{m-1}(m-k)}{\\sum_{i=0}^{n-1}{(n-i)}}","= \\frac {m(m+1)} {2} \\frac {n(n+1)} {2} = O(m^2 n^2) = O(n^4) if m=n","= max sum submatrix","0","1","2","8","9","Design an O(n^3) algorithm.","Design an O(n^4) algorithm.","Design an O(n^5) algorithm.","Design an O(n^6) algorithm.","For the case of m = n,","Given an mxn array of integers, find a subrectangle with the largest sum. (In this problem, we assume that a subrectangle is any contiguous sub-array of size 1x1 or greater located within the whole array.)","How many subrectangles are there in an mxn array?","If m = n→n","Note","Problem","What is the input size of this problem?→ (m, n)"]},{"i":"a-naive-approach","l":"A Naïve Approach","p":["For each subrectangle, find its sum.","[가정] n=m","\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} \\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} (j-i+1)(l-k+1) = \\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} {(j-i+1)} \\sum_{k=0}^{m-1} \\sum_{l=k}^{m-1} {(l-k+1)}","let A =\\sum_{i=0}^{n-1} \\sum_{j=i}^{n-1} {(j-i+1)}","A = 1*n + 2*(n-1) +3(n-2) + ... + n*1= \\sum_{i=1}^{n} {i(n-i+1)} = n \\sum_{i=1}^n i - \\sum_{i=1}^n i^2 + \\sum_{i=1}^n i \\frac{1}{6} n^3","so O(\\frac{1}{36} n^6 )","Time Complexity : O(n^6)"]},{"l":"Summed Area Table","p":["Table construction: O(n^2)","Sum comparisons: O(n^4)","Time Complexity : O(n^4)"]},{"i":"maximum-sum-subrectangle-kadane-algo-based","l":"Maximum Sum Subrectangle: Kadane Algo.-Based","p":["Idea","ref. geeksforgeeks","MSS(2D)의 해당 열은 어디이건 i에서 j까지 임.","가능한 모든 (i, j) 조합에 대하여 MSS(1D)를 Kadane 알고리즘을 사용하여 찾음.","그렇게 하기 위하여, ...","C Implementation","결과는 아래와 같다."]},{"i":"mathematical-induction--proof-of-correctness","l":"Mathematical Induction & Proof of Correctness","p":["Proof by Induction","Proof of Correctness : MSS (1D)","P(j): for-loop가 j번 수행한 직후에 ThisSum 변수는 ( )값을, MaxSum 변수는 ( )값을 가지고 있다."]}],[{"l":"2. Heap"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Dynamic set의 표현 및 응용 능력","Priority queue 구조","Disjoint set 구조"]}],[{"i":"21-heap-based-priority-queues-and-heap-sort","l":"2.1. Heap-based Priority Queues and Heap Sort"},{"l":"A Variety of Priority Queue Implementations","p":["[Priority Queue 1: Max(Min) Heap]","[Priority Queue 2: Min-Max Heap]","[Priority Queue 3: Heap and Hashing]","[Priority Queue 4: Deap]","[Priority Queue 5: Leftist Tree]","[Priority Queue 6: Binomial Heap]","[Priority Queue 7: Fibonacci Heap]","image"]},{"i":"job-scheduling-example-priority-queue","l":"[Job Scheduling Example: Priority Queue]","p":["Consider the following sequence of requests in an operating system:","image"]},{"l":"Requirement 1","p":["CPU executes the process with the highest priority first.","Use a heap structure – a simple max heap :)","image"]},{"l":"Requirement 2","p":["The priority of processes can be modified after they are placed in the priority queue.","This function requires locating a particular process in the heap, but the basic heap operations provide no efficient way to do it.","Employ an auxiliary data structure such as a hash table that keeps track of the location of each process in the heap structure.","Once the two requirements are satisfied, the operating system can process the following basic commands efficiently:"]}],[{"i":"22-pq1-maxmin-heap-1","l":"2.2. PQ1: Max(Min) Heap (1)","p":["ref.[Horowitz 5.6.2] [Neapolitan 7.6]","Problem","The following operations must be performed as mixed in data processing:","Store a record with a key in an arbitrary order.","Fetch the record with the current largest key.","A solution","Design a data structure that offers an efficient implementation of the following operations:","Insert an element with an arbitrary key.","Delete an element with the largest key."]},{"l":"An Array Implementation","p":["Ref. [Sedgewick 9.2]","What will be the worst-case time complexity of each operation?"]},{"i":"maxmin-heap-definitions","l":"Max(Min) Heap: Definitions"},{"l":"Definition 1","p":["[Horowitz 5.6.2] [Neapolitan 7.6]","A max(min) heap is a complete binary tree where the key value in each internal node is no smaller(larger) than the key values in its children."]},{"l":"Definition 2","p":["A binary tree has the max(min) heap property if and only if","The number of nodes of the tree is either 0 or 1, or","2 For the tree that has at least two nodes, the key in the root is no smaller(larger) than that in each child and the subtree rooted at the child has the max(min) heap property.","A max(min) heap is a complete binary tree that has the max(min) heap property.","image"]},{"l":"Brainstorming on Max Heap Operations","p":["Max Heap Example","Deletion Example 1","image","Deletion Example 2","Insertion Example","Deletion from a Max Heap","ref.[Horowitz 5.6.2]","C = log_2 n","O(log n)"]},{"i":"another-heap-implementation-min-heap","l":"Another Heap Implementation (Min Heap)","p":["ref.[Sedgewick 9.3]","What will be the worst-case time complexity of each operation?"]}],[{"i":"23-pq1-maxmin-heap-2","l":"2.3. PQ1: Max(Min) Heap (2)"},{"l":"Comparisons of Priority Queue Implementations","p":["Representation","Insertion","Deletion","Unordered array","O(1)","O(n)","Unordered linked list","Sorted array","Sorted linked list","Max heap","O(\\log n)"]},{"l":"Heap Sort in C Implementation","p":["1","10","11","115","15","19","2","26","3","4","48","5","59","6","61","7","77","8","9","Convert an input array of n unordered items into a max heap.","Extract the items from the heap one at a time to build an ordered array.","image image","Make a (max) heap.","max heap","Method","Name","O(n)","O(n\\log n) \\rightarrow O(n\\log n)","ordered","ref.[Horowitz 7.7] [Neapolitan 7.6]","unordered","주어진 정수들을 비감소 순서(non-decreasing order)대로 정렬하라."]},{"i":"the-adjust-function","l":"The adjust() function","p":["Input: a binary tree T whose left and right subtrees satisfy the heap property but whose root may not","Output: a binary tree T adjusted so that the entire binary tree satisfies the heap property","Executed d times, where d is the depth of the tree with root i","So O(d) time"]},{"l":"Cost of Make-Heap","p":["image","C_{MH} \\leq (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \\cdot 2^{k-2}","I= (k-1)2^0 + (k-2)2^1 + (k-3)2^2 + ...+1 \\cdot 2^{k-2}","2I= (k-1)2^1 + (k-2)2^2 + (k-3)2^3 + ...+1 \\cdot 2^{k-1}","2I-1I= -(k-1) + 2^1+ 2^2 + ... + 2^{k-2}","I = -k+ \\frac {1 \\cdot (2^k-1)}{2-1} = 2^k -k -1","\\therefore C_{MH} \\leq 2^k -k -1","Time Complexity Analysis","2^k \\leq 2n, -k < -log_2 n","then 2^k -k -1 < 2n - log_2n -1","so C_{MH} = O(n)"]},{"i":"extract-items-one-by-one","l":"Extract items one by one.","p":["image"]},{"l":"Complexity of Item Extractions","p":["image","2^c \\leq n < 2^{c+1} \\rightarrow c \\leq \\log_2 n < c+1","for a given n, the cost (depth) is c = ⌊\\log_2n⌋","C_{IE}=⌊\\log (n-1)⌋+⌊\\log (n-2)⌋+⌊\\log (n-3)⌋...+⌊\\log2⌋+⌊\\log 1⌋\\leq \\log2 + \\log3 + ...+\\log {(n-1)} < \\sum_{i=2}^n \\log_2 n= O(n \\log n)","Heap Sort : C_{MH} +C_{IE} = O(n)+ O(n \\log n) = O(n \\log n)"]}],[{"i":"24-pq-2-min-max-heap","l":"2.4. PQ 2: Min-Max Heap","p":["Problem","The following operations must be performed as mixed in data processing:","Store a record with a key in an arbitrary order.","Fetch the record with the current largest key.","Fetch the record with the current smallest key.","A solution","Design a data structure that offers the efficient implementation of the following operations (Double-Ended Priority Queue):","Insert an element with an arbitrary key.","Delete an element with the largest key.","Delete an element with the smallest key.","ref.[Horowitz 9.1]","{교육과정 외}"]},{"i":"priority-queue-3-heap-and-hashing","l":"Priority Queue 3: Heap and Hashing"},{"i":"priority-queue-4-deap","l":"Priority Queue 4: Deap"},{"i":"priority-queue-5-leftist-tree","l":"Priority Queue 5: Leftist Tree"},{"i":"priority-queue-6-binomial-heap","l":"Priority Queue 6: Binomial Heap"},{"i":"priority-queue-7-fibonacci-heap","l":"Priority Queue 7: Fibonacci Heap"}],[{"i":"3-divideconquer-sorting-and-selection","l":"3. Divide&Conquer, Sorting, and Selection"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Divide-and-conquer 기법에 대한 이해 및 응용 능력","Sorting 방법에 대한 이해 및 구현 기법 습득"]}],[{"l":"1. Sorting","p":["A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.","Are the keys of items very long or hard to compare? 항목 키가 매우 길거나 비교하기 어렵습니까?","Do you have to worry about disk accesses? 디스크 액세스에 대해 염려해야 합니까?","Do you know the distribution of the items? 품목의 분포를 알고 있습니까?","Do you need a stable sorting algorithm? 안정적인 정렬 알고리즘이 필요한가?","Ex: non-increasing, non-decreasing, or etc.","Given a list of n items, arrange them in a certain order.","How many items will you be sorting? 얼마나 많은 원소를 정렬할 것인가?","How much time do you have to write and debug your routine? 루틴을 작성하고 디버깅하는 데 얼마나 많은 시간이 필요합니까?","Is the data already partially sorted? 데이터는 이미 부분적으로 정렬되어 있는가?","Is the range of possible keys very small? 가능한 키의 범위가 매우 작습니까?","Problem:","ref. Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005,","Some criteria for choosing a sorting algorithm","Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐","What do you know about the data? 데이터에 대해 알고 계십니까?","Will there be duplicate items in the data? 데이터에 중복 항목이 있습니까?","원래 링크 깨짐","일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)"]},{"l":"A Formal Definition of Sorting","p":["A partial order on a set S is a relation R such that for each a, b, and c in S:","a R a is true ( R is reflexive).","aRb and bRc imply aRc( R is transitive)","aRb and bRa imply a = b( R is antisymmetric)","A Linear Order or Total Older on a set S is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.","The sorting problem","Given a sequence of n elements a_1, a_2, ..., a_n drawn from a set having a linear order $\\preceq $","find a permutation \\Pi = (\\pi_1, \\pi_2, ..., \\pi_n) of (1,2,...,n) that will map the sequence into a nondecreasing sequence a_{\\pi_1}, a_{\\pi_2},...,a_{\\pi_n} such that a_{\\pi_1} \\preceq a_{\\pi_i+1} for $1 \\leq i < n $","Ex: \\leq on \\mathbb{Z}, $ $\\subseteq $ on sets","Sorting on data with partial order?","ref. 이산수학 내용"]}],[{"i":"311-merge-sort","l":"3.1.1. Merge Sort"},{"l":"1. Merge Sort","p":["-","1","10","10 12","10 12 13","10 12 13 15","10 12 13 15 20","10 12 13 15 20 22","10 12 13 15 20 22 25","10 12 13 15 20 22 25 27","10 12 20 27","13 15 22 25","2","3","4","5","6","7","A simple implementation","An example of merging two arrays","Combine the solutions to the subarrays by merging them into a single sorted array.","Conquer each subarray by sorting it recursively.","Divide the array into two subarrays each with ~$ \\frac n 2$ items.","image","Inputs: positive integer n, array of keys S indexed from 1 to n.","k","left","merged","Outputs: the array S containing the keys in nondecreasing order. 배열 S는 감소하지 않는 순서로 정렬된 key를 갖는다","Problem: Sort n keys in nondecreasing sequence.","right"]},{"l":"Worst-case time complexity","p":["편의상 $n=2m$이라 할 경우 ( m \\in Z^+ \\cup \\{0\\}","T(n) = 2T(\\frac {n} {2}) + cn, n \\geq 2","2 : Number of subproblems","\\frac n 2: Subproblem size","T(1) =1\\rightarrow T(n) = O(nlogn)","Merge Sort Complexity Analysis| Merge Sort | | || ---------- | --------------- | ------- || Divide | Conquer | Combine || O(1)| 2T(\\frac n 2)| O(n)|","n개의 원소를 $k$개와 $l$개로 나누어 진행한다고 가정하면 ( n=k+l),","T(n) = T(k) + T(l) + cn (k \\approx l)","n = 2^m 이 아닌 일반적인 경우에도 같은 시간 복잡도를 가짐을 증명할 수 있음."]},{"l":"Solving Recurrence Equations","p":["Solve the following recurrences T(n) for given T(1)=1","T(n) = aT(n-1) + bn","T(n) = T(\\frac n 2) + bn \\log n","T(n) = aT(n-1) + bn^2","T(n) = aT(n/2) + bn^2","T(n) = T(\\frac n 2) + c \\log n","T(n) = T(\\frac n 2) + cn","T(n) = 2T(\\frac n 2) + cn","T(n) = 2T(\\frac n 2) + cn \\log n","T(n) = T(n-1) + T(n-2), for T(1) = T(2) = 1"]},{"l":"Some Derivations","p":["T(n) = 2 T(n/2) + cn, T(1) = 1","assume n=2^m, i.e., m = log_2 m for some m \\geq 0, m \\in \\mathbb{Z}","T(2^m) = 2T(2^{m-1})+c \\cdot 2^m\\\\= 2 \\{2T(2^{m-2})+c \\cdot 2^{m-1} \\}+c \\cdot 2^m\\\\=2^2 \\cdot T(2^{m-2})+2 \\cdot c \\cdot 2^m\\\\= 2^2 \\{2 \\cdot T(2^{m-3})+c \\cdot 2^{m-2} \\}+2 \\cdot c \\cdot 2^m$\\ ... \\= 2 m \\cdot T(2 0) + m \\cdot c \\cdot 2^ m $\\\\= n \\cdot 1 + (log_2 n) \\cdot c \\cdot n = O(n \\log n )","T(n) = T(n-1) + cn, T(1) = 1","T(n) = 2 T(n/2) + cn^2, T(1) = 1","Assume n=2^m for some m \\in \\mathbb{Z} - \\mathbb {Z^-}","2 \\cdot T (2^{m-1}) + c \\cdot 2 ^2m$\\ = 2 { 2 \\cdot T(2^) + c \\cdot 2 {2(m-1)} } + c \\cdot 2 2m $ $\\= 22 \\cdot T(2) + c { 2^{2m-1} + 2 {2m}} $ $\\ = 2 { 2 \\cdot T(2) + c \\cdot 2 {2(m-2)} } + c { 2{2m-1} + 2^{2m} } $$\\= 2 3 \\cdot T(2)+ c { 2^{2m-2} + 2^{2m-1} + 2 ^{2m}} $\\\\ … \\\\= 2^m + 2 \\cdot c \\cdot 2^{2m} - 2 \\cdot c \\cdot 2^m\\\\ =2 \\cdot c \\cdot n^2 - (2 \\cdot c -1) n = O(n^2)"]},{"l":"Another Implementation of Merge Sort","p":["ref. [Horowitz 7.6.3]","rmerge returns an integer that points to the start of the sorted list. start = rmerge(list, 0, n-1);","listmerge takes two sorted chains, first and second, and returns an integer that points to the start of a new sorted chain that includes the first and second chains.","listmerge 함수 수행 예 start","image"]}],[{"i":"312-quick-sort","l":"3.1.2. Quick Sort"},{"i":"312-quick-sort-1","l":"3.1.2. Quick Sort","p":["Pivot strategy","Divide","Select a pivot element, and then divide the array into two subarrays such that ....","Conquer","sort each subarray recursively.","Combine","do nothing.","image","A simple implementation"]},{"l":"Cost Analysis","p":["Cost","T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1) if n>1","T(1) = 1","Analysis|Quick Sort ||||---|---|---||Divide| Conquer| Combine|| O(n)| T(m_1)+T(m_2)| O(1)|","Worst-case time complexity","매 단계에서 선택한 pivot element가 가장 크거나 가장 작을 경우,","T(n) = T(0) + T(n-1) + cn, T(1) = 1 then T(n) = O(n^2)","Skewed vs well-balanced trees","Average-case time complexity","T(n) = \\sum_{p=1}^n {T(p-1) + T(n-p)} + cn","T(0) = 1 \\rightarrow","\\therefore T(n) = O(n log n)"]},{"l":"직관적인 시간 복잡도 추정","p":["T(n) = T(m_1) + T(m_2) + cn (m_1 + m_2 = n-1) if n>1","T(1) = 1","image"]},{"l":"Average Case Time Complexity"},{"l":"첫 번째 사실","p":["n \\leq 0, \\forall n \\in \\mathbb{Z}, T_{ave}(n) 을 n 개의 원소를 가지는 배열을 퀵 정렬 방법을 사용하여 정렬하는데 걸리는 평균 수행시간이라고 하자. 그러먼 어떤 양의 정수 b와 c에 대해 다음과 같은 재귀 관계 존재","T_{ave} (n) \\geq cn + \\frac {1}{n} \\sum_{p=1}^{n} \\{ T_{ave} (p-1) + T_{ave} (n-p) \\}\\\\= cn + \\frac{2}{n} {\\sum_{p=0}^{n-1} {T_{ave}(p)}}\\forall n \\geq 2","T_{ave} (1) \\leq b","T_{ave} (0) \\leq b","Cost_{ave} = \\sum_{p=1}^n {P_r (p) \\cdot Cost(p)} = \\frac {1}{n} \\sum_{p=1}^n {... + ...}"]},{"l":"두 번째 사실","p":["k=2(b+c) 라 할 때, 2보다 같거나 큰 모든 정수 n 에 대하여 T_{ave} (n) \\leq kn \\log_e n 과 같은 관계 존재","증명: 위의 부등식을 수학적 귀납법을 사용하여 증명하자.","n=2","첫 번째 사실로부터 다음과 같은 관계 성립\\\\ T_{ave}(2) \\leq 2c + T_{ave} (0) + T_{ave} (1) \\leq 2(b+c) \\leq k \\cdot 2 \\ log_e 2","\\therefore 따라서 두 번째 사실 성립","3보다 같거나 큰 임의의 n 이 given","Assume that : m<n 인 모든 m 에 대하여 두 번째 사실 성립한다고 가정하자.","그러면 첫 번째 사실과 이 과정을 사용하여 다음과 같은 관계 유도 가능","T_{ave} (n) \\leq cn + \\frac {2} {n} \\sum_{m=0}^{n-1} {T_{ave} (m)}\\\\ = cn + \\frac 2 m \\{ T_{ave} (0)+T_{ave} (1) \\} + \\frac {2} {n} \\sum_{m=2}^{n-1} {T_{ave} (m)}\\\\ \\leq cn + \\frac {4b} n + \\frac {2k} n \\sum_{m=2}^{n-1} {m log_e m}","그러므로 T_{ave} (n) \\leq cn + \\frac {2} {n} \\sum_{p=0}^{n-1} {T_{ve} (p)}\\forall n \\geq 2","함수 $x \\log_e x$가 $x$에 대하여 아래로 볼록한 함수이어서 m log_e m \\leq \\int_m^{m+1} x \\log_e x dx 라는 사실을 이용하면 다음과 같은 관계식을 얻는다.","T_{ave} (n)= cn + \\frac {4b}n + \\frac {2k}n \\int_2^n x log_e x dx\\\\ \\leq cn + \\frac {4b}{n} + \\frac{2k}{n} \\{ \\frac{n^2 log_e n}{2} - \\frac {n^2} 4 \\}\\\\= knlog_e n + \\{ cn + \\frac{4b} n - \\frac {kn} 2\\}","$\\int_2 n x log_e x dx =[\\frac 1 2 x 2 log_e x - \\frac {x 2} 4]_2 n $","= (\\frac {n^2} 2) log_e n - \\frac {n^2} 4 - (2log_e 2 - 1) \\leq \\frac {n^2} {2} {log_e n} - \\frac {n^2} {4}","이 때, $ cn + \\frac{4b} n - \\frac 2 = (c-\\frac k 2 )n + \\frac {4b} n = b(\\frac 4 n -n)$ 과 같고 이 값은 2보다 같거나 큰 n에 대해 항상 0보다 같거나 작으므로 T_{ave} (n) \\leq kn log_e n 이 되어 3보다 같거나 큰 임의의 n에 대해서도 두 번째 사실이 성립한다. 따라서 2보다 같거나 큰 모든 정수 n에 대해 다음과 같은 두 번째 사실이 성립한다."]},{"l":"Anther Implementation"},{"l":"Improving the Performance of Quick Sort","p":["How can you select a “good” pivot element?","Choose a random element in the list.","Choose the median of the first, middle, and final elements in the list.","Choose the median of the entire elements in the list. (bad idea)","Etc.","Program 7.4. improved quicksort","Choosing the median of the first, middle, and final elements as the partitioning element and cutting off the recursion for small subfiles can significantly improve the performance of quicksort.","This implementation partitions on the median of the first, middle, and final elements in the array (otherwise leaving these elements out of the partitioning process).","Files of size 11 or smaller are ignored during partitioning; then, insertion from is used to finish the sort.","How can you minimize the bookkeeping cost involved in the recursive calls?","Much of the pushing and popping of the frame stack is unnecessary.","Lists of size smaller than M are ignored during quick sort, then do a single sorting pass at the end.","Avoid making the recursive call on the larger subrange. \uF050 The depth of recursion <= O(log n)"]},{"i":"example-quick-sort","l":"Example: Quick Sort","p":["By courtesy of David R. Musser","Average-case: O(n log n)","Worst-case: O(n^2)","image"]},{"i":"quicksort-implementation-2-k-loudon","l":"Quicksort: Implementation 2 [K. Loudon]"}],[{"i":"313-insertion-sort","l":"3.1.3. Insertion Sort","p":["Insertion Sort: Example 1","image","Insertion Sort: Example 2","Insertion : O(n+d) in the worst case over sequences that have d inversions","When does the insertion sort run fast?","이러한 insertion sort의 성질을 quick sort의 성능 향상에 활용하자."]},{"l":"Implementation","p":["Sort a list of elements by iteratively inserting a next element in a progressively growing sorted array.","}"]},{"l":"Run-Time Analysis","p":["Worst case","No. of comparisons:","1+2+ ...+n-1 = O(\\frac {n^2}{2})","No. of record assignments:","Average case","No. of comparisons","\\sum_{i=1}^{n-1} {\\frac{1+2+...+i+i}{i+1} } =\\sum_{i=1}^{n-1} {(\\frac{i}{2}+1-\\frac{1}{i+1})}\\\\\\approx \\frac{(n-1)(n+4)}{4} - \\ln n = O(\\frac{n^2} 4)","No. of record assignments","\\sum_{i=1}^{n-1} {\\frac{0+1+2+...+i}{i+1} +2} = \\frac{n(n-1)}{4}+2(n-1) = O(\\frac{n^2}4)","image"]},{"l":"Example","p":["image"]}],[{"i":"314-selection-sort","l":"3.1.4. Selection Sort"},{"l":"Implementation","p":["T(n) = O(n^2)"]},{"l":"Example","p":["image"]},{"l":"Run-Time Analysis","p":["Worst case","No. of comparisons","\\sum_{i=0}^{n-2} (n-i-1) = \\frac {n(n-1)} 2 = O (\\frac {n^2} {2})","No. of record assignments","3(n-1) = O(3n)","Average case","[생각해보기] If we code like “if (i != cur) SWAP(A[i], A[cur]);”, what is the average cost?"]}],[{"i":"315-bubble-sort","l":"3.1.5. Bubble Sort"},{"l":"Example","p":["image"]},{"l":"Implementation"},{"l":"Run-Time Analysis","p":["Refer to The Art of Computer Programming (Vol. 3)","Worst Case","No. of comparisons","\\sum_{i=1}^{n-1} (n-1-i) = \\frac {n(n-1)} 2 = O (\\frac {n^2} {2})","No. of record assignments","$\\sum_ 3i = \\frac 3 2 n(n-1)= O (\\frac {3} {2} n 2) $","Average case","$\\frac 1 2 \\sum_ 3i = \\frac 3 2 n(n-1)= O (\\frac {3} {4} n 2) $"]}],[{"i":"316-cost-comparison","l":"3.1.6. Cost Comparison","p":["Selection","Insertion","Bubble","# of comparisons","\\frac{n^2}2","\\frac {n^2} 4(average)","\\frac{n^2}{2}(average)","\\frac{n^2} 2(worst)","\\frac{n^2}2(worst)","# of record assignments","3n","$\\frac{n^ 2}4 $(average)","\\frac{3n^2} 4(average)","\\frac{3n^2}2(worst)"]},{"l":"Comparison Sorts","p":["image","https://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms","-"]},{"l":"Performance Comparisons","p":["By courtesy of David R. Musser","image"]}],[{"i":"321-selection-algorithm","l":"3.2.1. Selection Algorithm"},{"l":"1. Selection of Both Maximum and Minimum Elements","p":["Problem- Find both the maximum and the minimum elements of a set containing n elements (assume n = 2m for some integer m).","[Aho 2.6]","T(n) = (n-1) + (n-2) = 2n-3 comparisons","T(n) = 2T(n/2) + 2 for n > 2, T(n) = 1 for n = 2","→ T(n) = (3/2)n - 2 comparisons","This is the minimum!"]},{"l":"2. Multiplication of Two n-bit Numbers","p":["The traditional method requires O(n^2) bit operations.","A divide-and-conquer approach","image","xy = (a2^{\\frac n 2} + b)(c2^{\\frac n 2} + d) = ac2^n + (ad+bc)2^\\frac n 2 + bd","[Aho 2.6]","T(n) = 1 for n = 1","T(n) = 3T(n/2) + cn for n > 1→ T(n) = O(nlog3)","O(n^2) → O(n^{1.59})","Read [Neapolitan 2.6]."]}],[{"i":"322-selection-of-the-k-th-smallest-element","l":"3.2.2. Selection of the k-th Smallest Element","p":["ref.[A. Aho, J. Hopcroft, and J. Ullman, Design and Analysis of Algorithms, Addison-Wesley, 1974. 3.6]","Problem","Given a sequence of S of n elements and an integer k (1 <= k <= n), find the k^{th} smallest element of S.","Solution 1:","Choose the smallest element repeatedly k times.","C = c(n-1)+c(n-2)+c(n-3)+...+c(n-k) = c \\cdot k \\cdot n - c \\cdot \\frac {k(k+1)} 2","if k= \\frac n 2 then C = c \\cdot \\frac {n^2} 2 - c \\cdot \\frac {n^2 + 2n} 8 = O(n^2)","Solution 2:","Build a min-heap, and then extract the smallest element repeatedly k times.","C = c \\cdot n + d \\cdot k \\cdot log n","if k= \\frac n 2 then C = c \\cdot n + d \\cdot \\frac n 2 \\cdot \\log n = O(n \\log n)","Can we design an O(n)-time algorithm?"]},{"l":"1. Observation","p":["At least O(n) time is necessary.","If we use a divide-and-conquer scheme like the merge sort,","What about T(n) = 3T(\\frac n 3) + cn?","image","Can we design an O(n)-time algorithm for this selection problem?","What about T(n) = T(an) + T(bn) + cn with a + b < 1?","cost : cn\\{1+(a+b)+(a+b)^2+...\\} \\leq cn \\frac 1 {1-a+b}","so O(n)"]},{"l":"2. Algorithm","p":["|S_1| <= \\frac {3n} 4","|S_3| <= \\frac {3n} 4","A divide-and-conquer strategy","At least one-fourth of the elements of S are greater than or equal to m.","At least one-fourth of the elements of S are less than or equal to m.","else find the (k – |S1| - |S2|)^{th} smallest element of S3.","else if (|S1| + |S2| >= k), then m is the k^{th} smallest element of S.","Facts","If |S1| >= k, then find the k-th smallest element of S1.","image","S1: the set of all elements less than m","S2: the set of all elements equal to m","S3: the set of all elements greater than m","Step 1: Divide S into \\lfloor \\frac {|S|} 5 \\rfloor sequence of 5 elements each with up to four leftover elements.","Step 2: Sort each 5-element sequence.","Step 3: Let M be the sequence of medians of the 5-element sets. Then, let m be the median of the elements in M.","Step 4: Let S1, S2, and S3 be the sequences of elements in S less than, equal to, and greater than m, respectively."]},{"i":"33-time-complexity","l":"3.3. Time Complexity","p":["Input size n = |S|","|M| <= \\lceil( \\frac n 5)\\rceil","|S_1| <= \\frac {3n} 4","|S_3| <= \\frac {3n} 4"]}],[{"i":"323-selection-algorithm-complexity-analysis","l":"3.2.3. Selection Algorithm: Complexity Analysis","p":["\\forall c, d \\in \\mathbb{R^+}, if the following recurrence relation holds:","$T(n) \\leq d $ for n \\leq 49","assume that n \\geq 5 and T(m) \\leq km\\forall m < n","Base case","Inductive step","Proof","So if we choose k s.t. k = max(d, 20c), T(n) \\leq kn for all n \\geq 50.","T(n) \\leq d \\leq dn\\forall n \\geq1","T(n) \\leq T(\\frac n 5) + T (\\frac {3n} 4) + cn for n \\geq 50","T(n)\\leq k \\frac n 5 + k \\frac {3n} 4+ cn = \\frac {19}{20}kn +cn","T(n)= kn + (c-\\frac k {20})n \\leq kn if k \\geq 20c","then T(n) = O(n)","Then, T(n) \\leq T(\\frac n 5) + T (\\frac {3n} 4) + cn","Theorem","Therefore, $T(n) \\leq kn $ \\forall 1 \\leq n \\leq 49 if we select k such that k \\geq d","We want to prove that T(n) \\leq kn for some constant k, \\forall n \\geq 1"]}],[{"i":"333-master-theorem","l":"3.3.3. Master Theorem"},{"l":"Master Theorem 1","p":["[Neapolitan 2.8]","Let a, b, and c be nonnegative constants.","The solution to the recurrence T (1)=1, and T(n)=aT(\\frac n c)+bn, for n>1 for n a power of c is","T(n)=O(n), if a<c","T(n)=O(n \\log n), if a=c","T(n) = O(n \\log ca), if a > c","Prove this by induction!","Avoid divided-and-conquer if, for example–","An instance of size n is divided into two or more instances each almost of size n.","An instance of size n is divided into almost n instance of size \\frac n c, where c is a constant.","The divide-and-conquer strategy often leads to efficient algorithms, although not always!"]},{"l":"Master Theorem 2","p":["212p"]}],[{"i":"34-miscellaneous","l":"3.4. Miscellaneous"},{"l":"Finding the Closest Pair of 2D Points"},{"l":"1. 내용","p":["[J. Kleinberg and E. Tardos, Algorithm Design, Addison Wesley, 2005. 5.4]","Problem","Given n points in the plane, find the pair that is closest together.","Notation","Naïve algorithm","Compute the distance between each pair of points","take the minimum → O(n^2) time"]},{"l":"2. Applying the Divide-and-Conquer Strategy","p":["[Combine] Use this information to get the closest pair in P→ O(n)","[Conquer] Find the closest pairs in Q and R, respectively→ 2T(n/2)","[Divide] Partition P into two subsets Q and R→ O(n)","[Fact 1] (Why?)","[Fact 2]","[Fact 3]","[merge] : O(n)","[Preprocessing]","[Recursion for P with |P| = n]","[Shamos and Hoey]","\\delta=min(d(q_0^*,q_1^*),d(r_0^*,r_1^*))","\\exists q \\in Q, r\\in R for which d(q,r)<\\delta\\iff\\exists s, s^{'} \\in S for which d(s,s^{'})<\\delta","✓ Can be done in O(n)","Build a list P_x in which all the points in P have been sorted by increasing x-coordinate→ O(n \\log n)","Build another list P_y in which all the points in P have been sorted by increasing y-coordinate→ O(n \\log n)","Can be done in 2T(\\frac n 2).","Compare d(s, s^{'}) with \\delta","Create Q and R, where","Each box contains at most one point of S. (Why?)","For each s \\in S_y, compute its distance to each of the next 15 pts in S_y","Furthermore, create Q_x, Q_y, R_x, and R_y, where","General idea","How can we answer this question in linear time?","if s, s^{' } \\in S have the property that d(s, s^{'})<\\delta, then s, s^{'} re within 15 positions of each other in the sorted list S_y","if there \\exists q \\in Q , r \\in R for which d(q,r)<\\delta","If two points in S are at least 16 positions apart in S_y, ...","image","Let s, s^{'} be the pair achieving the minimum of these distances","No two points in P have the same x-coordinate or the same y- coordinate.","Q_x consisting of the points in Q sorted by increasing x-coordinate,","Q_y consisting of the points in Q sorted by increasing y-coordinate,","Q: the set of points in the first \\lceil(n/2)\\rceil positions of the list P_x(the “left half”),","Question : are there points q \\in Q, r \\in R for which d(q,r)<\\delta?","R_x consisting of the points in R sorted by increasing x-coordinate,","R: the set of points in the final \\lfloor(n/2) \\rfloor positions of the list P_x(the “right half”).","Recursively determine a closest pair (q_0, q_1) of points in Q.","Recursively determine a closest pair (r_0, r_1) of points in R.","Ry consisting of the points in R sorted by increasing y-coordinate.","S_y: the list consisting of the points in S sorted by increasing y-coordinate.","Simple assumption for an easy explanation","The stage [Combine]: Use the obtained info. to get the closest pair in P.","The stage [Conquer]: Find the closest pairs in Q and R, respectively.","The stage [Divide]: Partition P into two subsets Q and R.","then each of q,r lies within a distance \\delta of$ L$","Time-complexity O(n \\log n) + T(n) where T(n) = cn +2T(n/2) → O(n \\log n)","x^*: the x-coordinate of the rightmost point in Q"]}],[{"i":"#","p":["Divide-and-Conquer Techniques and Sorting Techniques","Divide-and-Conquer Method","Dynamic Programming Method","Greedy Method","Backtracking Method","Local Search Method","Branch-and-Bound Method","Etc."]},{"l":"The Divide-and-Conquer Approach","p":["Divide an instance of a problem into one or more smaller instances.","문제의 인스턴스를 하나 이상의 작은 인스턴스로 나눕니다.","Conquer(Solve) each of the smaller instances. Unless a smaller instance is sufficiently small, use recursion to do this.","각 작은 인스턴스를 정복합니다. 작은 인스턴스가 충분히 작지 않으면 재귀적을 사용하여 이 작업을 수행합니다.","If necessary, combine the solutions to the smaller instances to obtain the solution to the original instance.","필요한 경우 작은 인스턴스에 대한 솔루션을 결합하여 원래 인스턴스에 대한 솔루션을 확보합니다.","image"]},{"l":"Recursion","p":["Tower of Hanoi","Geeksforgeeks","image","T(n) = 2T(n-1) +1, n>1, T(1) = 1","Recursive thinking!","princeton"]},{"l":"1. Sorting","p":["A sorting algorithm is said to be stable if two items with equal keys appear in the same order in sorted output as they appear in the input array to be sorted.","Are the keys of items very long or hard to compare?","Do you have to worry about disk accesses? 디스크 액세스에 대해 염려해야 합니까?","Do you know the distribution of the items?","Do you need a stable sorting algorithm? 안정적인 정렬 알고리즘이 필요한가?","Ex: non-increasing, non-decreasing, or etc.","Given a list of n items, arrange them in a certain order.","How many items will you be sorting? 얼마나 많은 원소를 정렬할 것인가?","How much time do you have to write and debug your routine? 루틴을 작성하고 디버깅하는 데 얼마나 많은 시간이 필요합니까?","Is the data already partially sorted?","Is the range of possible keys very small? 가능한 키의 범위가 매우 작습니까?","Problem:","ref. Skiena, Steven S. The Algorithm Design Manual: The CD-ROM. 2 June 1997. 7 Dec. 2005,","Some criteria for choosing a sorting algorithm","Sorting Algorithm의 Stability : 정렬되지 않은 상태에서 같은 key 값을 가진 원소의 순서가 정렬 후에도 유지하느냐","What do you know about the data? 데이터에 대해 알고 계십니까?","Will there be duplicate items in the data? 데이터에 중복 항목이 있습니까?","데이터는 이미 부분적으로 정렬되어 있는가?","원래 링크 깨짐","일부 정렬 알고리즘은 삽입 정렬, 병합 정렬, 버블 정렬 등과 같이 본질적으로 안정적입니다. (정렬 후에도 원래의 순서가 유지됨)","품목의 분포를 알고 있습니까?","항목 키가 매우 길거나 비교하기 어렵습니까?"]},{"l":"A Formal Definition of Sorting","p":["A partial order on a set S is a relation R such that for each a, b, and c in S:","aRa is true (R is reflexive).","aRb and bRc imply aRc(R is transitive)","aRb and bRa imply a = b(R is antisymmetric)","A Linear Order or Total Older on a set S is a partial order R on S such that for every pair of elements a, b, either aRb or bRa.","The sorting problem","Given a sequence of n elements a_1, a_2, ..., a_n drawn from a set having a linear order $\\preceq $","find a permutation \\Pi = (\\pi_1, \\pi_2, ..., \\pi_n) of (1,2,...,n) that will map the sequence into a nondecreasing sequence a_{\\pi_1}, a_{\\pi_2},...,a_{\\pi_n} such that a_{\\pi_1} \\preceq a_{\\pi_i+1} for $1 \\leq i < n $","Ex: $ \\leq$ on \\mathbb{Z}, $ $\\subseteq $ on sets","Sorting on data with partial order?","ref. 이산수학 내용"]}],[{"l":"4. DP"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Dynamic programming 기법에 대한 이해 및 응용 능력","Greedy approach에 대한 이해 및 응용 능력","Graph 구조 표현 기법 구현 및 관련 알고리즘 응용 능력","Intractable Problem과 근사 알고리즘에 대한 이해 (희망 사항)"]}],[{"i":"41-dynamic-programming-overview","l":"4.1. Dynamic Programming: Overview","p":["A complicated problem is broken down into simpler sub-problems in a recursive manner.","a computer programming method.","A problem is broken down into subproblems which are reused several times or a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.","A solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.","Backtracking Method","Branch-and-Bound Method","Divide-and-Conquer Method","Dynamic Programming Method","Etc.","From Wikipedia: Dynamic programming is both a","Greedy Method","Local Search Method","mathematical optimization method and","NOW","Optimal substructure","Overlapping subproblems","When applicable, the method takes far less time than other methods that don't take advantage of the subproblem overlap like the divide- and-conquer technique."]}],[{"i":"42-approaches-for-recursive-formulation","l":"4.2. Approaches for Recursive Formulation"},{"i":"421-top-down-approach","l":"4.2.1. Top Down Approach","p":["T(i,j) = T(i-1,j) + T(i, j-1) + C \\cdot (2i + j) for i,j \\geq 1","T(i,0) = T(0,j) = 1 for i,j \\geq 0","Easily becomes exponential!"]},{"i":"422-bottom-up-approach","l":"4.2.2. Bottom Up Approach","p":["T(i,j) = T(i-1,j) + T(i, j-1) + C \\cdot (2i + j) for i,j \\geq 1","T(i,0) = T(0,j) = 1 for i,j \\geq 0","Often much more efficient!"]},{"i":"423-examples","l":"4.2.3. Examples"},{"i":"4231-ex1-world-series-odds","l":"4.2.3.1. [ex1] World Series Odds","p":["Problem","Dodgers and Yankees are playing the World Series in which either team needs to win n games first.","Suppose that each team has a $50%$chance of winning any game.","Let P(i,j) be the probability that if Dodgers needs i games to win, and Yankees needs j games, Dodgers will eventually win the Series.","Ex: P(2, 3) = \\frac {11}{16}","Compute P(i,j) 0 \\leq i,j \\leq n\\forall n"]},{"i":"4232-worse-a-divide-and-conquer-approach","l":"4.2.3.2. [Worse] A Divide-and-Conquer Approach","p":["Recursive formulation","$P(i,j) $","\\\\ = 1 if i=0, j>0","\\\\ = 0 if i=0, j=0","\\\\ = \\frac{P(i-1,j)+P(i,j-1)}{2} if i>0, j>0","If we solve this recurrence relation in the divide-and-conquer way,","Let T( n) be the maximum time taken by a call to P( i),where i+ j= n.","Then we can prove that T( n) is exponential!","T(1)=1, T(n) = 2T(n-1) + c \\rightarrow O(2^n)","What is the problem of this approach?"]},{"i":"4323-better-a-dynamic-programming-approach","l":"4.3.2.3. [Better] A Dynamic Programming Approach","p":["Instead of computing the same repeatedly, fill in a table as suggested below:","Time Complexity","For input size (m, n), computing P(m, n) takes O(mn)-time.","By far better than the Divide-and-Conquer approach."]}],[{"i":"43-concepts-of-dynamic-programming","l":"4.3. Concepts of Dynamic Programming","p":["Top-down → Bottom-up","When the divide-and-conquer approach produces an exponential algorithm where the same sub-problems are solved iteratively,","Take the recursive relation from the divide-and-conquer algorithm, and","replace the recursive calls with table lookups by recording a value in a table entry instead of returning it.","Three elements to consider in designing a dynamic programming algorithm","Recursive relation","Optimal substructure","Table setup","Table fill order","B(i,j)=B(i-1,j-1) + B(i-1,j) if 0<j<i","B(i,j)=1 if j=0 or j=i"]},{"l":"Application of DP"},{"i":"431-the-manhattan-tourist-problem","l":"4.3.1. The Manhattan Tourist Problem","p":["→ optimal substructure","A brute force approach","A formal description of this problem","A given optimization problem can be constructed efficiently from optimal solutions of its subproblems.","A greedy approach","A possible selection determined by a greedy approach","An example grid of size (4, 4)","Assume that a tourist may move either to east or to south only","Basic idea","Courtesy of [Jones & Pevzner 6.3]","Given a (n, m) grid, what is the time complexity T(n, m)?","Given a weighted graph (grid) G of size (n, m) with two distinguished vertices, a source (0, 0) and a sink (n, m), find a longest path between them in its weighted graph.(0, 0)","Given two street corners in the borough of Manhattan in New York City, find the path between them with the maximum number of attractions, that is, a path of maximum overall weight.","How can you use the solutions of smaller problems to build a solution of a problem?","i,j \\geq 1","i=0, j=1,2,...,n","i=j=0","j=0, i=1,2,...,m","Optimal substructure : S_{n,m} =?","Problem:","Pseudocode","S_{0,0} = 0","S_{0,j} = S_{0,j-1}+W({(0,j-1)},{(0,j)})","S_{i,0} = S_{i-1,0}+W({(i-1,0)},{(i,0)})","S_{i,j} = \\max(S_{i-1,j}+W({(i-1,j)},{(i,j)}), S_{i,j-1}+W({(i,j-1)},{(i,j)}))","Search among all paths in the grid for the longest path!","So far, we have found the cost of the longest path from source to each vertex in the grid.","Table setup and fill","Then, how can you print out the actual optimal path from source to sink?","다음 강의 주제"]},{"i":"432-chained-matrix-multiplication","l":"4.3.2. Chained Matrix Multiplication","p":["[Neapolitan 3.4]","In general, to multiply an a x b matrix with a b x c matrix using the standard method, it is necessary to do abc elementary multiplications.","Problem","Determine the minimum number of elementary multiplications, needed to multiply n matrices where $ A_i \\in R^{d_\\times d_i}$","Examples: A_1 (20 \\times 2) \\bullet A_2 (2 \\times 30) \\bullet A_3 (30 \\times 12) \\bullet A_4 (12 \\times 8)","A_1: 20 \\times 2, A_2: 2 \\times 30","$A_1(A_2(A_3 A_4)) : 30 \\times 12 \\times 8 + 2 \\times 30 \\times 8 + 20 \\times 2 \\times 8 = 3,680 $ multiplications","(A_1 A_2)(A_3 A_4) : = 8,880 multiplications","A_1((A_2 A_3 )A_4) : = 1,232 multiplications","((A_1 A_2)A_3 )A_4 := 10,320 multiplications","(A_1(A_2 A_3 ))A_4 := 3,120 multiplications","The order of multiplication is very important!","(a \\times b) \\times c = a \\times (b \\times c)"]},{"i":"433-dynamic-programming-approach","l":"4.3.3. Dynamic programming approach","p":["→ O(n) time","0","1","2","3","4","5","6","7","8","Chained matrix multiplication problem","Definition","Example: M(2, 7)","j/ i","j/i","M(2,7) = \\min_{2\\leq k \\leq 6}{\\{ M(2,k) + M(k+1,7)+d_1 d_k d_7}\\}","M(i, j): the minimum number of multiplications needed to multiply A_i through A_j (i \\leq j )","n + (n-1) \\cdot 1 + (n-2) \\cdot 2 + ... + (n-(n-1))\\cdot (n-1)\\\\= n + \\Sigma_{g=1}^{n-1}{(n-g)g}\\\\= O(n^3)","O(n log n) by Hu and Shing (1982, 1984)","O(n^2) by Yao (1972)","O(n^3) by Godbole (1973)","Optimal subtructure","Printing optimal order","Table fill order","Time complexity"]}],[{"i":"44-principles-of-dynamic-programming","l":"4.4. Principles of Dynamic Programming","p":["C_{ij}= the cost of the shortest path from (0,0) to (i,j)","Then C_{ij} = min \\{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \\}","Recursive formulation","Optimal substructure","Overlapping subproblems","Bottom-up approach"]},{"i":"441-optimal-substructure-wiki","l":"4.4.1. Optimal Substructure (wiki)","p":["Dynamic programming algorithms are often used for optimization.","A problem is said to have optimal substructure","if a solution to a given optimization problem can be constructed efficiently from optimal solutions of its subproblems.","Consequently, the first step towards devising a dynamic programming solution is to check whether the problem exhibits such optimal substructure.","Such optimal substructures are usually described by means of recursion.","C_{ij} = min \\{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \\}"]},{"i":"442-overlapping-subproblems-wiki","l":"4.4.2. Overlapping Subproblems (wiki)","p":["To solve a problem, we often need to solve different parts of the problem (subproblems), then combine the solutions of the subproblems to reach an overall solution.","A problem is said to have overlapping subproblems if","the problem can be broken down into subproblems which are reused several times or","a recursive algorithm for the problem solves the same subproblem over and over rather than always generating new subproblems.","C_{ij} = min \\{C_{i-1,j} + w_{i-1, j} ^{s},C_{i-1,j-1} + w_{i-1, j-1} ^{se},C_{i,j-1} + w_{i, j-1} ^{e} \\}","The dynamic programming approach seeks to solve each subproblem only once, thus reducing the number of computations:","(i) once the solution to a given subproblem has been computed, it is stored or \" memoized\":","(ii) the next time the same solution is needed, it is simply looked up.","This approach is especially useful when the number of repeating subproblems grows exponentially as a function of the size of the input.","If a problem can be solved by combining optimal solutions to non-overlapping sub-problems, the strategy is called \"divide-and- conquer\" instead. This is why merge sort and quick sort are not classified as dynamic programming problems."]},{"i":"443-the-checkerboard-problem","l":"4.4.3. The Checkerboard Problem","p":["Courtesy of Wikipedia","Restrictions","A checker can start at any square on the first row (i= 1).","It can move only diagonally left forward, diagonally right forward, or straight forward.","It must pay the cost c[i] when visiting the (i, j)-position.","Cost table c [i] [j]","Problem","Given a checkerboard with n \\times n squares, and a cost function c[i][j], find the minimum-cost path from the first row to the last row.","Optimal substructure","code"]}],[{"i":"45-응용1-longest-common-subsequence-lcs","l":"4.5. [응용1] Longest Common Subsequence (LCS)","p":["[T. Cormen et al., Introduction to Algorithms (3rd ed.), The MIT Press, 2009. 16.3]","A subsequence of a given sequence is just the given sequence with some elements (possibly none) left out.","Definitions","Enumerate all subsequences of X and check each subsequence to see if it is also a subsequence of Y, keeping track of the longest subsequence found.→ Exponential algorithm!","Ex: \\\\ X=<A,B,C,B,D,A,B>, \\\\ Z=<B,C,D,B>(<2,3,5,7>)","Ex: X = <A, B, C, B, D, A, B>, \\\\ X_4 = <A, B, C, B>,\\\\ X_0 = null sequence","Ex: X = <A, B, C, B, D, A, B>, \\\\ Y = <B, D, C, A, B, A>,\\\\ Z_1 = <B, C, A>,\\\\ Z_2 = <B, C, B, A>,\\\\ Z_3 = <B, D, A, B>","find a longest common subsequence of X and Y.","Given a sequence X = <x_1, x_2, ..., x_m >, X_i = <x_1, x_2, ..., x_i > is the ith prefix of X, for i = 0, 1, ..., m.","Given a sequence X = <x_1, x_2, ..., xm > another sequence Z = <z_1, z_2, ..., zk > is a subsequence of X if there exists a strictly increasing sequence <_i1, i_2, ..., i_k > of indices of X such that \\forall j = 1, 2, ..., k, we have x_{ij} = z_j.","Given two sequences X = <x_1, x_2, ..., x_m > and Y = <y_1, y_2, ..., y_n >","Given two sequences X and Y, we say that a sequence Z is a common subsequence of X and Y if Z is a subsequence of both X and Y.","If x_m \\neq y_n, then an LCS of X and Y is either an LCS of X_{m-1} and Y or an LCS of X and Y_{n-1}.","If x_m = y_n, then z_k = x_m = y_n, and Z_{k-1} is an LCS of X_{m-1} and Y_{n-1}.","Let c[i, j] be the length of an LCS of the sequences X_i and Y_j","Let X = <x_1, x_2, ..., x_m > and $Y = <y_1, y_2, ..., y_n > $be sequences, and let Z = <z_1, z_2, ..., z_k > be any LCS of X and Y.","Naïve approach","Optimal substructure for computing c[i, j]","Optimal substructure of an LCS","Problem","The LCS problem can be solved efficiently using dynamic programming."]},{"i":"451--algorithm","l":"4.5.1. O(mn) Algorithm","p":["Filling the table","Printing the LCS"]},{"i":"452-c-implementation","l":"4.5.2. C Implementation","p":["Courtesy of link"]}],[{"i":"46-응용2-the-gapped-alignment-problem","l":"4.6. [응용2] The Gapped Alignment Problem","p":["Problem","Given two sequences, find a gapped alignment that maximize the score!","Compare two sequences if they are similar (related).","Gapped alignment","Example:","A possible alignment scoring scheme","Ex: match score = 2, mismatch penalty = -1, gap penalty = -2","s","Optimal substructure"]}],[{"i":"47-응용3-longest-increasing-subsequence-lis","l":"4.7. [응용3] Longest Increasing Subsequence (LIS)","p":["Problem","Given a sequence A=(a[0], a[1],...,a[n-1]), find the length of the longest subsequence such that all elements of the subsequence are sorted increasing order.","Example","(10, 22, 9, 33, 21, 50, 41, 60, 80)→(10, 22, 33, 50, 60, 80)","(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15)→(0, 2, 6, 9, 11, 15), \\\\(0, 4, 6, 9, 11, 15) \\\\...","Algorithm","Let d[i] be the length of the LIS that ends in the element at index i. Then, the answer to the LIS problem is the maximum value of d[i], i=0,1,...,n-1","Optimal substructure","d[i] = \\max(1, \\max_{j=0,...,n-1 / a[j]<a[i]}{(d[j]+1)}) when i=0,1,..., n-1","code"]},{"l":"Minimal Triangulation","p":["[A. Aho, J. Hopcroft, and J. Ullman, Data Structures and Algorithms, Addison-Wesley, 1983. 10.2]","Problem","Given a set of n vertices for convex polygon, find a triangulation such that no two chords cross each other, and the total length of the chords selected is a minimum.","Counting all possible selections of chords in an inefficient way results in an exponential algorithm."]}],[{"i":"48-응용4-the-0-1-knapsack-problem","l":"4.8. [응용4] The 0-1 Knapsack Problem","p":["Problem","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i \\in A} p_i subject to \\Sigma_{i \\in A} w_i \\leq W","Example","\\{w_1, w_2, ..., w_5\\} = \\{6,5,10,3,4\\}","\\{p_1, p_2, ..., p_5\\} = \\{9,7,11,6,8\\}, W=15","\\rightarrow \\{1,2,5\\}","An intuitive interpretation","There are n items in a store.","The i th item weighs w_i kilograms and is worth p_i wons, where w_i and p_i are positive integers.","A thief has a knapsack that can carry at most W kilograms, where W is a positive integer.","What items should the thief take to maximize his “profit”?"]},{"l":"0. A 0-1 Knapsack Problem in Real Life","p":["10M","20M","22M","2M","3M","4M","500K","50K","600K","75M","800K","80M","City top paper network","Cost (dollars)","Expected reach (people)","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i \\in A} p_i subject to \\Sigma_{i \\in A} w_i \\leq W","Option","Problem","Radio ad campaign for 40 metro areas","ref","Super bowl","TV non peak hour campaign","Viral marketing campaign","Web advertising","Which marketing campaigns would you choose to maximize the total expected reach under the condition that, for each of these marketing campaigns, you either select it or you don’t?","You have a marketing budget of 5 million dollars.","You have the following marketing options and their paybacks in new potential customers:"]},{"l":"1. How to Solve the 0-1 Knapsack Problem","p":["\\{p_1, p_2, ..., p_4\\} = \\{3,2,4,4\\}, W=6","\\{w_1, w_2, ..., w_4\\} = \\{4,3,2,3\\}","\\max \\{(P(i-1,w), p_i+P(i-1,w-w_i))\\} if i>0 || w_i \\geq w","0 if i=0 || w = 0","Dynamic programming approach","Example","If we let A* be an optimal subset of \\{1, 2, ..., n\\},","Let P(i,w) be the maximized profit obtained when choosing items * only from the first i items under the restriction that the total weight cannot exceed w.","n \\in A* : P(n,W) = p_n + P(n-1, W-w_n)","n \\notin A* : P(n,W) = P(n-1, W)","Naïve approach","Optimal substructure","P(2,4) = \\max{(P(1,4), p_2 + P(1, 4-w_2))} = 3","P(3,5) = \\max{(P(2,5), p_3 + P(2,5-w_3))} = 6| | 0 | 1 | 2 | 3 | 4 | 5 | 6 || ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- || 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 || 1 | 0 | 0 | 0 | 0 | 3 | 3 | 3 || 2 | 0 | 0 | 0 | 2 | 3 | 3 | 3 || 3 | 0 | 0 | 4 | 4 | 4 | 6 | 7 || 4 | 0 | 0 | 4 | 4 | 4 | 8 | 8 |","P(4,2) = P(3,2) = 4","P(i-1,w) if i>0 || w_i >w","P(i,w)=","There are 2^n subsets of \\{1, 2, ..., n\\}!"]},{"l":"3. How to Reconstruct the Solution","p":["P(4,6) = \\max{(P(3,6), p_4 + P(3, 6-w_4))} = 8","P(3,3) = \\max{(P(2,3), p_3 + P(2, 3-w_3))} = 4","P(2,1) = P(1,1) = 0","P(1,1) = P(0,1) = 0","0","1","2","3","4","5","6","7","8"]},{"l":"4. Implementation and Time Complexity","p":["O(nW) Time"]},{"i":"5-0-1-knapsack-ex-1-","l":"5. 0-1 Knapsack Ex. 1: n = 6, W = 10","p":["?","0","1","10","11","12","13","14","15","16","18","19","2","3","4","5","6","7","8","9","A problem is that W is not bounded with respect to n.","Is the time-complexity O(nW) an efficient one?","No one has ever found an algorithm for the 0-1 Knapsack problem whose worst-case time complexity is better than exponential, yet no one has proven that such an algorithm is not possible!","Obtained profit: 19","P","p_i","Q","Selected items: i = 2, 3, 4, 6","This algorithm can be improved so that the worst-case number of entries computed is O(2^n).","This is not a linear-time algorithm!","w_i","What if n = 20 and W = 20!? → O(n*n!)","When W is extremely large in comparison with n, this algorithm is worse than the brute-force algorithm that simply considers all subsets."]},{"l":"6. A Variation of the 0-1 Knapsack Problem","p":["Problem","Decision Problem","Given n items of length l_1, l_2, ..., l_n, is there a subset of these items with total length exactly L?","Example\\{ 1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808, 17206, 117705, 117993 \\}, \\\\ L = 138457→ \\{1, 2, 7, 98, 343, 686, 2409, 17206, 117705\\}","Dynamic programming approach","Let P(i,w) be the maximized profit obtained when choosing items * only from the first i items under the restriction that the total weight cannot exceed w.","If we let A* be an optimal subset of \\{1, 2, ..., n\\},","n \\in A* : P(n,W) = p_n + P(n-1, W-w_n)","n \\notin A* : P(n,W) = P(n-1, W)","\\rightarrow fill (i, j)"]},{"l":"7. A Divide-and-Conquer Approach","p":["Let fill(i,j) return TRUE \\iff\\exists subset of the first i items that has total length j.","When fill(i,j) returns TRUE,","If the $i$th item is used, fill(i - 1, j - l_i) must return TRUE.","If the $i$th item is not used, fill(i - 1, j) must return TRUE.","To solve fill(int n, int L),","T(n) \\geq c if n=0","T(n) \\geq 2T(n-1) +d if n>0","\\rightarrow T(n) = \\Theta(2^n)"]},{"l":"8. A Dynamic Programming Approach","p":["The optimal substructure :","F(i,j)= FALSE if i=0, j!=0","F(i,j)= TRUE if i=0, j=0","F(i,j)= F(i-1,j) || ((l_i \\geq j) || F(i-1, j-l_i)) if i>0","O(nL) time implementation","Example","L = 15, (l_1, l_2, l_3, l_4, l_5, l_6, l_7)= (1, 2, 2, 4, 5, 2, 4)| | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 || ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- || 0 | T | F | F | F | F | F | F | F | F | F | F | F | F | F | F | F || 1 | T | T | F | F | F | F | F | F | F | F | F | F | F | F | F | F || 2 | T | T | T | T | F | F | F | F | F | F | F | F | F | F | F | F || 3 | T | T | T | T | T | T | F | F | F | F | F | F | F | F | F | F || 4 | T | T | T | T | T | T | T | T | T | T | F | F | F | F | F | F || 5 | T | T | T | T | T | T | T | T | T | T | T | T | T | T | T | F || 6 | T | T | T | T | T | T | T | T | T | T | T | T | T | T | T | T || 7 | T | T | T | T | T | T | T | T | T | T | T | T | T | T | T | T |"]},{"l":"9. Subset Sum","p":["Problem","Given a set of positive integers \\{w_1, w_2, ..., w_n\\} of size n and a postivie integer W, Find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i\\in A}{w_i} subject to \\Sigma_{i\\in A}{w_i} \\geq W","Example","\\{w_1, ..., w_9\\} = \\{20,30,14,70,40,50,15,25,80,60,10,95\\}, W=99 \\rightarrow \\{20,14,40,25\\}","Application","There are n jobs, each of which takes w_i time.","Now we have a CPU with W free cycles, and want to choose the set of jobs that minimizes the number of idle cycles.","Relation to the 0-1 Knapsack problem","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a subset A of \\{1,2,...,n\\} that maximizes \\Sigma_{i \\in A} p_i subject to \\Sigma_{i \\in A} w_i \\geq W\\iff","참고","If it is possible to solve the 0-1 knapsack problem in polynomial time, the subset sum problem can be solved in polynomial time too.","Somebody has already proven that the subset sum problem is very hard.","In other words, the subset sum problem is NP-complete. \\rightarrow Hence, the 0-1 knapsack problem is also a very hard problem. In other words, the 0-1 knapsack problem is also NP-complete."]},{"l":"10. The Fractional Knapsack Problem","p":["\\rightarrow Could be faster if only a small number of items are necessary to fill the knapsack.","A greedy approach","Choose all of the 1st item: (5, 50)","Choose all of the 3rd item: (20, 140)","Choose half of the 2nd item: (\\frac {10}{2}, \\frac{60}{2})","Choose the items, possibly partially, one by one until the knapsack is full.","Does the greedy approach always find an optimal solution to the 0- 1 Knapsack problem?","Example: \\{w_1, w_2, w_3\\} = \\{5, 10, 20\\},\\\\ \\{p_1, p_2, p_3\\} = \\{50, 60, 140\\}, w = 30\\\\ \\frac{p_1}{w_1} = 10, \\frac{p_2}{w_2} = 6, \\frac{p_3}{w_3} = 7","Given two sets of positive integers \\{w_1, w_2, ..., w_n\\} and \\{p_1, p_2, ..., p_n\\} of size n and a positive integer W, find a set of ratios of \\{r_1, r_2, ..., r_n\\}(0 \\leq r)i \\geq 1) that maximizes \\Sigma_{i} r_i \\cdot p_i subject to \\Sigma_{i} r_i \\cdot w_i \\leq W","Implementation 1 : $O(n \\log n +n) = O(n \\log n) $","Implementation 2 : O(n + k \\log n) = ?","Problem","Put the items in a heap → O(n)","Repeat the choice → O(k \\log n)","Repeat the choice → O(n)","Sort the items → $O(n \\log n) $","Sort the items in nonincreasing order by profits per unit weight \\frac{p_i}{w_i}.","The greedy method always find an optimal solution to the fractional Knapsack problem! \\leftarrow Correctness"]},{"i":"0-1-knapsack-example-2-","l":"0-1 Knapsack Example 2: n = 6, W = 10","p":["0-1 knapsack (dynamic programming)","Selected items: i = 3, 4","Obtained profit: 15","Time Complexity: O(nW)| | 1 | 2 | 3 | 4 | 5 | 6 || ---- | ---- | ---- | ---- | ---- | ---- | ---- || p_i| 4 | 5 | 12 | 3 | 4 | 3 || w_i| 4 | 2 | 9 | 1 | 6 | 2 |","Fractional knapsack (greedy)","Selected items: i = 4, 2, 6, 3(5)","Obtained profit: 17.67","Time Complexity: O(n \\log n)| | 4 | 2 | 6 | 3 | 1 | 5 || ----- | ----- | ----- | ----- | ----- | ----- | ----- || p_i| 3 | 5 | 3 | 12 | 4 | 4 || w_i| 1 | 2 | 2 | 9 | 4 | 6 || p_i/w_i| 3.000 | 2.500 | 1.500 | 1.333 | 1.000 | 0.667 |","0-1 knapsack (greedy 1)","Selected items: $i = 4, 2, 6 $","Obtained profit: 11","0-1 knapsack (greedy 2)","Selected items: i = 3","Obtained profit: 12"]}],[{"l":"5. Greedy"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Greedy approach에 대한 이해 및 응용 능력"]}],[{"i":"51-huffman-coding","l":"5.1. Huffman Coding","p":["Data compression","Data compression can save storage space for files.","Huffman coding is just one of many data compression techniques.","Problem","Given a file, find a binary character code for the characters in the file, which represents the file in the least number of bits.","Example","Original text file: ababcbbbc","Huffman codes: a=10,b=0,c=11","→ Compressed file: 1001001100011","Is it possible to have a code set where a = 01, b = 0, and c = 11?"]}],[{"i":"51-the-greedy-method","l":"5.1. The Greedy Method"},{"l":"Algorithm Design Techniques","p":["Divide-and-Conquer Method","Dynamic Programming Method","Greedy Method","Backtracking Method","Local Search Method","Branch-and-Bound Method","Etc."]},{"l":"1. The Greedy Method","p":["A technique to follow the problem-solving heuristic of making the locally optimal choice at each stage.","각 단계에서 휴리스틱적으로 최적의 선택을 하는 PS 기술","Strategy","Make the choice that appears best at each moment!","It is hoped to arrive at a globally optimal solution by making a locally optimal choice.","Pros and cons","wiki","Simple and straightforward to design an algorithm.","Does not guarantee the optimal solution to all problems","Local maximum versus global maximum"]}],[{"i":"52-prefix-codes","l":"5.2. Prefix Codes","p":["No codeword can be a prefix of any other code.","Otherwise, decoding is impossible!","Uniquely decodable!","☺ Example 1","a = 00, b = 1110, c = 110, d = 01, e = 1111, f = 10","Example 2","a = 00, b = 1100, c = 110, d = 01, e = 1111, f = 10","Binary trees corresponding to prefix codes","The code of a character c is the label of the path from the root to c.","Decoding of an encoded file is trivial.","Problem","Given a file F to be encoded with a character set V = \\{v_1, v_2, ..., v_n \\}, find an optimal prefix binary code with a corresponding binary tree T that minimizes the cost function","bits(T) = \\Sigma_{i=1}^n{freq(v_i) \\cdot depth(v_i)}","where freq(v_i) is the number of times v_i occurs in F, and depth(v_i) is the depth v_i of in T.","A Greedy approach successfully finds an optimal code."]}],[{"i":"53-huffmans-algorithm","l":"5.3. Huffman’s Algorithm"},{"l":"1. Contents","p":["Idea","Put the rarest characters at the bottom of the tree.","A greedy approach","Repeat the following until only one tree is left:","Start from a set of single node trees.","Pick up two trees u and v with the lowest frequencies.","Merge them by adding a root node w where the frequency of the new node is the sum of those of u and v.","Replace u and v by w."]},{"l":"2. Implementation and Time Complexity","p":["Implementation issues","How can you manage a dynamic set to which the following operations occur frequently:","Delete the elements with the highest priority from the list.","Insert an element with some priority into the list.","The answer is to use Priority Queue.","The priority queue can be implemented in many ways. Which one would you use?| Representation | Insertion | Deletion || --------------------- | ------------ | ------------ || Unordered array | O(1)| O(n)|| Unordered linked list | O(1)| O(n)|| Sorted array | O(n)| O(1)|| Sorted linked list | O(n)| O(1)|| Heap | O(\\log n)| O(\\log n)|","✓ The answer is to use the priority queue based on (min) heap.","→ O (n\\log n) time","insert the n single-node trees : O(n)","\\log n + \\log (n-1) + ... + \\log(2) = \\log n! = O (n \\log n)"]},{"i":"3-correctness-of-the-huffmans-algorithm","l":"3. Correctness of the Huffman’s Algorithm","p":["(Base step) When k = 0, each tree is trivially a branch of an optimal tree.","(Induction step) Suppose that the proposition is true when k = i, that S is the set of trees that exist after the $i$th step, and that T is the corresponding optimal tree. Let u and v be the root of the trees combined in the $(i+1)$st step.","(Proof by mathematical induction)","\\rightarrow (i+1)-th step","Case 1: If u and v are siblings in T, we are done.","Case 2: Otherwise, assume that u is at a level in T at least as low as v, and that w is the u’s sibling in T.","i-th step","If the set of trees obtained in the i-th step are branches in a binary tree corresponding to an optimal code, then the set of trees obtained in the $(i+1)$st step are also branches in a binary tree corresponding to an optimal code.","If we create a new tree T’ by swapping the two branches with root v and w, then bits(T’) = bits(T) + (depth(w) – depth(v))(freq(v) – freq(w)) ≤ bits(T).","Optimal binary tree","siblings, branch","Since bits(T) ≤ bits(T’), T’ is also optimal. Hence, the proposition also holds when k = i+1.","The branch in T with root w is one of the trees in S or contains one of those trees as a subtree.","Therefore, freq(w) ≥ freq(v) and depth(w) ≥ depth(v) in T","What happens if all the steps are done?","why?"]}],[{"i":"54-maximum-non-overlapping-intervals","l":"5.4. Maximum Non-overlapping Intervals","p":["` if (s_j \\geq f_k)","`` k=j","`` S = S \\cup \\{a_j\\}","A = \\{a_1, ..., a_n\\} with a_i = [s_i, f_i) for 0 \\leq s_i <f_i < \\infty","Assertion 1: For any set A of n activities, there always exists an optimal solution S that contains a_1 with the earliest finish time.","Assertion 2: If S is an optimal solution for A containing a_1, S^* = S \\ \\{a_1\\} is an optimal solution for A^* = \\{a_i \\in A | s_i \\geq f_1\\}","Correctness of “Earliest-finish-first”-based algorithm","Earliest finish first","Earliest start first","Example","for j=2 to n","Greedy algorithm","if selected, activity a_i takes place during the time interval [s_i, f_i).","Input: A = \\{a_1, ..., a_n\\} with a_i = [s_i, f_i) for 0 \\leq s_i < f_i <\\infty","k=1;","Let A = \\{a_1, a_2, ..., a_n\\} be a set of n activities, where a_i has start time s_i and finish times f_i (0 \\leq s_i < f_i < \\infty ).","Longest one first","Now, select a largest set S of mutually compatible activities. (We assume that the activities are given in such a way that f_1 \\leq f_2 ... \\leq f_{n-1} \\leq f_n)","Possible strategies for choosing activities","Problem","return S;→ O(n \\log n + n) = O(n \\log n) time","S = \\{a_1\\}","Selecting a_1 reduces the problem to finding an optimal solution for activities not overlapping with a_1.","Shortest one first","Sort the activities so that f_1 \\leq f_2 \\leq ... \\leq f_n","Two activities a_i, a_j are called compatible if the time intervals [s_i, f_i) and [s_j, f_j) do not overlap.","귀류법 (Proof by contradiction)"]}],[{"i":"55-scheduling-minimizing-total-time-in-the-system","l":"5.5. Scheduling: Minimizing Total Time in the System","p":["A greedy approach","A naïve approach","Algorithm","C(S) = s_1 + (s_1 +s_2) + (s_1 + s_2 + s_3) + ... + (s_1 + s_2 + ... + s_n) \\\\ = n \\cdot s_1 + (n-1) \\cdot s_2 + ... + 2 \\cdot s_{n-1} + 1 \\cdot s_n \\\\ = \\Sigma_{i=1}^{n}{(n+1-i)\\cdot s_i} \\\\ = (n+1) \\Sigma_{i=1}^{n}{s_i}-\\Sigma_{i=1}^{n}{i \\cdot s_i}","Consider a system in which a server is about to serve n clients. Let T = {t_1, t_2, ..., t_n} be a set of positive numbers, where ti is the estimated time-to-completion for the ith client. What is the optimal order of service where the total (wait+service) time in the system is minimized?","Correctness : 귀류법 (Proof by contradiction)","Does the greedy approach always find a schedule that minimizes the total time in the system?","Enumerate all possible schedules of service, and select the optimal one.→ O(n!)","Example","Hair stylist with waiting clients, pending operations on a shared hard disk, etc.","If they are not scheduled in nondecreasing order, then, for at least one i(1≤i≤n-1), s_i >s_{i+1}.","Let S = [s_1, s_2, ..., s_n] be an optimal schedule, and C(S) be the total time for S.","Now consider the schedule S’ = [s_1, s_2, ..., s_{i+1}, si, ..., sn] that is obtained by interchanging s_i and s_{i+1}.","Problem","Sort T in nondecreasing order to get the optimal schedule. - → O(n \\log n)","T = {t_1, t_2, t_3} = {5, 10, 4}| Schedule | Total Time in the System || --------- | --------------------------------- || [1, 2, 3]| 5 + (5 + 10) + (5 + 10 + 4) = 39|| [1, 3, 2]| 33|| [2, 1, 3]| 10 + (10 + 5) + (10 + 5 + 4) = 44|| [2, 3, 1]| 43|| [3, 1, 2]| ☞ 4 + (4 + 5) + (4 + 5 + 10) = 32|| [3, 2, 1]| 37|","Then, C(s) - C(s') \\\\ = (i \\cdot s_{i+1} + (i+1) \\cdot s_i) - (i \\cdot s_i + (i+1) \\cdot s_{i+1}) \\\\ = s_i - s_{i+1} >0.","Therefore, ..."]}],[{"i":"56-scheduling-minimizing-lateness","l":"5.6. Scheduling: Minimizing Lateness"},{"l":"Problem","p":["Let J = {1, 2, ..., n} be a set of jobs to be served by a single processor.","The $i$th job takes t_i units of processing time, and is due at time d_i.","When the $i$th job starts at time s_i, its lateness l_i = \\max{0, s_i + t_i - d_i }.","Goal: Find a schedule S so as to minimize the maximum lateness","L = \\max{l_i}."]},{"l":"Example","p":["S = {3, 2, 6, 1, 5, 4}→ maximum lateness = 6| Job | t_i| d_i|| ---- | ------ | ------ || 1 | 3 | 6 || 2 | 2 | 8 || 3 | 1 | 9 || 4 | 4 | 9 || 5 | 3 | 14 || 6 | 2 | 15 |"]},{"l":"Possible greedy approaches","p":["Sort jobs in nondecreasing order of processing time ti","Shortest Jobs First (?)","Sort jobs in nondecreasing order of slack d_i - t_i:","Smallest Slack-Time First (?)","Sort jobs in nondecreasing order of deadline d_i:","Earliest Deadline First (O)","An optimal schedule S = \\{1, 2, 3, 4, 5, 6\\}","→ maximum lateness = 1| Job | ti | di || ---- | ------ | ------ || 1 | 3 | 6 || 2 | 2 | 8 || 3 | 1 | 9 || 4 | 4 | 9 || 5 | 3 | 14 || 6 | 2 | 15 |"]},{"i":"correctness-of-earliest-deadline-first-based-algorithm","l":"Correctness of “Earliest-deadline-first”-based algorithm","p":["사실","만약 주어진 schedule에 inversion이 있을 경우, 최소한 연달아 schedule된 두 개의 inversion된 job이 있음.","Inversion이란 deadline 관점에서 봤을 때 서로 순서가 뒤 바뀐 두 개의 job의 쌍 을 말함.","연달아 있는 inversion 상태의 두 개의 job의 순서를 서로 바꿀 경우, maximum lateness를 증가시키지 않음.","증명","$S$를 최소 개수의 inversion을 가지는 최적의 schedule이라 가정.","만약 $S$에 inversion이 없다면, 위의 방법으로 구한 schedule과 동일.","만약 $S$에 inversion이 있다면, 이 경우 연달아 있는 inversion된 두 job의 순서를 서로 바꾸면, 결과로 발생하는 schedule $S’$는 maximum lateness를 증가시키지 않음으로 역시 또 다른 최적의 schedule임.","그러나 $S’$는 S 보다 inversion의 개수가 적음. 이는 S에 대한 가정에 대한 모순. 따라서 $S$에는 inversion이 없고 따라서 이는 위의 방법으로 구한 schedule과 동일함."]}],[{"i":"57-scheduling-with-deadlines","l":"5.7. Scheduling with Deadlines"},{"l":"Problem","p":["Let J = \\{1, 2, ..., n\\} be a set of jobs to be served.","Each job takes one unit of time to finish.","Each job has a deadline and a profit.","If the job starts before or at its deadline, the profit is obtained.","Schedule the jobs so as to maximize the total profit (not all jobs have to be scheduled)."]},{"i":"example","l":"Example:"},{"l":"A greedy approach","p":["Sort the jobs in non-increasing order by profit.","Scan each job in the sorted list, adding it to the schedule if possible."]},{"i":"example-1","l":"Example","p":["S = EMPTY","Is S = {1} OK?","Yes: S \\leftarrow{1} ([1])","Is S = {1, 2} OK?","Yes: S \\leftarrow{1, 2} ([2, 1])","Is S = {1, 2, 3} OK?","No.","Is S = {1, 2, 4} OK?","Yes: S \\leftarrow{1, 2, 4} ([2, 1, 4] or [2, 4, 1])","Is S = {1, 2, 4, 5} OK?","Is S = {1, 2, 4, 6} OK?","Is S = {1, 2, 4, 7} OK?"]},{"i":"example-2","l":"Example"},{"l":"Implementation Issues","p":["A key operation in the greedy approach","An $O(n^ 2)$implementation","at most i comparisons are needed to check if the new sequence is feasible.","at most i-1 comparisons are needed to add a new job in the sequence, and","Determine if a set of jobs S is feasible.","Example","Fact","For each job in the sorted order,","If yes, add it to the list of feasible sequence.","Is S = \\{1, 2, 4, 7\\} OK?→$[2(1), 7(2), 1(3), 4(3)]$→No","Is S = \\{1, 2, 4\\} OK?→$[2(1), 1(3), 4(3)]$→Yes!","Is the time complexity always O(n^2)?","Is this complexity achievable when a max heap data structure is employed","O(n \\log n) + \\Sigma_{i=2}^{n}{\\{(i-1)+i\\}} = O(n^2)","O(n \\log n+n d_{max})","O(n + k_{scanned} \\log n + k_{scanned} d_{max}) = O(n)","Otherwise, reject it.","S is feasible if and only if the sequence obtained by ordering the jobs in S according to nondecreasing deadlines is feasible.","See if the current job can be scheduled together with the previously selected jobs, using a linked list data structure.","Sort the jobs in non-increasing order by profit.","Time complexity","What if n >> d_{max} and n >> k_{scanned}?","What if n >> d_{max}?","When there are i-1 jobs in the sequence,"]},{"l":"Correctness of the Greedy Method","p":["Left as an exercise."]}],[{"i":"58-data-structures-for-disjoint-sets","l":"5.8. Data Structures for Disjoint Sets","p":["{a, c} = Find(a);","A partition of a set X is a set of non-empty subsets of X such that every element x in X is in exactly one of these subsets.","Always attach the smaller tree to the root of the larger tree.","Applications","Basic operations on disjoint sets","Classifying a set of atoms into molecules or fragments.","Computing shorelines of a terrain","Connected component labeling in image analysis","Decide if two vertices belong to the same component, or if adding an edge between them would result in a cycle.","Determine which set the particular element x is in.","Disjoint set의 path compression 연산에 대해서도 알아볼 것.","Disjoint-set data structure (union-find data structure)","Example","Example: X = \\{1, 2, 3, 4, 5, 6\\}→\\{ \\{1, 3, 5\\}, \\{2\\}, \\{4, 6\\} \\}","For (each x\\in U)","Implementation of disjoint sets using reversed trees","Make a set containing only the given element x.","Makeset( x); → { a}, { b}, { c}, { d}, { e}","Makeset(x)","May be used to determine if two elements are in the same subset.","Merge two subsets into a single subset.","Partition","ref","S = Find(x)","Scheduling with deadlines","The maximum possible rank of a tree with n elements is O(\\log n).","The number of elements in a tree of rank r is at least 2^r(Proof by induction)","The rank increases by one only if two trees of the same rank are merged.","The rank of a one-element tree is zero.","The Union and Find operations can be done in O(\\log n) in the worst case.","Time complexity: 2 Find op’s + O (1)","Time complexity: O(\\log n)","Time complexity: O(1)","Time complexity: O(depth of x in the tree)","Time complexity: O(n)","Tracking the connected components of an undirected graph","Two ways of implementing the Union Operation","Typically return an element that serves as the subset’s representative.","U=\\{a,b,c,d,e\\}","Union by rank","Union( a, c); → { a, c}, { b}, { d}, { e}","Union( c, e); → { a, c, e}, { b}, { d}","Union(x, y)","Union(x, y)(or Merge(x, y))","Used to effectively manage a collection of subsets that partition a given set of elements.","Useful for implementing the Kruskal’s algorithm for finding minimum spanning tree"]},{"l":"Another Algorithm Based on Disjoint Sets","p":["Method","d_{max}: the maximum of the deadlines for n jobs.","Add a job as late as possible to the schedule being built, but no later than its deadline.","Sort the jobs in non-increasing order by profit.","Initialize d_{max}+1 disjoint sets, containing the integers 0, 1, 2, ..., d_{max}","For each job in the sorted order,","Find the set S containing the minimum of its deadline and n.","If small(S) = 0, reject the job.","Otherwise, schedule it at time small(S), and merge S with the set containing small(S)-1.","Time complexity","O(n \\log m) for the disjoint set manipulation, where m is the minimum of n and d_{max}","O(n \\log n) for sorting the profits.","Example"]}],[{"l":"6. Graph"},{"l":"컴퓨터공학 전공자로서 본 수업을 통하여 습득하려는 능력","p":["이러한 능력을 습득하기 위하여 상당한 시간에 걸쳐 반복적인 노력이 필요함","Graph 구조 표현 기법 구현 및 관련 알고리즘 응용 능력","Intractable Problem과 근사 알고리즘에 대한 이해 (희망 사항)"]}],[{"l":"0. Basic Things to Know about Graph as a CSE Undergraduate","p":["All-pairs shortest path algorithm","Biconnected component algorithms","Biconnectivity","Breadth-first search","Connectivity","Definitions and representations","Depth-first search","Graph traversal algorithms","Kruskal’s minimum spanning tree algorithm","Minimum spanning tree algorithm","Prim’s minimum spanning tree algorithm","Shortest path algorithm","Simple connectivity","Single-source shortest path algorithm","Strong connectivity","Transitive closure"]},{"l":"1. Definitions","p":["An (undirected, simple) graph G is defined to be a pair of (V, E), where V is a non-empty finite set of elements called vertices, and E is a finite set of unordered pairs of distinct elements of V called edges.","G = (V, E) = (V(G), E(G))","Graphs that allow loops and multiple edges are often called a general graphs.","A (simple) digraph D is defined to be a pair (V, A), where V is a non-empty finite set of elements called vertices, and A is a finite set of ordered pairs of distinct elements of V called (directed) edges or (directed) arcs.","A weighted graph is a graph in which a number, called the weight, is assigned to each edge.","V = \\{ 1, 2, 3, 4, 5, 6 \\}\\\\ E = \\{ (1, 2), (1, 5), (2, 3), (2, 5), (3, 4), (4, 5), (4, 6) \\}","From Wikipedia","A subgraph of a graph G is simply a graph, all of whose vertices belong to V(G) and all of whose edges belong to E(G)."]},{"l":"Adjacency and incidence","p":["Two vertices v and w of a graph G are said to be adjacent if there is an edge joining them.","Two distinct edges of G are adjacent if they have at least one vertex in common.","The vertices v and w are then said to be incident to such an edge.","The degree of a vertex v of G is the number of edges incident to v."]},{"i":"walk-trail-circuit-path-and-cycle","l":"Walk, trail, circuit, path, and cycle","p":["-->","A circuit is a trail that is closed.","A cycle is a path containing at least one edge with an exception that the first and last vertices coincide.","A Hamiltonian cycle is a Hamiltonian path that is a cycle.","A Hamiltonian path is a path that visits each vertex exactly once.","A path is a walk in which all the vertices are distinct from one another.","A trail is a walk in which all the edges are distinct from one another.","A walk is closed if it starts and ends at the same vertex.","A walk(or edge-sequence) is an alternating sequence of vertices and edges, starting and ending at a vertex, in which each edge is adjacent in the sequence to its two endpoints.","Allowed","An Eulerian circuit exists in a connected graph G if the degree of every vertex is even, and can be found in O(|E|) time.","An Eulerian circuit is an Eulerian trail that starts and ends on the same vertex.","An Eulerian trail is a trail that visits every edge exactly once.","Circuit","Closed","Cycle","Determining whether such paths and cycles exist in graphs is the Hamiltonian path problem, which is NP-complete.","Disallowed","Edge repetition","Open","Open/Closed","Openness","Path","The definitions differ by various textbooks!!!","The length of a walk is the number of edges in it.","Trail","Vertex repetition","Walk"]},{"l":"Examples of graphs","p":["A null graph is a graph whose edge-set is empty.","A regular graph is a graph in which each vertex has the same degree.","A complete graph is a graph in which each pair of vertices is joined by an edge.","A bipartite graph is a graph in which its vertex set can be partitioned into two sets V_1 and V_2, in such a way that every edge of the graph joins a vertex of V_1 to a vertex of V2.","A connected graph is an undirected graph, in which, given any pair of vertices v and w, there is a path from v to w.","An arbitrary graph can split up into disjoint connected subgraphs called connected components.","A tree is a connected graph with no cycles.","A forest is a graph with no cycles.","Graph isomorphism","Two graphs G1 and G2 are isomorphic if there is a one-to-one correspondence between the vertices of G1 and those of G2 with the property that the number of edges joining any two vertices of G1 is equal to the number of edges joining the corresponding vertices of G2."]},{"l":"Graph Representation"},{"l":"1. Adjacency List","p":["In mathematics"]},{"l":"2. Adjacency Matrix","p":["In mathematics","Various Costs for a Graph G = (V, E)"]}],[{"i":"62-graph-search","l":"6.2. Graph Search"},{"l":"Some Problems Related to Graph Search","p":["Cycle detection","Does a given graph have a cycle of odd length?","Does a given graph have any cycle?","Find a path that uses all the edges in a graph exactly twice – once in each direction.","Find a shortest path in the graph from v to w.","Find shortest paths connecting a given vertex v with each other vertex in the graph.","General connectivity","Given a connected graph with n vertices, find a set of n-1 edges that connects the vertices.","Given two vertices, is there a path in the graph that connects them?","How many vertices are in the same connected component as a given vertex?","Is a given graph bipartite?","Is a given graph k-edge connected?","Is a graph connected?","Is a graph k-connected?","Is there a way to assign one of two colors to each vertex of a graph such that no edge connects two vertices of the same color?","Shortest path","Simple connectivity","Simple path","Single-source shortest paths","Spanning tree","st-connectivity","Two-colorability, bipartiteness, odd cycle","Two-way Euler tour","Vertex search","What is the edge connectivity and the vertex connectivity of a given graph?","What is the minimum number of edges whose removal will separate two given vertices s and t in a graph?"]},{"i":"1-graph-search-1-depth-first-search-dfs","l":"1) Graph Search 1: Depth-First Search (DFS)","p":["자료구조 과목에서 배웠음"]},{"i":"depth-first-search-review","l":"Depth-First Search: Review","p":["A graph structure definition","A Recursive implementation in C","parent = predecessor","entry time = discovery time","exit time = finish time"]},{"l":"An Abstract Implementation Using a Stack","p":["편의상 connected graph로 가정 (아닐 경우에는?)","어떤 연산이 전체 탐색을 dominate하는가?","각 꼭지점은 unvisited 상태에서 스택에 몇 번 push되는가?","전체적으로 각 edge는 몇 번 access되는가?","Time complexity","Adjacency list: O(|V|+|E|)","Adjacency matrix: O(|V|2)","기존에 배운 recursion 기반 구현과 비교할 것"]},{"i":"3-graph-search-2-breadth-first-search-bfs","l":"3) Graph Search 2: Breadth-First Search (BFS)","p":["자료구조 과목에서 배웠음"]},{"l":"An Abstract Implementation Using a Queue","p":["편의상 connected graph로 가정 (아닐 경우에는?)","어떤 연산이 전체 탐색을 dominate하는가?","각 꼭지점은 unvisited 상태에서 스택에 몇 번 push되는가?","전체적으로 각 edge는 몇 번 access되는가?","Time complexity","Adjacency list: O(|V|+|E|)","Adjacency matrix: O(|V|^2)"]}],[{"i":"63-shortest-path-algorithm","l":"6.3. Shortest Path Algorithm"},{"l":"Floyd-Warshall All-Pairs Shortest Path Algorithm","p":["A dynamic programming approach","An in-place implementation is possible.","cost[i][j]= \\infty if (i,j) \\notin E(G)","cost[i][j]= 0 if i=j","cost[i][j]= c_{ij} if (i,j) \\in E(G)","Example: k = 4 (A_k[i][j] \\leftarrow A_{k-1}[i][j])","Given a weighted graph G = (V, E) with cost function cost[i][j], find the shortest paths between all pairs of vertices. V = \\{v_0, v_1, v_2, ..., v_{n-1} \\} with |V| = n","If the shortest path from i to j going through no vertex with index greater than k does go through the vertex with index k A^k [i][j]= $A^[i][k] + A^ [k][j] $","If the shortest path from i to j going through no vertex with index greater than k does not go through the vertex with index k A^k [i][j]= A^{k-1} [i][j]","In general, the cost(weight) may be negative, but there must not exist a negative cycle in the graph.","Initialization / Table traversal order","Let A^k [i][j] be the cost of the shortest path from i to j, using only those intermediate vertices with an index ≤ k.","O(n^3) time","Optimal substructure for computing A^k [i][j] from A^{k-1} [i][j]","Path reconstruction","Problem","ref","The goal is to compute A^{n-1} [i][j] \\forall i,j = 0,1,2,...,n-1","The table computation"]}],[{"i":"641-minimum-spanning-trees","l":"6.4.1. Minimum Spanning Trees","p":["A forest is a graph with no cycles.","A minimum spanning tree for a weighted graph G = (V, E) is a spanning tree of least cost.","A naïve approach","A spanning tree for a graph G = (V, E) is a tree that contains all the vertices of G.","A tree is a connected graph T that contains no cycle.","Any two vertices of T are connected by exactly one path.","Buy-Two-Get-One-Free Theorem","Examine all the spanning trees of G, and take one having least cost.","For a graph G = (V, E) with n vertices, any two of the following three properties imply the third one:","Forest","G has n-1 edges.","G is acyclic.","G is connected.","Given a weighted graph G = (V, E), find a minimum spanning tree of G.","https://en.wikipedia.org/tree","https://www.mathreference.org/","Minimum spanning tree","Other equivalent statements ( T = (V, E) where |V| = n)","Problem","references","T contains no cycles, and has n-1 edges.","T contains no cycles, but the addition of any new edge creates exactly one cycle.","T is connected, and has n-1 edges.","The cost of a spanning tree of a weighted graph G = (V, E) is the sum of the weights of the edges in the spanning tree.","There are n^{n-2} spanning trees in K_n!","Tree","wiki"]}],[{"i":"642-kruskals-algorithm-vs-prims-algorithm-greedy","l":"6.4.2. Kruskal’s Algorithm vs Prim’s Algorithm (Greedy!)","p":["ref. Courtesy of T. Cormen et al.","Kruskal’s algorithm","In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest.","Prim’s algorithm","In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex."]},{"l":"Generic MST Algorithm and its Correctness","p":["Generic algorithm for a graph G = (V, E) with a weight function w","For an edge set A that is a subset of some MST, an edge (u, v) is called a safe edge for A if A \\cup \\{(u, v)\\} is also a subset of some MST.","Loop invariant for a set of edges A• Prior to each iteration, A is a subset of some minimum spanning tree.","Some definitions","Courtesy of T. Cormen et al.","A cut(S, V-S) of G is a partition of V.","An edge (u, v) of G crosses a cut (S, V-S) if u \\in S and v \\in V-S→ cut-set.","A cut respects a set A of edges if no edge in A crosses the cut.","An edge is a light edge crossing a cut if its weight is the minimum of any edge crossing the cut."]},{"l":"Cut Property","p":["For any cut C of the graph, if the weight of an edge e in the cut-set of C is strictly smaller than the weights of all other edges of the cut-set of C, then this edge belongs to all MSTs of the graph.","Proof:","Assume that there is an MST T that does not contain e.","Adding e to T will produce a cycle, that crosses the cut once at e and crosses back at another edge e'.","Deleting e' we get a spanning tree T∖\\{e'\\} \\cup \\{e\\} of strictly smaller weight than T. This contradicts the assumption that T was a MST.","By a similar argument, if more than one edge is of minimum weight across a cut, then each such edge is contained in some minimum spanning tree.","Loop invariant for the set A","Prior to each iteration, A is a subset of some minimum spanning tree.","Theorem","Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E.","Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A."]},{"i":"selection-of-next-edge-kruskals-algorithm","l":"Selection of Next Edge: Kruskal’s Algorithm","p":["In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest."]},{"i":"selection-of-next-edge-prims-algorithm","l":"Selection of Next Edge: Prim’s Algorithm","p":["In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.","Theorem","Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A."]},{"i":"kruskals-minimum-spanning-tree-algorithm","l":"Kruskal’s Minimum Spanning Tree Algorithm","p":["Idea","Finds an edge of the least possible weight that connects any two trees in the forest.","Implementation using disjoint-set data structure","매 단계 forest를 어떻게 관리할 것인가?","두 tree를 어떻게 병합할 것인가?","매 단계 $(u, v)$를 어떻게 선택할 것인가?","Complexity","Sort the edges by weight: O(E \\log E)","Process the edges until a tree is built: O(E \\log V)","O(E \\log E + E \\log V) = O(E \\log V)","why?","0 \\leq E \\leq O(V^2), \\log E \\leq \\log V^2"]},{"i":"an-implementation-of-the-kruskals-algorithm","l":"An implementation of the Kruskal’s algorithm","p":["geeksforgeeks"]},{"i":"prims-minimum-spanning-tree-algorithm","l":"Prim’s Minimum Spanning Tree Algorithm","p":["Idea","In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.","Algorithm","A key issue in implementation","Tree vertices와 non-tree vertices들을 어떻게 관리할 것인가?","Tree vertices와 non-tree vertices들 간의 최소 비용 edge를 어떻게 (효율적으 로) 찾을 것인가?","From Prof. Kenji Ikeda's Home Page"]},{"i":"inductive-description-of-the-prims-algorithm","l":"Inductive Description of the Prim’s Algorithm","p":["$ V={ v_0,v_1,v_2,...,v_} with|V| = n$","T^k →T^{k+1}","매번 가장 비용이 낮은 fringe edge를 선택하여 T^k 로 옮긴 후 그에 따른 처리를 함."]},{"i":"an--implementation-adjacency-matrix-사용","l":"An O(n^2) Implementation: Adjacency Matrix 사용","p":["a = 0, b = 1, c = 2, d = 3, e = 4, \\\\f = 5, g = 6, h = 7, i = 8, j = 9","st[i]: T 로 선택된 vertex i의 parent vertex 번 호 저장","fr[i]: NT 에 있는 vertex i에서 T 에 있는 vertex 중 가장 가까운 vertex의 번호","wt[i]: NT 에 있는 vertex i에 대해 그 vertex 에서 fr[i] 까지의 거리","n=|V|","모든 계산이 끝난 후 wt[i]는 어떤 정보를 가지고 있을까?"]},{"i":"an--implementation-adjacency-list-사용","l":"An O(e \\log n) Implementation: Adjacency List 사용","p":["n = | V |, e = | E |","Observations","The inner for-loop in the O(n^2) implementation visits all the vertices to update wt[] array and to find the minimum.","An O(e \\log n) time implementation is possible.","If the graph is dense, n^2 \\log n","If the graph is sparse, n \\log n","0 \\leq e \\leq \\frac{n(n-1)}{2}, O(n) \\leq e\\sim \\frac {n^2}{\\log n} \\leq O(n^2)","We need to employ the priority queue that allows","to insert a new item ( PQinsert(w))","to delete the minimum item ( w = PQdelmin())","to change the priority of an arbitrary specified item ( PQdec(w))."]}],[{"i":"643-shortest-paths-problems","l":"6.4.3. Shortest-Paths Problems","p":["dijstra@datascience","Single-source shortest-paths problem","Dijkstra’s algorithm","Only nonnegative-weight edges are present.","Bellman-Ford algorithm","Negative-weight edges may be present, but there are no negative-weight cycles.","Single-destination shortest-paths problem","Singe-pair shortest-path problem","All-pairs shortest-paths problem","Floyd-Warshall algorithm","Johnson’s algorithm for sparse graphs","The optimal-substructure property of shortest paths","Subpaths of shortest paths are shortest paths!"]},{"l":"Single-Source Shortest Path","p":["Problem","Given a weighted directed graph G = (V, E) with a weighting function w(e) (w(e) ≥ 0 for the edges in G), and a source vertex v_0, find a shortest path from v_0 to each of the remaining vertices of G.","Note","The case of an undirected graph can be handled by simply replacing each undirected edge e = (u, v) of length w(e) by two directed edges (u, v) and (v, u), each of the same length.","Only the case of a directed graph whose weights are positive (or nonnegative) is handled by the Dijkstra’s algorithm. For a graph that allows a negative weight, the Bellman-Ford algorithm is one to be used.","Before learning the single-source shortest path algorithm that builds some tree, recall how the breadth first search tries to build a BFS tree.","A breadth first search tree","A tree built by the Dijkstra’s algorithm"]},{"i":"dijkstras-single-source-shortest-path-algorithm","l":"Dijkstra’s Single-Source Shortest Path Algorithm","p":["A greedy approach","Generate the shortest paths in non-decreasing order of lengths!","$S^ 1={ v_0 }$로 설정하고 시작.","($i=k$일 때) $S k$의 꼭지점들만 사용할 경우에 대한 $v_0$에서 $v$까지의 shortest path가 구해져 있음. ($v$는 $S k$의 꼭지점)","$S k$상황에서 가장 짧은 path에 대한 꼭지점 $v$를 $S k$로 옮긴 후 적절한 처리를 수행 → S^{k+1}","($i = k+1$일 때) S^{k+1} 의 꼭지점들만 사용할 경우에 대한 $v_0$에서 $v$까지의 shortest path가 구해져 있음. ($v$는 $S^{k+1}$의 꼭지점)","다시 2. 로 감","S_n 이 다 구해졌을 경우"]},{"i":"from-prof-kenji-ikedas-home-page","l":"From Prof. Kenji Ikeda's Home Page"},{"i":"dijkstras-algorithm","l":"Dijkstra’s Algorithm","p":["(from Introduction to Algorithms by T. Cormen)","A directed graph with nonnegative weight G(V, E) with w: E→ [0,∞) and source s","Two components for each vertex v","v.d: an upper bound on the weight of a shortest path from s to v(a shortest path estimate)","v.π: the predecessor of v in the (current) shortest path","Relaxation","The process of relaxing an edge (u, v) consists of testing whether we can improve the shortest path to v found so far by going through u and, if so, updating v.d and v.π.","아직 shortest path를 찾지 못한 vertex v에 대해","새롭게 선택된 vertex u에 adjacent한 vertex v에 대해"]},{"i":"dijkstras-single-source-shortest-path-algorithm-1","l":"Dijkstra’s Single-Source Shortest Path Algorithm","p":["A key in the proof","adds u to S","At the start of each iteration of the while loop of lines 4-8, v.d = \\delta(s,v) for each vertex v \\in S","Correctness of Dijkstra’s algorithm","Dijkstra algorithm, run on a weighted, directed graph $ G=(V,E)$ with nonnegative weight function w : E \\rightarrow R and source s, terminates with v.d = \\delta(s,v)\\forall vertices v \\in V","Dijkstra’s algorithm","Loop invariant","Maintains a set S of vertices whose final shortest-path weight from the source s have already been determined.","relaxes all edges leaving u.","s --- x -y 가 shortest path이므로, $x$가 $S$에 add 되면서 x-y 에 relaxation할 때, y.d 에 $δ(s, y)$가 저장. 따라서 $u$가 $S$에 add 가 될 때에도 y.d= δ(s, y).","Select repeatedly the vertex u in V-S with the minimum shortest-path estimate","Suppose for contradiction that u be the first vertex for which u.d \\neq \\delta(s,u) when it is added to set S","Theorem","to show that for each vertex u \\in V, we have u.d = \\delta(s,u) at the time when u is added to set S","u.d \\leq \\delta(s,y) \\leq u.d \\rightarrow \\delta(s,u) = u.d","u.d \\leq y.d","When the algorithm adds a vertex u to the set S, u.d is the final shortest-path weight from s to u.","y.d = \\delta(s,y)","y.d = \\delta(s,y) \\leq \\delta (s,u) \\leq u.d","계산과정 예"]},{"i":"an--implementation--adjacency-matrix-사용","l":"An O(n^2) Implementation : Adjacency Matrix 사용","p":["S: the set of vertices, including v_0, whose shortest paths have been found","distance[w]: the length of the shortest path starting from v_0, going through vertices only in S, and ending in w( w \\notin S)","Observations","When the shortest paths are generated in nondecreasing order of length,","If the next shortest path is to vertex u, then the path from v_0 to u goes through only those vertices that are in S.","Vertex u is chosen so that it has the minimum distance distance[u] among all the vertices \\notin S.","Adding u to S may change the distance of shortest paths starting at v_0 going through vertices only in the new S, and ending at a vertex w that is not currently in the new S.","distance[w] = \\min \\{distance[w], distance[u] + length(<u, w>) \\}","V = \\{ v_0, v_1, ..., v_{n-1}\\} with |V| = n","distance[i]: the length of the SP from vertex v to i","found[i]","FALSE if the SP from vertex i has not been found,","TRUE otherwise","cost[i][j]: cost adjacency matrix","code in [Horowitz]"]},{"i":"an--implementation-adjacency-list-사용","l":"An O(e \\log n) Implementation: Adjacency List 사용","p":["매 순간 $wt[w]$에는 항상 S_k 의 꼭지점들만 사용할 경우에 대한 $v_s$에서 $w$까지의 shortest path의 길이가 저장되어 있음.","wt[] 는 앞의 프로그램에서의 distance[] 에 해당","n = |V|, e = |E|","MO ̈HRING et at., Partitioning Graphs to Speedup Dijkstra’s Algorithm, ACM Journal of Experimental Algorithmics, 2006.","Standard Dijkstra’s Algorithm","Acceleration Algorithm"]}],[{"l":"2020 06 01 biologyhyper"},{"l":"BIOLOGY_hyper","p":["고급생명과학 @ Chungnam Science High School Prof. Sujeong Ryu"]},{"l":"Contents","p":["image","고급생명과학","세포의 에너지","세포의 구성분자","광합성, 외호흡과 내호흡","세포 호흡","생물의 조절과 방어","신경에 의한 조절","호르몬에 의한 조절","면역 1, 2","유전자의 구조와 발현","염색체","유전자의 발현"]}],[{"l":"deep-learning-papers"},{"l":"Computer Vision"},{"l":"CNN Architecture","p":["AlexNet: ImageNet Classification with Deep Convolutional Neural Networks ( note)","DenseNet:","EfficientNet:( note)","GoogLeNet: Going Deeper with Convolutions","Inception-v1: GoogLeNet","Inception-v2, v3: Rethinking the Inception Architecture for Computer Vision ( note, code)","Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning","InceptionNet:","NASNet: Learning Transferable Architectures for Scalable Image Recognition ( note, code)","NIN: Network in Network","ResNet-v1: Deep Residual Learning for Image Recognition ( note)","ResNet-v2: Identity Mappings in Deep Residual Networks","ResNet:","VggNet: Very Deep Convolutional Networks for Large-Scale Image Recognition","Wide Residual Networks ( note, code)","ZFNet (DeconvNet): Visualizing and Understanding Convolutional Networks ( note, code)"]},{"l":"Visualizing CNNs","p":["DeconvNet","BP: Deep inside convolutional networks: Visualising image classification models and saliency maps ( note)","Guided-BP (DeconvNet+BP): Striving for simplicity: The all convolutional net ( note, code)","Understanding Neural Networks Through Deep Visualization"]},{"l":"Weakly Supervised Localization","p":["From Image-level to Pixel-level Labeling with Convolutional Networks (2015)","GMP-CAM: Is object localization for free? - Weakly-supervised learning with convolutional neural networks (2015) ( note, code)","GAP-CAM: Learning Deep Features for Discriminative Localization (2016) ( note, code)","c-MWP: Top-down Neural Attention by Excitation Backprop","Grad-CAM: Visual Explanations from Deep Networks via Gradient-based Localization (2017) ( note, code)"]},{"l":"Object Detection","p":["OverFeat - Integrated Recognition, Localization and Detection using Convolutional Networks ( note, code)"]},{"l":"Semantic Segmentation","p":["3D / Point Cloud","DeepLabv3+ (2018) ( note)","DeepMask","EncNet (2018)","FastFCN (2019)","FCN + atrous convolution과 CRF를 사용: DeepLap V2 (2016)","FCN + Dilated convolutions 사용: Multi-Scale Context Aggregation by Dilated Convolutions (2015)","FCN + global context 반영 위해 global pooling 사용: ParseNet (2015)","FCN + max-pooling indices를 사용: SegNet V2 (2015) ( note)","FCN + Multi-scale: Predicting Depth, Surface Normals and Semantic Labels with a Common Multi-Scale Convolutional Architecture (2015)","FCN + 모든 레이어에서 skip 사용: U-Net (2015) ( note)","FCN 개선: Fully Convolutional Networks for Semantic Segmentation (FCN_V2, 2016) ( note, code)","FCN_V1 (2014)에서 직접적인 영향을 받은 모델들:","Instance Segmentation","Mask R-CNN (2017) ( note)","PointNet (2017)","PSPNet (2016) ( note)","SGPN (2017)","SharpMask","Weakly-supervised Segmentation"]},{"l":"Style Transfer","p":["A Neural Algorithm of Artistic Style (2015)","Image Style Transfer Using Convolutional Neural Networks (2016)","Perceptual Losses for Real-Time Style Transfer and Super-Resolution (2016)","Instance Normalization:","Instance Normalization: The Missing Ingredient for Fast Stylization (2016)","Improved Texture Networks: Maximizing Quality and Diversity in Feed-forward Stylization and Texture Synthesis (2017)"]},{"i":"siamese-triplet-network","l":"Siamese, Triplet Network","p":["Triplet Network","FaceNet: A Unified Embedding for Face Recognition and Clustering ( note, code)","Learning Fine-grained Image Similarity with Deep Ranking ( note, code)","Siamese Network"]},{"l":"Mobile","p":["Shufflenet: An extremely efficient convolutional neural network for mobile devices","Mobilenets: Efficient convolutional neural networks for mobile vision applications"]},{"i":"etc","l":"Etc.","p":["A guide to convolution arithmetic for deep learning ( note)"]},{"l":"Generative Models"},{"l":"Models"},{"l":"Autoregressive Models","p":["NADE (2011)","RNADE (2013)","MADE (2015)","PixelRNN 계열","PixelCNN (2016): ( note, code1(mnist), code2(fashion_mnist))","WaveNet (2016) ( note, code)","VQ-VAE: Neural Discrete Representation Learning"]},{"l":"Variational Autoencoders","p":["VAE ( note, code1(mnist), code2(fashion_mnist))","Conditional VAE ( note, code)","VAE-GAN: Autoencoding beyond pixels using a learned similarity metric"]},{"l":"Normalizing Flow Models","p":["NICE (2014) ( note)","Variational Inference with Normalizing Flows (2015) ( code)","IAF (2016)","MAF (2017)","Glow (2018)"]},{"l":"GANs","p":["GAN: Generative Adversarial Networks ( note, code1(mnist), code2(fashion_mnist))","DCGAN ( note, code1, code2)","WGAN 계열:","WGAN: Wasserstein GAN ( note(진행중), code)","WGAN_GP: Improved Training of Wasserstein GANs","CT-GAN: Improving the Improved Training of Wasserstein GANs","infoGAN","Improved GAN:","SNGAN: Spectral Normalization for Generative Adversarial Networks ( note(진행중), code)","SAGAN:","CoGAN: Coupled Generative Adversarial Networks (note, code)"]},{"l":"Image generation"},{"l":"image-to-image","p":["cGAN: Conditional Generative Adversarial Nets (2014) ( note, code)","(내맘대로)pix2pix 계열:","pix2pix: Image-to-Image Translation with Conditional Adversarial Networks (2016) ( note)","pix2pixHD","CycleGAN:","BicycleGAN","vid2vid: Video-to-Video Synthesis","SPADE: Semantic Image Synthesis with Spatially-Adaptive Normalization (2019) ( note)","StarGAN:","PGGAN:","UNIT/MUNIT","iGAN","StyleGAN:"]},{"l":"text-to-image","p":["Generative adversarial text to image synthesis","StackGAN","AttnGAN"]},{"l":"Sequence generation","p":["WaveGAN: ( note, code)","SeqGAN:"]},{"l":"Evaluation","p":["A note on the evaluation of generative models","A Note on the Inception Score"]},{"i":"cs236-deep-generative-models","l":"CS236 (Deep Generative Models)","p":["Introduction and Background ( slide 1, slide 2)","Autoregressive Models ( slide 3, slide 4)","Variational Autoencoders","Normalizing Flow Models","Generative Adversarial Networks","Energy-based models"]},{"l":"NLP","p":["Recent Trends in Deep Learning Based Natural Language Processing ( note)"]},{"l":"RNN Architecture","p":["(Bahdanau) Neural Machine Translation by Jointly Learning to Align and Translate (2014) ( note, code)","(Luong) Effective Approaches to Attention-based Neural Machine Translation (2015)","A Neural Conversational Model","Attention","ByteNet: Neural Machine Translation in Linear Time (2017)","CNN","Convolutional Neural Networks for Sentence Classification (2014)","Deep Recurrent Models with Fast-Forward Connections for NeuralMachine Translation (2016)","Depthwise Separable Convolutions for Neural Machine Translation (2017)","End-To-End Memory Networks (2015)","Google's Neural MachineTranslation: Bridging the Gap between Human and Machine Translation (2016)","Learning Phrase Representations Using RNN Encoder-Decoder for Statistical Machine Translation (2014)","Memory Network","Memory Networks (2014)","Residual Connection","Seq2Seq","Sequence to Sequence Learning with Neural Networks (2014) ( note, code)","SliceNet: Convolutional Sequence to Sequence Learning (2017)","Transformer: Attention Is All You Need (2017)"]},{"l":"Word Embedding"},{"l":"Multimodal Learning","p":["DeVise - A Deep Visual-Semantic Embedding Model: ( note)","Unifying Visual-Semantic Embeddings with Multimodal Neural Language Models: ( note)","Show and Tell: ( note)","Show, Attend and Tell: ( note)","Multimodal Machine Learning: A Survey and Taxonomy: ( note)"]},{"i":"etc-optimization-normalization-applications","l":"Etc. (Optimization, Normalization, Applications)","p":["An overview of gradient descent optimization algorithms ( note)","Dropout:","Batch Normalization: ( pdf+memo, code)","How Does Batch Normalization Help Optimization?","Spectral Norm Regularization for Improving the Generalizability of Deep Learning ( note(진행중), code)","Wide & Deep Learning for Recommender Systems","Xavier Initialization - Understanding the difficulty of training deep feedforward neural networks","PReLU, He Initialization - Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification"]},{"l":"Drug Discovery"}],[{"l":"Drug Discovery","p":["The rise of deep learning in drug discovery: https://doi.org/10.1016/j.drudis.2018.01.039"]},{"l":"De novo design","p":["RNN 계열","Generating Focussed Molecule Libraries for Drug Discovery with Recurrent Neural Networks","Generative Recurrent Networks for De Novo Drug Design","REINVENT: Molecular De Novo Design through Deep Reinforcement Learning","GAN 계열","ORGAN","ORGANIC","Graph 계열","Geometric deep learning: going beyond Euclidean data","Deeply learning molecular structure-property relationships using graph attention neural network"]}],[{"i":"etc","l":"Etc."},{"l":"Normalization","p":["Adaptive Instance Normalization","Batch Renormalization","Batch-Instance Normalization:","Conditional Instance Normalization","Conditional normalization","Group Normalization","How Does Batch Normalization Help Optimization? 한글 자료","https://blog.lunit.io/2018/04/12/group-normalization/","https://blog.lunit.io/2018/05/25/batch-instance-normalization/","https://ml-dnn.tistory.com/6","https://yjucho1.github.io/deep%20learning%20paper/batchnorm/","Instance Normalization","Layer Normalization","Spectral Normalization","Switchable Normalization","Unconditional normalization","Weight Normalization","각종 normalization 총정리: https://subinium.github.io/introduction-to-normalization/"]},{"l":"Initialization","p":["Xavier","https://dhhwang89.tistory.com/23","He","https://calcifer1009-dev.tistory.com/11"]},{"l":"Convolution","p":["A guide to convolution arithmetic for deep learning 번역본"]}],[{"l":"Generative Models"},{"l":"개론","p":["GAN과 VAE 비교","https://taeoh-kim.github.io/blog/generative-models-part-1-vaegandcgan/","https://www.quora.com/What-are-the-pros-and-cons-of-Generative-Adversarial-Networks-vs-Variational-Autoencoders"]},{"l":"GAN","p":["최윤제님 정리 자료","원본: https://www.youtube.com/watch?v=uQT464Ms6y8","네이버 버전: https://www.youtube.com/watch?v=odpjk7_tGY0","슬라이드: https://www.slideshare.net/NaverEngineering/1-gangenerative-adversarial-network","AtoZ:","http://nbviewer.jupyter.org/github/metamath1/ml-simple-works/blob/master/GAN/GANs.ipynb","GAN tutorial","2016 한글 정리: https://kakalabblog.wordpress.com/2017/07/27/gan-tutorial-2016/","2017: https://nips.cc/Conferences/2016/Schedule?showEvent=6202","블로그","컨셉과 원리: http://learnai.tistory.com/","구현: http://jaynewho.com/post/2","라온피플 자료: http://laonple.blog.me/221190581073"]},{"l":"DCGAN","p":["DCGAN 논문 리뷰 한글:","http://laonple.blog.me/221201915691","http://artoria.us/19","https://jaejunyoo.blogspot.com/2017/02/deep-convolutional-gan-dcgan-1.html","소개 동영상: https://www.youtube.com/watch?v=7btUjE2y4NA","https://kakalabblog.wordpress.com/2017/06/04/unsupervised-representation-learning-with-dcgan-2016-%EB%85%BC%EB%AC%B8-%EB%A6%AC%EB%B7%B0/","독창적인 소개: https://dev-strender.github.io/articles/2017-07/decan-introduction","참조하기 좋은 자료들","http://www.khshim.com/archives/218","https://kakalabblog.wordpress.com/2017/06/10/gandcgan-%EB%A6%AC%EB%B7%B0-%EB%B0%9C%ED%91%9C/"]},{"l":"cGAN"},{"l":"Introduction","p":["cGAN의 특징","class label","data from different modality","GAN","gradient를 얻기 위해 backprop만 사용되고","Markov chain도 필요없고","MIR Flickr: condition이 multi-modal 정보","MNIST: condition이 class label","S.O.T.A log-likelihood estimate와 진짜같은 sample을 만들 수 있다.","some part of data for inpainting ( inpainting, 참고논문 Fig. 3)","기존 GAN과는 달리 추가적인 정보를 사용하여 data generation process를 제어하는 것이 가능함","까다로운 확률 계산을 approximating하는 것은 어려운데, 이것을 회피할 수 있는 generative model 학습 framework가 대안으로 뜨고 있다.","다양한 factor와 interation을 모델에 쉽게 포함시킬 수 있고","이 논문에서는 두 가지 데이터셋으로 실험을 진행했다.","이러한 conditioning은 아래와 같은 것들이 될 수 있다.","장점","주목받는 이유","학습 과정에서 inference도 필요없고"]},{"l":"Related Work","p":["기존 supervised neural networks의 2가지 challenge","아주 많은 수의 output category를 예측하는 모델로의 확장이 어렵다.","해결책: 다른 modality의 정보를 활용한다. ( 참고논문 Fig. 1)","=> prediction error라도 ground truth에 가까울 수 있고(e.g. table 대신 chair를 예측),","=> 학습 과정에서 unseen인 label에까지 generalized prediction이 가능하다","input에서 output으로의 매핑이 one-to-one mapping을 학습하는데 많은 연구가 집중되어 있지만, 많은 실제 문제들은 probabilistic one-to-many mapping이다. (e.g. 이미지 하나에 대해 다양한 태깅이 존재할 수 있음)","해결책: conditional probabilistic generative model을 사용한다.","=> multi-modal Deep Boltzmann Machine을 학습하는 방법 (cGAN 방법론과 유사한 접근법)","=> multi-modal neural language model 학습해서 이미지에 대한 다양한(= one-to-many) description을 생성"]},{"l":"Conditional Adversarial Nets","p":["generator와 discriminator에 추가적인 정보 y로 condition을 주면 GAN을 conditional model로 확장할 수 있다.","Generator: input noise p(z)와 y가 joint hidden representation으로 결합된다. (참고로 adversarial training framework는 hidden representation을 구성하는 방식에 상당한 유연성을 제공한다. 반면 전통적인 generative framework에서는 이게 엄청 어려웠음)","Discriminator: x와 y가 입력으로 discriminator function에 제공된다.","Objective function:![alt text] image1","Structure:![alt text] image2"]},{"l":"Experimental Results"},{"i":"1-unimodal-mnist","l":"1) Unimodal (MNIST)","p":["(one-hot vector로 인코딩된) class labels로 conditioned된 MNIST 이미지로 conditional adversarial net을 학습함.","100차원 unit hypercube에서 uniform distribution으로부터 z 추출함.","alt text","conditional adversarial net on MNIST images:","Discriminator 구현부 설명","discriminator의 아키텍쳐는 충분한 capacity만 있다면 별로 중요하지 않고, maxout이 이 task에 궁합이 좋다.","dropout keepprob: 0.5","Gaussian Parzen window log-likelihood estimate로 성능 평가","Generator 구현부 설명","learning rate: 0.1 -> 0.000001","mini-batch size: 100","momentum: 0.5 -> 0.7","Parzen window distribution을 사용해서 test set의 log-likelihood를 추정했다.( 참고 논문 5장)","stopping point: best estimate of log-likelihood on the validation set","x, y를 maxout layer(각각 240/5, 50/5)로 매핑한다.","z와 y는 각각 size 200, 1000 짜리 hidden layer(w/ ReLU)로 매핑됨. 그러고나서 양쪽 모두 size 1200짜리 두 번째 combined hidden ReLU 레이어로 매핑됨.","두 hidden layer는 joint maxout layer(240/4)로 매핑된 후 sigmoid layer로 들어간다.","마지막으로 784 차원의 MNIST 샘플을 output으로 생성하는 sigmoid unit layer가 있음.","막상 결과를 수치로 따져보면 다른 모델이 좀 더 낫다. 근데 우리 모델은 그냥 PoC라서 그런것이고 좀 더 고도화하면 나아질 것이다.","성능 평가 결과"]},{"i":"2-multimodal-flickr","l":"2) Multimodal (Flickr)","p":["UGM(user-generated metadata)","Flickr같은 사진 사이트에는 labeled data가 많다. (e.g. 사진에 연관된 사용자 태그들)","UGM은 canonical image labelling schems랑은 많이 달라서 좀 더 descriptive하다","UGM은 사람마다 다른 단어를 이용해서 같은 컨셉을 기술하기 때문에 동의어가 많다. 고로 이런 labels를 잘 normalize하는 방법이 중요하다. => word embedding을 사용한다.","자동화된 이미지 태깅","이미지 feature로 condition된 tag-vector의 분포를 생성하기 위해 conditional adversarial nets를 사용","feature","image representation: ImageNet으로 pre-train된 network에서 마지막 FC layer의 4096 차원 output을 image representation으로 사용","word representation: YFCC100M으로 skip-gram model을 학습하여 word representation으로 사용","샘플 생성 방법:","image feature vector를 condition으로 사용하여 word feature vector를 생성한다.","해당 word representation과 cosine 유사도가 높은 word들을 선별","개중에 10개의 most common words를 선택해서 evaluation에 사용함.","자세한 내용은 논문을 참조"]},{"i":"연관된-연구들-참고-이미지","l":"연관된 연구들 (참고 이미지)","p":["cGAN은 아래 연구들로 발전된다.","generative adversarial text to image synthesis![alt text] image6","pix2pix: Image-to-Image Translation with Conditional Adversarial Networks![alt text] image7"]},{"l":"같이 보면 좋은 자료","p":["김승일 소장님 발표: https://www.youtube.com/watch?v=iCgT8G4PkqI","cgan 정리 블로그:","http://t-lab.tistory.com/29","https://kangbk0120.github.io/articles/2017-08/conditional-gan"]},{"l":"InfoGAN","p":["참고자료","ppt: https://www.slideshare.net/ssuser2a5d00/infogan-paper-review","code https://github.com/1202kbs/InfoGAN-Tensorflow"]},{"l":"Auto-Encoding Variational Bayes","p":["문제제기: continuous latent variables을 가진 intractable posterior distribution과 large datasets가 있을 때 어떻게 directed probabilistic model에서 효율적인 inference and learning을 수행할 수 있을까?","제안하는것: stochastic variational inference and learning algorithm","large datasets로 확장 가능","mild differentiability conditions하에서","intractable case에서도 잘 동작","contribution:","variational lower bound를 reparameterization하여 standard SGD로 최적화할 수 있는 lower bound estimator를 산출한다.","datapoint마다 continuous latent variable이 있는 i.i.d. dataset에 대해, lower bound estimator를 사용해서 approximate inference model(= recognition model)을 intractable posterior에 fitting함으로써 posterior inference를 효율적으로 만들 수 있다.","graphical model, expectation maximization, variational inference, (TODO: 내용 추가)"]},{"l":"1 Introduction","p":["어떻게 하면 directed probabilistic models에 대한 효율적인 approximate inference and learning을 수행할 수 있을까? (이 모델의 continuous latent variables와 parameters는 intractable posterior distributions를 가진다) (TODO: 가우시안 믹스쳐 그림 추가 (잠재변수, 그래피컬 모델))","Variational Bayesian approach: intractable posterior에 대한 approximation을 최적화함","안타깝지만 common mean-field 접근법은 approximate posterior에 대한 기대값의 analytical solution을 필요로 하며, 보통은 이것도 intractable한 경우가 많다. (TODO: PRML에서 closed form이 아닌것들 보여주는 부분 설명 추가)","variational lower bound의 reparameterization이 어떻게 lower bound의 미분가능한 unbiased estimator를 산출하는지 보인다.","이 SGVB(Stochastic Gradient Variational Bayes) estimator는 continuous latent variables and/or parameters를 가진 거의 모든 모델에서 효율적인 approximate posterior inference를 위해 사용될 수 있다.","이 estimator는 standard stochastic gradient ascent 테크닉을 사용해서 간단하게 최적화할 수 있다.","AEVB(Auto-Encoding Variational Bayes) 알고리즘을 제안한다.","i.i.d. dataset이며 datapoint마다 continuous latent variable 가진 데이터셋에 적용","recognition model을 최적화하기 위해 SGVB estimator를 사용함으로써 AEVB는 inference and learning을 효율적으로 만든다.","recognition model은","간단한 ancestral sampling을 사용하여 approximate posterior inference를 효율적으로 수행하게 해준다. (ancestral sampling: 그래피컬 모델이 주어졌을 때 부모 노드에서 자식노드로 이동하는 형태로 샘플링해서 얻은 결합확률로부터 하나의 샘플 (x_1, x_2, ..., x_K)를 얻는 방법)","고로 MCMC 같은 값비싼 iterative inference 기법을 적용하지 않고도 효과적으로 모델 parameter를 학습할 수 있게 해준다.","학습된 approximate posterior inference model은 recognition, denoising, representation, visualization 같은 다수의 task에 사용될 수 있다.","recognition model에 neural network를 사용한게 바로 VAE이다."]},{"l":"2 Method","p":["여기서 사용하는 전략은 continuous latent variables를 가진 다양한 directed graphical model에서 lower bound estimator(stochastic objective function)를 유도하는데 사용될 수 있다.","다음과 같은 common case로 제한한다.","i.i.d. dataset with latent variables per datapoint","parameter에 대해 maximum likelihood(ML) or maximum a posteriori(MAP) inference 수행","latent variables에 대해 variational inference 수행","이 방법론은 streaming data같은 online, non-stationary setting에 적용될 수 있지만 이 논문에서는 단순함을 위해 fixed dataset을 가정한다."]},{"i":"21-problem-scenario","l":"2.1 Problem scenario","p":["A large dataset: 데이터가 많아서 batch optimization이 너무 비싼 경우 minibatch나 single datapoint로 파라미터를 업데이트 하고싶다.","coding theory 관점에서 unobserved variables z는 latent representation 또는 code로 생각할 수 있다. 그러므로...","Efficient approximate marginal inference of the variable x: x에 대한 prior가 필요한 모든 종류의 inference task를 가능하게 해준다. 이미지 denoising, inpainting, super-resolution 같은 것들. -> p(x)","Efficient approximate ML or MAP estimation for the parameters theta: 파라미터 자체로 관심의 대상이 될 수 있다. 실제 데이터를 닮은 artificial data 생성 같은 일들을 가능하게 해준다. -> p(x|z)","Efficient approximate posterior inference of the latent variable z given an observed value x for a choice of parameters θ: coding이나 data representation task에 유용하다. -> p(z|x)","Intractability: 아래와 같은 intractability들은 꽤 흔하며, 복잡한 likelihood function p_\\theta(\\mathbf|\\mathbf) 의 경우에 나타난다. (e.g. a neural network with a nonlinear hidden layer)","marginal likelihood의 적분 p_\\theta(\\mathbf) = \\smallint p_\\theta(\\mathbf)p_\\theta(\\mathbf|\\mathbf) d\\mathbf 가 intractable: marginal likelihood를 미분하거나 계산할 수 없다.","mean-field variational inference에서 posterior를 approixmate하는 것과는 반대로, 이것은 factorial일 필요도 없고 parameter phi가 closed-form expectation으로부터 계산되지도 않는다.","mean-field VB 알고리즘을 위해 필요한 적분이 intractable","Monte Carlo EM같은 샘플링 기반 솔루션은 datapoint 마다 expensive sampling loop가 필요하므로 너무 느리다.","p_\\theta(\\mathbf|\\mathbf) 를 decoder로 표기: code z가 주어졌을 때, 그에 해당하는 x의 가능한 값에 대한 distribution을 생성하기 때문","recognition model q_\\phi(\\mathbf|\\mathbf) 을 encoder로 표기: datapoint x가 주어졌을 때, datapoint x가 생성되어졌을 수 있는 z의 가능한 값에 대한 distribution을 생성하기 때문","true posterior density 가 intractable: EM 알고리즘을 사용할 수 없다.","대신에 recognition model parameter 를 generative model parameter 와 jointly 학습하는 방법을 소개할 것이다.","문제: marginal or posterior probability에 대한 간략화 가정을 하지 않는다. 역으로 아래 경우에도 효율적으로 동작하는 일반적인 알고리즘에 관심이 있다.","솔루션:","얘는 intractable true posterior p_\\theta(\\mathbf|\\mathbf) 의 approximation이다.","위 문제들을 해결하기 위해 recognition model q_\\phi(\\mathbf|\\mathbf) 를 도입해보자."]},{"l":"중간정리","p":["\\begin (\\mu, log\\ \\sigma) = EncoderNeuralNet_\\phi(\\mathbf) \\ q_\\phi(\\mathbf|\\mathbf) = \\mathcal(\\mathbf;\\mu, diag(\\sigma)) \\end","\\underset{\\ }\\ \\underset{\\theta}[p_\\theta(x) = \\int_ p_\\theta(x,z) = \\int_ p_\\theta(x|z)p_\\theta(z)]","all datapoints: batch gradient descent","directed graphical model의 모든 variable들이 데이터에서 observed 된다면 그냥 straightforward optimazation하면 된다.","distribution q_\\phi(z|x)를 neural network로 parameterize하면 아래와 같이 표현할 수 있다.","latent variable model 상황이라면?","latent variable은 모델에서 사용되는 variable이지만 dataset에서는 관측할 수는 없기 때문에 latent variable이라고 말한다.","latent variable을 도입하면 이 directed graphical model은 joint distribution p_theta(x,z)","latent variable을 사용하는 이해하기 쉬운 사례로는 가우시안 혼합 모델 이 있음.","minibatche data: stochastic gradient descent","observed variable x는 unknown underlying process로 부터의 random sample이라고 가정한다. 이 underlying process의 true distribution p^{*}(\\mathbf) 은 unkown이기 때문에 우리는 이 underlying process를 모델 p_\\theta(\\mathbf) 로 approximate 하려는 것이다.","p_\\theta(\\mathbf) \\approx p^{*}(\\mathbf) 이러한 parameter theta의 값을 찾는 과정이 바로 learning이다.","variational inference : General family of methods for approximating complicated densities by a simpler class of densities","variational parameter phi가 q_\\phi(z|x) \\approx p_\\theta(z|x) 요렇게 되도록 optimize한다.","그래서 parametric inference model q_\\phi(z|x) 도입","그러니까 정리해보면, 우리가 궁극적으로 구하려고 하는 것은...","그러면 위 식을 이용해서 maximum likelihood를 계산하면 될까?","만약 fully observed model 상황이라면?","보통은 maximum likelihood 방법을 사용하며, maximum likelihood ciriterion은 log\\ p_\\theta(\\mathcal) = \\sum_{\\mathbf\\in \\mathcal}^\\ log\\ p\\theta(\\mathbf) 이다. 이 objective의 gradient를 구해서 hill-climb 방식으로 iterative하게 local optimum을 찾아간다.","사족으로, 해당 문서 아래쪽에서 단순히 log-likelihood function 미분해서 파라미터를 구할 수 없는 경우(closed-form이 아니기 때문)를 봐두면 나중에 참고가 된다.","샘플을 생성하기 위해 우선 p(z) 분포에서 z 값을 생성하고 차례로 ancestral sampling을 수행한다. 이렇게 joint distribution p(x,z) = p(x|z)p(z)를 사용해 생성한 샘플 예제는 그림 (a)에서 확인할 수 있다.","여기까지의 의식의 흐름은 다음과 같다. 궁극적으로 알고 싶은건 p*(x)를 근사하는 pθ(x)를 최대화하는 θ를 찾고 싶은건데 p(x)를 바로 알기는 어려우니 z 도입. 즉 pθ(x,z)를 알고 싶다는 얘기. p(x,z)는 prior* decoder 즉 p(z)p(x|z)인데 아무 z~p(z)나 넣으면 샘플 생성이 잘 안되더라. 그래서 샘플 생성을 잘 하는 z를 p(z|x)로 구하면 어떨까? 이게 인코더. 인코더에서 posterior pθ(z|x)를 구해야 하는데 이게 intractable이라서 이걸 qφ(z|x)로 approximate한다. ![alt text]image_vae101","원래 식 (9.7)이 있지만 잠재변수를 사용하면 복잡한 혼합 모델 p(x) 대신 비교적 간단한 p(x,z)의 marginalization \\sum__\\ p(\\mathbf,\\mathbf) 으로 p(x)를 나타낼 수 있다. 이러면 조건부 확률을 사용할 수 있으므로 EM 알고리즘도 사용 가능하게 된다.","하지만 모두 다 intractable해서 계산할 수가 없다."]},{"i":"22-the-variational-bound","l":"2.2 The variational bound","p":["∇θELBO: simple.","∇φELBO: problematic. 이런 문제를 위한 monte carlo gradient estimator는 샘플링 때문에 high variance가 나타나며 impractical하다. -> reparameterization trick이 필요하다.","alt text","Decomposition of log-likelihood 참고 참고","ELBO를 최대화하는 것은 2 가지를 측면을 동시에 optimize한다.","first RHS term: approximate와 true posterior의 KL divergence","KL divergence 최소화: qφ(z|x)를 우리가 잘 다룰 수 있는 tractable한 분포(ex. gaussian) pθ(z)와 비슷하게 만든다.","marginal likelihood는 개별 datapoint들의 marginal likelihood의 합으로 구성된다. 즉 log\\ p_\\theta(\\mathbf{(1)}, ... , \\mathbf{(N)}) = \\sum_^\\ log\\ p\\theta(\\mathbf^{(i)}) 이며, 각 likelihood 식은 아래와 같이 전개된다.","pθ(x) 최대화: generative model이 점점 더 좋아진다.","second RHS term: datapoint i의 marginal likelihood에 대한 (variational) lower bound라고도 하며, 베이지안에서 marginal likelihood를 model evidence라고 하므로 evidence lower bound(ELBO)라고도 한다.","고로 식 (1)은 아래와 같이 다시 쓸 수 있는데","수식 전개는 pr12-vae 의 ELBO - eq(2) 부분 참고","수식 전개는 활석님 자료 의 VAE 7 page 참고","수식 전개는 활석님 자료 의 VAE 8 page 참고","식 (2)를 다시 쓰면 아래와 같다.","이렇게 하는 이유는 앞에서 봤듯이 pθ(x)에 직접 maximum likelihood를 적용할 수 없기 때문에 ELBO를 최대화 할것이다. L을 최대화하면 maximum likelihood도 최대화되겠지.","이제 ELBO를 두 파라미터(variational parameter φ와 generative parameter θ)에 대해 미분하고 최적화해보자. ( kingma thesis 18 page 참고)"]},{"i":"23-the-sgvb-estimator-and-aevb-algorithm-잘-모름","l":"2.3 The SGVB estimator and AEVB algorithm (잘 모름)","p":["여기서는 approximate posterior가 qφ(z|x) 형태인데 위에서 살펴본 monte carlo gradient estimator는 x로 conditioned되지 않는 qφ(z)의 경우만에 적용될 수 있다는 점에 유의하라.","특정한 mild condition을 가정하면 approximate posterior qφ(z|x)를 위해서 미분 가능한 transformation gφ(e, x)를 사용하여 random variable \\tilde{\\mathbf} \\sim q_\\phi(\\mathbf|\\mathbf)를 reparameterizate할 수 있다. 여기서 e는 (auxiliary) noise variable.","수식으로 나타내면 다음과 같다.","alt text","이렇게 하면 이제 어떤 function f(z)의 expectation의 qφ(z|x)에 대한 monte carlo estimate를 아래와 같이 수행할 수 있다.","이 테크닉을 수식 (2)에 적용하면 아래와 같이 generic Stochastic Gradient Variational Bayes(SBVB) estimator를 얻을 수 있다.","이 테크닉을 수식 (3)에 적용하면 KL-divergence term 말고 expected reconstruction error term만 sampling으로 estimation하면 된다. 이때 KL-divergence term은 φ를 regularizing한다고 해석할 수 있다. 즉, approximate posterior qφ(z|x)를 pθ(z)에 가깝게 만든다.","여기서 식 (3)에 해당하는 두 번째 버전의 SGVB estimator가 아래와 같이 나온다. 보통은 이게 앞에서 본 generic estimator 보다 작은 variance를 갖는다.","정리하면... 활석님 자료 의 VAE 11 page 참고"]},{"i":"24-the-reparameterization-trick","l":"2.4 The reparameterization trick","p":["continuous latent variable과 미분가능하 encoder와 generative model이 있을 때, change of variables를 통해 ELBO는 θ와 φ에 대해 straightforward하게 미분가능해질 수 있다.","kingma thesis Figure 2.3 참고"]},{"l":"함께 보면 좋은 자료","p":["VAE 논문: https://arxiv.org/pdf/1312.6114.pdf","킹마형 Thesis: https://pure.uva.nl/ws/files/17891313/Thesis.pdf","VAE tutorial: https://arxiv.org/abs/1606.05908","직관이 좋은 슬라이드 자료: https://www.slideshare.net/ssuser06e0c5/variational-autoencoder-76552518","동전 던지기로 설명: http://www.openias.org/variational-coin-toss","EM 관련: https://www.youtube.com/watch?v=MBr47eM4hf0","GMM 관련: https://www.youtube.com/watch?v=JNlEIEwe-Cg","Bloomberg (EM for Latent): https://www.youtube.com/watch?v=lMShR1vjbUo","CS231N (Generative Models): https://www.youtube.com/watch?v=5WoItGTWV54"]},{"l":"WaveGAN","p":["PR12 발표 동영상: https://www.youtube.com/watch?v=UXVKSSXdwb8","구현: https://github.com/chrisdonahue/wavegan/"]},{"l":"WGAN","p":["Wasserstein distance","wgan 수학 이해하기: https://www.slideshare.net/ssuser7e10e4/wasserstein-gan-i","gan to wgan: https://lilianweng.github.io/lil-log/2017/08/20/from-GAN-to-WGAN.html","http://dogfoottech.tistory.com/185","wasserstein 거리: https://rosinality.github.io/2017/04/wasserstein-%EA%B1%B0%EB%A6%AC/","Lipschitz Continuity","연속성의 종류: http://mathnmath.tistory.com/42","갑자기 왜 Lipschitz continuity가 나온걸까? convex optimization 때문: http://sanghyukchun.github.io/63/","Kantorovich-Rubinstein Duality","https://vincentherrmann.github.io/blog/wasserstein/"]},{"l":"SNGAN","p":["http://jaejunyoo.blogspot.com/2018/05/paper-skim-spectral-normalization-for-gan.html","http://keunwoochoi.blogspot.com/2018/01/spectral-normalization-for-generative.html","http://sanghyukchun.github.io/63/","http://users.ece.utexas.edu/~cmcaram/EE381V_2012F/Lecture_4_Scribe_Notes.final.pdf","https://www.math.uh.edu/~jingqiu/math4364/iterative_linear_system.pdf","https://www.youtube.com/watch?v=_MKhnZ_n3PY","https://www.youtube.com/watch?v=5VK5-KfYXDI","https://www.youtube.com/watch?v=Cnc83B3C2pY","https://www.youtube.com/watch?v=GMiOPeqAwlw","https://www.youtube.com/watch?v=iXSYqohGQhM","https://www.youtube.com/watch?v=pgJ2Sg1jcYQ","https://www.youtube.com/watch?v=pI9faLfYrH8","https://www.youtube.com/watch?v=sv1R8gualO8","https://www.youtube.com/watch?v=UtNPmGw60jg","https://www.youtube.com/watch?v=VpYyGfs0SdA","https://www.youtube.com/watch?v=WPMY_ufrmzI","https://www.youtube.com/watch?v=yzRDBw1bSV0","Lipschitz 관련","matrix norm 관련","wikipedia: https://en.wikipedia.org/wiki/Matrix_norm#Special_Cases","논문 설명","동영상"]},{"l":"CS236"},{"l":"1. Autoregressive Models","p":["NADE: The Neural Autoregressive Distribution Estimator ( http://proceedings.mlr.press/v15/larochelle11a/larochelle11a.pdf)","RNADE: The real-valued neural autoregressive density-estimator ( https://arxiv.org/abs/1306.0186)","MADE: Masked Autoencoder for Distribution Estimation ( https://arxiv.org/abs/1502.03509)","Pixel Recurrent Neural Networks ( https://arxiv.org/abs/1601.06759)","Conditional Image Generation with PixelCNN Decoders ( https://arxiv.org/abs/1606.05328)","PixelCNN++: Improving the PixelCNN with Discretized Logistic Mixture Likelihood and Other Modifications ( https://arxiv.org/abs/1701.05517)","WaveNet: A Generative Model for Raw Audio ( https://arxiv.org/abs/1609.03499)"]},{"l":"2. Variational Autoencoders"},{"l":"3. Normalizing Flow Models","p":["Real NVP 저자 직강: https://www.youtube.com/watch?v=7hKul_tOfsI","수학","Change-of-Variable Technique: https://newonlinecourses.science.psu.edu/stat414/node/157/","Jacobian determinant: http://www.math.ucla.edu/~archristian/teaching/32b-sum18/session-4.pdf","Khan Academy : 행렬식과 평행사변형의 영역, Derivatives of multivariable functions","matrix determinant lemma","튜토리얼","겁나 정리 잘한 블로그","강의안이 그림 캡쳐한 블로그 글 1, 글 2","tensorflow bijector API 사용법 소개글"]},{"l":"Generative Adversarial Networks"},{"l":"Energy-based models"}],[{"l":"Image-to-image translation"},{"l":"pix2pix","p":["http://laonple.blog.me/221356582945(논문을 제대로 읽은 사람은 이사람 하나 뿐인듯;;;)","https://kakalabblog.wordpress.com/2017/08/10/pix2pix-image-to-image-translation-with-conditional-adversarial-networks/","http://www.navisphere.net/5932/image-to-image-translation-with-conditional-adversarial-networks/","코드 리뷰: https://kim6394.tistory.com/92"]},{"l":"CycleGAN","p":["https://rm-7.tistory.com/4","https://kim6394.tistory.com/84"]},{"l":"PGGAN","p":["https://ml-dnn.tistory.com/8","https://curt-park.github.io/2018-05-09/pggan/","http://jaejunyoo.blogspot.com/2018/05/paper-skim-progressive-growing-of-gans.html","https://www.slideshare.net/ssuser2a5d00/progressive-growing-of-gans-for-improved-quality-stability-and-variation","GCP로 실행해보기: https://kim6394.tistory.com/99"]},{"l":"SPADE","p":["참고"]}],[{"l":"Object Detection"},{"l":"RCNN 이전","p":["Deep Neural Networks for Object Detection (2013)","OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks (2013)"]},{"l":"R-CNN 이후","p":["RCNN 계열","R-CNN: Rich feature hierarchies for accurate object detection and semantic segmentation (2013)","Fast R-CNN","Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks","SPP","SSD","YOLO:","YOLO9000:"]},{"l":"참고자료"},{"l":"RCNN 계열 히스토리 정리","p":["https://www.slideshare.net/IldooKim/deep-object-detectors-1-20166","From R-CNN to Mask R-CNN: https://blog.athelas.com/a-brief-history-of-cnns-in-image-segmentation-from-r-cnn-to-mask-r-cnn-34ea83205de4","R-CNN to Faster R-CNN: https://blog.lunit.io/2017/06/01/r-cnns-tutorial/"]}],[{"l":"Semantic Segmentation","p":["개론 설명 블로그들","2017: http://blog.qure.ai/notes/semantic-segmentation-deep-learning-review#deeplabv3","2018:","https://mc.ai/a-peek-at-semantic-segmentation-2018/","https://medium.com/@arthur_ouaknine/review-of-deep-learning-algorithms-for-image-semantic-segmentation-509a600f7b57","2019: https://medium.com/@vahavp/why-pixel-precision-is-the-future-of-the-image-annotation-12a891367f7b"]},{"l":"DeepLab 계열 논문들","p":["참고자료","PR-045: DeepLab","Inception, Xception","CRF 관련 자료"]},{"l":"v1"},{"l":"v2","p":["https://dogfoottech.tistory.com/169","https://reniew.github.io/18/"]},{"l":"v3"},{"i":"v3-1","l":"v3+","p":["참고자료","논문 정리 1, 2, 3","코드","https://www.kaggle.com/alexanderliao/deeplabv3","deploy with TF Serving"]},{"l":"EncNet","p":["참고자료:","저자 발표 동영상: https://www.youtube.com/watch?v=vAhzirU4WqA"]},{"l":"Instance Segmentation"},{"l":"Mask R-CNN","p":["참고자료","전반","https://blog.lunit.io/2017/06/01/r-cnns-tutorial/","https://junn.in/archives/2517","https://www.pyimagesearch.com/2018/11/19/mask-r-cnn-with-opencv/","https://www.youtube.com/watch?v=RtSZALC9DlU","https://blog.naver.com/sogangori/221012300995","https://towardsdatascience.com/using-tensorflow-object-detection-to-do-pixel-wise-classification-702bf2605182","RoIAlign","https://deepsense.ai/region-of-interest-pooling-explained/","http://hugrypiggykim.com/2018/03/26/mask-r-cnn/","https://cdm98.tistory.com/33","https://www.slideshare.net/windmdk/mask-rcnn","코드","https://lazyer.tistory.com/14"]},{"l":"3D"},{"l":"Weakly-supervised Segmentation","p":["Constrained Convolutional Neural Networks for Weakly Supervised Segmentation","Weakly- and Semi-Supervised Learning of a DCNN for Semantic Image Segmentation","BoxSup: Exploiting Bounding Boxes to Supervise Convolutional Networks for Semantic Segmentation","Decoupled Deep Neural Network for Semi-supervised Semantic Segmentation","From Image-level to Pixel-level Labeling with Convolutional Networks","Weakly Supervised Instance Segmentation using Class Peak Response","ScribbleSup: Scribble-Supervised Convolutional Networks for Semantic Segmentation","Weakly- and Semi-Supervised Panoptic Segmentation","WEAKLY SUPERVISED INSTANCE SEGMENTATION USING HYBRID NETWORKS","Weakly-Supervised Semantic Segmentation Network with Deep Seeded Region Growing"]}],[{"l":"Style Transfer","p":["관련 논문 순서대로 정리:","https://blog.lunit.io/2017/04/27/style-transfer/","https://tykimos.github.io/2018/10/10/Neural_Style_Transfer_with_OpenCV/","https://harishnarayanan.org/writing/artistic-style-transfer/","http://www.chioka.in/tensorflow-implementation-neural-algorithm-of-artistic-style"]},{"l":"Perceptual Losses for Real-Time Style Transfer and Super-Resolution","p":["설명 및 구현: https://hoya012.github.io/blog/Fast-Style-Transfer-Tutorial/"]}],[{"l":"Visualizing CNNs","p":["관련 논문들 순서대로 총정리: https://blog.lunit.io/2017/04/09/back-projecting-mid-level-activations/"]},{"l":"Convolution 관련","p":["understanding convolutions (colah): http://colah.github.io/posts/2014-07-Understanding-Convolutions/","colvolution-arithmetic: https://tensorflow.blog/a-guide-to-convolution-arithmetic-for-deep-learning/","correlation vs. convolution: http://www.popit.kr/%EB%94%AE%EB%9F%AC%EB%8B%9D%EC%98%81%EC%83%81%EC%B2%98%EB%A6%AC-convolution-correlation-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/"]},{"l":"각 논문을 위한 참고 링크들"},{"l":"DeconvNet","p":["저자 직강: https://www.youtube.com/watch?v=ghEmQSxT6tw","라온피플: https://laonple.blog.me/220680023908","간단정리: http://dambaekday.tistory.com/3","F.T가 왜 Deconv로 동작하는지 1: http://soumith.ch/ex/pages/2014/08/07/why-rotate-weights-convolution-gradient/","F.T가 왜 Deconv로 동작하는지 2: https://www.facebook.com/groups/TensorFlowKR/permalink/454949628179434/","open research: http://openresearch.ai/t/zf-net-visualizing-and-understanding-convolutional-networks/30","구현: https://github.com/InFoCusp/tf_cnnvis","https://www.slideshare.net/smrl7460/paper-review-visualizing-and-understanding-convolutional-networks-82147562","http://ferguson.tistory.com/5"]},{"l":"Guided-Backprop","p":["https://medium.com/@konpat/striving-for-simplicity-the-all-convolutional-net-springenberg-et-al-2014-85da395be338"]},{"l":"ResNet visualization","p":["Visualizing Residual Networks( paper): 학생들이 프로젝트 과제로 쓴거라 별 내용은 없네..."]}],[{"l":"Weakly Supervised Localization"},{"l":"CAM","p":["cam: https://github.com/sjchoi86/advanced-tensorflow/blob/master/cam/cam.ipynb","cam video: https://www.youtube.com/watch?v=-Z1NIzLxgRU&index=48&list=PLlMkM4tgfjnJhhd4wn5aj8fVTYJwIpWkS","대선주자 얼굴 위치 추적기: http://jsideas.net/python/2018/01/04/class_activation_map.html"]},{"l":"Grad-CAM","p":["grad-cam paper: https://arxiv.org/pdf/1610.02391.pdf","grad-cam video: https://www.youtube.com/watch?v=faGsrPX1yFM","구현","https://github.com/insikk/Grad-CAM-tensorflow","https://github.com/sjchoi86/deep-uncertainty/blob/master/code/demo_gradcam_resnet50.ipynb"]}],[{"l":"System Programming","p":["6. Concurrent Programming","7. Synchronization Basics","8. Synchronization Advanced","9. Thread Level Parallelism","10. Dynamic Memory Allocation - Basic Concepts","11. Dynamic Memory Allocation - Advanced Concepts","12. Linking","13. Virtual Memory Concepts"]}],[{"i":"6-concurrent-prog","l":"6. Concurrent Prog.","p":["Property: CSAPP 6"]},{"l":"Thread","p":["stack not shared, process~~ 보다 더 명확하게 state할 것"]},{"l":"Process vs Thread","p":["(message passing shared memory) Mechanism","→ process마다 addr space가 달라서 data를 share하기 어렵다 :","→ thread끼리 easy to share data","1 process내 많은 execution flow가 존재한다.","can run concurrently with others (also on different core)","context switched?","Differences","effective cost than process : process control cycle is more expensive","FIFO, shared memory, semaphore","has its own logical control flow","Heap, Data, Code가 공유된다","Local stack은 제외","on each process, physically isolated된 상태로 OS설계시 만들어진다.","Process","process privacy","Similarity","Thread","via IPC Mechanism"]},{"i":"race-deadlock-livelock-starvation-fairness--def--contents","l":"Race, Deadlock, Livelock, Starvation, Fairness : Def & contents","p":["(def) improper rsrc alloc prevents forward progress","(def) outcome depends on arbitrary scheduling decisions elsewhere in the system","(def) shared memory내 오직 한 Process만 접근 가능→ lock을 잡기 위해 매번 시도한다.","(def) 공정히 compete했음에도 한 process가 독식하며 필요한 clock cycle만큼 획득하지 못하는 현상","(def) 한 번도 lock 잡을 Chance를 갖지 못하는 Process 발생","(sol) order 설정 (OS범위)","(결과) 잡지도 못하는데도 불구하고 지속해서 시도하기에 inefficient CPU Usage","(비유) Process 하나는 잡지 못해 굶어 죽게됨","(비유) 교차로 무한대기","(비유) 교차로 무한대기 - 누구도 지나가지 못하고 state에서 횡행하며 무한대기","(비유) 무한 경쟁","(사고 접근) 화장실이 하나 있는데 대기자 5명 / 허니버터칩 등 대란","Deadlock","Fairness","Livelock","Race","Starvation"]},{"i":"process-based-concurrency-vs-event-based-concurrency-vs-thread-base-concurrency-2021기출-12","l":"Process based concurrency vs Event-based concurrency vs thread-base concurrency [2021기출-12]"},{"i":"1--process-based--server가-client-개수만큼-multiple-process","l":"1. Process-based : server가 client 개수만큼 multiple process","p":["(interprocess communication message passing shared memory)","(pros : avoid unintended sharing)과 상충되는 내용","**Listenfd 에 각 Connection 요청 마다 parent process를 accept하고 client에 fork() 를 띄워 connfd 와 client를 연결시켜 각 client마다 자신만의 address space를 가질 수 있도록 한다.","→ isolated address space :execution flow 변화 고려 필요 X","→ Process Privacy : 각 client의 space는 독립적인 고립된 공간이다.**","→ process마다 addr space가 달라서 data를 share하기 어렵다 :","110개의 client가 들어오면 110개의 Fork 진행.","additional overhead for process control - server: client개수만큼 process fork 진행","clean sharing model : file table","close its copy of connfd","Cons","FIFO, shared memory, semaphore → data share가능해짐","Handle multiple connections concurrently","Isolated","Issues :","kernel automatically interleaves : multiple logical flows","listening server process","must reap zombie child - to prevent memory leak","Nontrivial to share data between processes : Hard to share rsrcs","Pros","simple, straightforward","single process : if loop에 따라 file descriptor 본 후 event가 있는 경우 handling","Solution via IPC Mechanism","의도하지 않은 Sharing Avoidance = Process 간 Resource 공유 Nontrivial"]},{"i":"2-event-based--process-1개","l":"2. Event-Based : process 1개","p":["**connfd- Descriptor에 pending input의 유무를 확인한 후 : epoll, select","**listenfd 있다면 event 처리: accept 통해 Connection + new connfd 배열에 추가**","all flows share : same address space","ask kernel to suspend the process, returning control to applicatoin after 1개 이상의 IO Event 발생시","Can single-step with a debugger.","Cannot take advantage of multi-core","Cons","Design of choice for high-performance Web servers and search engines.","E.g., how to deal with partial HTTP request headers","e.g., Node.js, nginx, Tornado","Hard to provide fine-grained concurrency→ developer 알아서","IO Multiplexing : client 1, 2,3에 fd 따로 → Process if loop에 따라 각자 처리함","One logical control flow and address space.","programmer에 의해 mulitple logical flow (manually)","Pros","server daemon이 listenfd의 Connection request가 client로부터 오는지 보고 그에 맞춰 connfd 생성 → client-server channel 생성 후 응답","Significantly more complex to code than process- or thread-based designs.","Single thread of control + 나머지는 놀고 있다!","tedious, low-lv","total control over scheduling","Very Low overhead : No process or thread control overhead.","각 client들이 fd를 따로 두어, process의 조건에 따라 각자 처리한다.","없다면 skip한다."]},{"i":"3-thread-based--process-1개--lightweight-concurrent-programming","l":"3. Thread-Based : process 1개 → lightweight concurrent programming","p":["→ reap to free memory rsrc","→ rsrcs automatically reaped on termination","all fn called by thread must be thread-safe","careful to avoid unintended sharing → subtle, hard-to-reproduce error","Cons","detached thread - can’t be reaped, killed by others","each flows share : same address space","Easy to share data structs between threads","efficient than process : not so much control voer scheduling policies","event orderings not repeatable + shared data로 인한 unexpected error","issues","joinable thread - can be reaped, killed by other thread","kernel automatically interleaves : multiple logical flows","kernel에 의해 mulitple logical flow 자동","overhead많다: process creation overhead + process간 context switch overhead","process based + event based / mid overhead","Pros","run ‘detached’ to avoid memory leak","synchronization","구현이 복잡하다 & debug 어렵다:"]},{"l":"Thread view"},{"i":"thread--stack-variable에서-다른-thread가-visible한-이유","l":"Thread : stack variable에서 다른 thread가 visible한 이유","p":["개념 : Thread는 다른 stack invisible","실제 : trick을 통해 reference 가능","global variable indirection"]},{"l":"1. Traditional view","p":["[Process] = [Process context] + [code, data, stack]","Untitled"]},{"l":"2. Alternative view","p":["[Thread] + [code, data, kernel context]","[Thread] = [stack] + [thread context]","Untitled","each thread has","has its own logical control flow / own TID","has its own stack for logical var - not protected from other thread","same code, data, kernel context","Concurrent execution","single-core : simulate parallelism by time slicing","multi-core : true parallelism","[2021] Iterative server (6-concurrent programming)","[2021기출] iterative servers process one request at a time. in this iterative server, while a client exchanges messages with the server, the second client is blocking. however, the second client was still able to send a message even though the server didn't accept the connection request. where and how is the message sent by the second client managed?","Second client는 connection을 server에 요청했으나 First Client에 의해 blocking된 상태이다. 그러나 message를 보낼 수는 있기 때문에 해당 server process가 돌고 있는 OS의 TCP Manager내 write() 함수를 수행할 수 있다. 이는 읽을 수 없고 buffering만 되어 있는 상태이다.","실제로 수행되기 위해서는 first client가 close하여 client2와의 새로운 connection이 형성되면 해당 message를 read하고 write한다."]}],[{"i":"7-synchronization-basics","l":"7. Synchronization: Basics"},{"l":"Shared Variables in Threaded C Programs","p":["Question: Which variables in a threaded C program are shared?","The answer is not as simple as “global variables are shared” and “stack variables are private”","Def: A variable x is shared \\iff multiple threads reference some instance of x.","다수의 thread가 변수의 일부 instance를 참조할 때","Requires answers to the following questions:","What is the memory model for threads?","Thread를 위한 하부 메모리 모델?","How are instances of variables mapped to memory?","이는 어떻게 mapping되는가?","How many threads might reference each of these instances?","얼마나 많은 thread가 이 변스들을 참조하는가?"]},{"l":"Threads Memory Model","p":["Conceptual model:","Multiple threads run within the context of a single process","Each thread has its own separate thread context","자신만의 별도의 thread context :","Thread ID, stack, stack pointer, PC, condition codes, and GP registers","All threads share the remaining process context","전체 사용자 virtual address space :","Code, data, heap, and shared library segments of the process virtual address space","Open files and installed handlers","Operationally, this model is not strictly enforced:","Register values are truly separate and protected, but...","하나의 thread가 다른 thread register를 읽거나 쓰는 것은 불가능하나 모든 thread는 shared vm내 모든 위치에 접근 가능","Any thread can read and write the stack of any other thread","The mismatch between the conceptual and operation model is a source of confusion and errors"]},{"l":"Example Program to Illustrate Sharing","p":["2개의 peer thread 생성하는 1개의 main thread","main thread : 각 peer thread에 고유의 id 전달","id를 이용해 thread routine이 호출된 message와 함께 개인화된 message print"]},{"l":"Mapping Variable Instances to Memory","p":["1 instance → main thread stack에 들어감 ( tid.m)","2 instance → peer thread 0, 1에 들어감 ( myid.p0, myid.p1)","Def: Variable declared inside function with the static attribute","Def: Variable declared inside function without static attribute","Def: Variable declared outside of a function 함수 밖에서 선언된 모든 변수","Each thread stack contains one instance of each local variable","ex. myid","ex. tid","Global variables","Local static variables","Local variables","rumtime VM의 r/w영역","thread에 의해 참조될 수 있는 각 전역 변수에서 정확히 하나의 instance 참조 (Instance : ptr)","Virtual memory contains exactly one instance of any global variable","Virtual memory contains exactly one instance of any local static variable.","다수의 thread가 thread routine을 동일하게 가질 때에도 동일","자신만의 local var instance를 가짐"]},{"l":"Shared Variable Analysis","p":["(\\because 단 1개의 runtime instance를 가지고 있으며, peer thread 모두에 의해서 참조되고 있기 때문에)","Answer: A variable x is shared \\iff multiple threads reference at least one instance of x.","cnt","ex. cnt: shared","i and myid are not shared","i.m","msgs.m","myid.p0","myid.p1","ptr","Referenced by Main Thread","Referenced by peer thread 0","Referenced by peer thread 1","Thus: ptr, cnt, and msgs are shared","Variable Instance","Which variables are shared?","yes","자신의 instance 중 하나가 하나 이상의 thread에 의해 reference 되는 경우에만 공유되어 있음"]},{"l":"Synchronizing Threads","p":["Shared variables are handy... (편리하다)","...but introduce the possibility of nasty synchronization errors."]},{"i":"badcntc--improper-synchronization","l":"badcnt.c : Improper Synchronization","p":["counter variable increment code 예제 → cnt should equal 20, 000.","What went wrong ?","두 thread가 하나의 variable을 increment한다고 할 때 2 thread가 20,000 이 나와야지 이상적인 결과이다.","실제 pthread programming을 통해 각각 계산해보면 20,000이 나오지 않음.","= cnt 가 atomic하지 않는다 = cnt 실행 도중 다른 thread로 실행이 넘어가 atomic하지 않기 때문에 interleaving된다.","counter를 niters번 증가시키기에 최종 값이 2* niters라고 생각하지만 잘못된 값이 나온다"]},{"l":"Assembly Code for Counter Loop","p":["C code for counter loop in thread i","Asm code for thread i","H_i: loop 앞에 위치한 Instruction block","L_i: 공유변수 Cnt를 %Rdx 에 load하는 Instruction","( rdx_i: thread i 내의 register rdx)","U_i: %rdx 를 갱신하는 instruction","S_i: renewed %rdx 값을 다시 공유 변수 cnt로 저장하는 Instruction","T_i: loop 끝에 위치한 Instruction block","load update store : 세 가지 instruction","어떻게 interleaving되느냐에 따라 값이 다르다."]},{"l":"Concurrent Execution","p":["일반적으로 OS가 thread를 위해 정확한 순서를 선택하게 될 지의 여부를 예측할 수 있는 방법은 없다.","Key idea: In general, any sequentially consistent interleaving is possible, but some give an unexpected result!","l_i denotes that thread i executes instruction I","%rdx_i is the content of %rdx in thread i’s context","Untitled","Incorrect ordering : two threads increment the counter, but the result is 1 instead of 2","thread 1이 cnt를 2단계에서 Load한 후에 thread 1이 자신의 갱신된 값을 6단계에서 저장하기 전 thread 2가 cnt를 5단계에서 load하기 때문에 일어난다.","How bout this ordering?","We can analyze the behavior using a progress graph"]},{"l":"Progress Graphs","p":["instruction 순서를 process graph를 통해 명확히 할 수 있다.","Untitled","A progress graph depicts the discrete execution state space of concurrent threads.","하나의 상태에서 다른 상태로의 전환으로 Modeling","Each axis corresponds to the sequential order of instructions in a thread.","thread k의 진행에 대응된다","Each point corresponds to a possible execution state (Inst1, Inst2).","thread k가 I_k를 완료한 상태","그래프의 원점 : Initial state, thread 모두가 한 개의 Instruction도 완료하지 못한 상태","E.g., (L1, S2) denotes state where thread 1 has completed L1 and thread 2 has completed S2. (L1, S2) Thread 1 14"]},{"l":"Trajectories in Progress Graphs","p":["Untitled","A trajectory is a sequence of legal state transitions that describes one possible concurrent execution of the threads.","Example: H1, L1, U1, H2, L2, S1, T1, U2, S2, T2","어떤 순서로 진행되느냐에 따라 그 궤적이 달라진다.(어떻게 interleaving되느냐에 따라)","우 상향으로 interleaving됨.","trajectory 실행하는 thread"]},{"l":"Critical Sections and Unsafe Regions","p":["Untitled","Critical section : L, U, S instruction에 의해 형성 (thread i에 대해 shared var의 내용 조작)","다른 Thread의 Critical section과 중첩되면 안됨","L, U, S form a critical section with respect to the shared variable cnt","Instructions in critical sections (wrt some shared variable) should not be interleaved","Sets of states where such interleaving occurs form unsafe regions","같이 interleaving되면 안되는 구간 “critical section”","한 thread 실행 중 다른 thread가 껴드면 안됨","unsafe region Untitled","unsafe zone 은 둘레의 state에 접해 있지만 이들을 포함하지는 않는다.","Def: A trajectory is safe iff it does not enter any unsafe region","Claim: A trajectory is correct (wrt cnt) \\iff it is safe","unsafe region acccess를 막을 수 있는 방법 : synchronization"]},{"l":"Enforcing Mutual Exclusion","p":["Question: How can we guarantee a safe trajectory?","Answer: We must synchronize the execution of the threads so that they can never have an unsafe trajectory.","i.e., need to guarantee mutually exclusive access for each critical section.","def : 각각의 thread가 자신의 critical section내의 Instruction을 실행하는 동안에는 exclusively shared variable을 접근하도록 보장하기를 원하는 현상","synchronize 됐다 = 상호 배타적으로 access를 guarantee해준다.",": 여러 process가 경쟁해서 들어가면 하나만 들어갈 수 있도록 설계함","모든 safe trajectory는 shared counter를 정확히 갱신한다.","thread program의 정확한 실행과 전역 data를 공유하는 동시성 프로그램에 대해서도 어떻게든 동기화하여 안전 궤적을 가지도록 해야 한다.","Classic solution:","Semaphores (Edsger Dijkstra) : 비음수 정수 값을 값는 전역 변수로 P, V연산으로만 조작 가능","Other approaches (out of our scope)","Mutex and condition variables (Pthreads)","Monitors (Java)"]},{"l":"Semaphore","p":["non-negative global integer synchronization variable. : int s; (>=0)","Manipulated by P and V operations. semaphore variable을 바꿀 수 있는 방법 p, s 를 통해 manipulate","manipulate : int var를 증가, 감소시킴 (+복잡)","Binary semaphore vs Counting semaphore","initialize as 1 (binary) 5, 10","semaphore의 초기 value는 critical session에 들어갈 수 있는 thread 개수","critical session에는 딱 하나 thread 밖에 못 들어감","Counting semaphore는 그 값을 5로 초기화해두었다면 5개 cricial session에 들어갈 수있음","critical session에 들어가고 나서 : P를 통해 들어갈지 안들어갈지 보고,","내가 들어갔다는 이야기 = Semaphore val = 1이고 critical session에서 작업하고 나올 때 누군가가 내가 아직 critical session에서 있을 때 들어오려고 하면 P에서 blocked (semaphore val = 0) -> blocked, suspended","내가 나올 때 unlock → V fn 호출한다."]},{"i":"ps","l":"P(s)","p":["(binary semaphore기억하고 설명) Semaphore가 1로 initialize -> 두 thread가 \\frac P V","→ blocked 된 상태로 남아있고 그 semaphore에 나는 wait하고 있다며 매달려 있음","→ 깨어나게 되면, s라는 variable을 decrement하고 진행됨","After restarting, the P operation decrements s and returns control to the caller.","critical session을 앞 뒤로 쌓아서 lock을 가져다 lock을 얻으면 들어가고 얻지 못하면 기다림","If s is nonzero, then decrement s by 1 and return immediately.","If s is zero, then suspend thread until s becomes nonzero and the thread is restarted by a V operation.","Process state transition diagram에서 보면 run 상태에서 block상태로","s \\neq 0: 0이 아니면 → 1을 빼고 나서 끝난다**","s=0: 본인이 suspend된다","s라는 variable이 0인지 아닌지 봄","Test and decrement operations occur atomically(indivisibly)","until 0보다 큰 값이 될 때 : var x를 0보다 크게 만든 다음 깨워줄 때까지 기다림 (signal 받을 때까지)","나올 땐 lock을 풀어주는 구조","내가 이 var보고나서 이 함수 안에서 여러 thread중 누군가가 decrement했다는 것→ 나는 그 값이 0보다 큰 값이 될 때까지 기다릴 것이다 (suspend, sleep)","만약에 들어가려 했는데 semaphore 값을 봤는데 0이다","이 P라는 것은 semaphore value를 가져다 확인하고, 그 값이 0이 아니라면 decrement","최초로 1로 되있을 때 들어간다고 하면 decrement하여 0으로 만들고, 그리고 critical session으로 들어감"]},{"l":"정리","p":["semaphore s 를 Decrement한다","s \\neq 0- 그 값이 0보다 크면 decrement,","$s=0$이면 sleep하고 누군가가 깨워줄 때까지 suspend된다.","= CPU Cycle을 소모하지 않는다.","→ 즉 0보다 크거나 같은 값을 계속 체크하지 않고 suspended되어 있다가 signal오면 깨어나는 형태"]},{"i":"vs","l":"V(s):","p":["‘Atomically’","→ 그 thread가 decrement할수 있게 해줌","→ 그리고 나서 만일 s variable을 기다리고 있던 suspend thread가 있다면 그 중 한명을 깨워주고","→ 깨어나 ready 상태로 가 scheduler에 의해 행사되어 critical session으로 들어감","→ 여러 thread가 다같이 깨어남 : thundering herd","→ 여러 개의 thread가 하나의 Semaphore를 가지고 있을 때 어떤 것이 V의 결과로 재시작되는지는 예측 불가능","→ 이 semaphore value의 기다리고 있떤 blocked된 thread를 깨워","atomic하게 increment시키고 누군가가 s라는 variable을 decrement하지 못해서 pending되어있는 경우 (suspended된 경우), 여러 thread중 누군가 하나를 wake시켜서 decrement할 수 있게끔 한다.","block되어 기다리던 thread를 깨워 줌","If there are any threads blocked in a P operation waiting for s to become non- zero, then restart exactly one of those threads, which then completes its P operation by decrementing s.","Increment operation occurs atomically :","Increment s by 1 :","P,V 는 atomically 수행된다 : indivisibly","Semaphore invariant: (s >= 0)","semaphorevalue s 를 increment","s라는 variable을 increment해줌","S를 increment하고, 이 semaphore value에 기다리고 있던 blocked 된 thread를 깨워줌","test와 감소 연산은 semaphore s가 0이 아니면 s의 감소가 중단 없이 일어난다는 의미에서 개별적으로 일어남. V에서도 증가연산 개별적. - Semaphore를 중단 없이 load, 증가, 저장하기 때문","variable이 뭔지 test하고 이 variable을 어떤 값으로 setting해줌 (decrement)","v또한 Atomically increment해주기 때문에 변수를 하나 증가해줌","V의 정의 : 기다리고 있는 thread들이 재시작되는 순서를 정의하지 않는다.","요구하는 유일한 사항은 V가 정확히 한 개의 waiting thread를 restart","정리하면,","쪼개질 수 없는 함수이다.= p라는 함수는 실행이 되거나, 안 되거나 둘 중 하나이다."]},{"l":"QnA","p":["(질문) interleaving한다는 개념","(질문) lock을 잡는다는 것이 cpu 제어권을 가진다는 것과 동치 표현인가?","(질문) lock을 활용해 오직 하나의 thread만 running될 수 있는 상태면 context switch는 발생하지 않는가요? 결과적으론 lock을 들고 있는 thread만 실행될텐데 context switch로 인해 무의미한 overhead가 발생하지 않나 싶어 질문드립니다.","(질문) t1은 새로운 경쟁에 참여하지 않는가?","(질문) t2, t3를 다 깨워주나요?","(질문) thread들이 충분히 많을 경우 운이 없다면 영원히 lock을 받지 못하는 thread가 생길 수 있는가?","(질문) 순서 부여 방식으로는 해결이 안되는가?","\\rightarrow 순서가 있다보니 중간 interleaving되는 경우가 안 나옴.","critical session 이라고 이야기할 수 있는 cnt++","critical session 크기에 따라 항상 semaphore 쓰는게 좋다곤 할 수 없다. critical session 적당한 크기면 효과적이나, 너무 작을 경우 정말 언제 나올 것인지 polling하면 더 effective할 수 있음","critical session에 t1들어가고","critical session에서 t1, t2, t3 경쟁하는 상황에서 thread 하나밖에 들어갈 수 없으므로 lock을 잡아 들어가야 한다. 물론 누가 들어갈지는 모른다 - 3개 중 하나가 lock을 잡게 될 것이다.","ex1. Thread1번이 lock을 잡았다면","Interleaving이란 : load하기 전에 다른 thread가 load하여 겹치게 되는 경우","key를 누구한테 줄거야 : 나 나왔으니까 일어나 \\rightarrow 둘이 일어나서 둘중 하나 성공","lock을 가져다 새 떼들이 한꺼번에 모이는 problem이라고 이야기함.","lock을 풀고 나왔는데 나도 다시 경쟁할 수 있음","Lock잡은 다음 그 누구도 cpu 제어권을 가질 수 없다.","OS program 자체도 thread Untitled","overhead : tradeoff","pthread : 다 깨워주고, 그 중 한 thread만 lock을 잡아 줌.","semaphore이 에너지 효율 관점에서는 좋음. task의 길이가 무척 짧은 경우에는 sleep으로 가지 않는 mutex lock이 효과적일 수 있음.","single cpu에서는 cpu 제어권을 갖는다는 것과 lock","sleep한다음 깨어나려면 overhead : (잠깐 자다가 깨어나면 더 힘들지 않나)","t1은 새로운 경쟁에 참여하지 않는다. 이미 lock을 풀고 남았기 때문에, critical session으로 다시 들어가지 않는다. 화장실 쓰다 나왔는데, 다시 들어가지 않지 않겠느냐?","t1은 자기 혼자 독점해서 cnt++ 같은 load update store같은 것을 혼자 수행함을 보장해줌","t2, t3 는 lock을 잡으려고 p(s) 모두다 blocked된, suspend된 상태 = 자고 있는 상태→ thread 2번과 3번은 sleep된 상태","t2, t3가 들어가 있었는데 ready상태로 들어가서 줄 서서 기다린다.","Thread 1번이 load update store 수행하고 순차적으로 t2, t3가 수행함 \\rightarrow interleaving이 일어나지 않음","가정","가정) 화장실 갔는데 2,3명 기다리고 있 먼저 들어간 사람이 금방 들어갔다 나올거면 금방 나올거니까 기다리는게 나음 한참 걸릴거 같으면 기다리는 thread들이 자고 있는게 효율적","깨어날 때 context switch일어나는데 block->ready->running 상태 과정에서 overhead가 있긴 함","나는 들어갔다 나왔기 때문에 다시 안들어감","누가 먼저 running할지 모르겠지만 ready한 상태: 하나가 lock잡으면 들어감.","단, 만일 loop로 짰다고 하면 다시 경쟁에 참여할 것","둘중 하나 성공 :ready상태로 둘 다 보내놓고 경쟁하는 상황","뒤에서 기다리는 thread: sleep -> CPU Cycle 소모 x cpu 사용 : energy cost - battery 많이 먹음 그래서 일부러 sleep을 시키는것","맞습니다 (starvation문제 : 경쟁을 계속 시키다보니까)","방법 :모두다 깨워서 경쟁을 다시 시키거나, (s:->t2->t3) running 상태 → blocked 상태 → ready상태","순서 부여하기 위해 semaphore를 사용함- 순서 부여 방식이 자동적으로 생기는 것임","암묵적으로 먼저 들어간애 있으면 자동적으로 그 다음 thread에 대한 순서가 만들어짐","여러 thread 100개가 sleep할 때 동시에 wake해주면 성능이 떨어져서 단계적으로 깨워주기도 함.","여러 thread가 cnt++ 를 부르게 되면 cnt는 load-update-store 명령어로 구성되어 있다.","이후 t1이 나오게 되면 -> unlock (Lock을 풀어준다 : lock s)","자기 순서 들어가게 되면 running상태가 되어 깨워 줘서 이 상태로 갈 수 있게 하는 것을 V(s)가 수행해준다. → 그렇게 함으로써 기다리던 녀석 중 하나가 깨어나면 다시 시도해서 complete한다. decrement하게 되면 T2가 들어가게 된다.","장점 : 화장실 들어갔다가 나올 때 언제 나올지 모르기 때문에 sleep","현재 Thread 2,3번 모두 sleep된 상태 → 2,3중 하나 : 한 녀석을 깨워준다","형평성 있게 경쟁 다 같이 하게 해놓고, 순서가 자동으로 결정 -> ordering이 만들어짐"]},{"l":"C Semaphore Operations","p":["Pthreads functions:","semaphore integer variable에 1로 초기화","binary semaphore : cricital session에 1","atomic 한 operation = 그 명령을 수행하는 한 줄짜리 machine code가 있는가?","lock primitive :하나씩 제공해줌","user level에서 사용할 수 있게 pthread에선 sem_wait","→ 그래서 쪼갤 수 없는 것이다.","sem wait: test and set","variable s를 test하고 0보다 크고 작은지 확인, 0보다 크면 decrement (test → set)","이를 하나의 명령어로 만들어놈 / 그 명령어가 cpu architecture마다 다름","load, store, add 등 : 쪼갤 수 없는 instruction","Compare, swap : cpu designer 들이 lock primitive","→ pthread에서는 sem_wait 등으로 정의","CS : APP wrapper functions :"]},{"i":"badcntc--improper-synchronization-1","l":"badcnt.c : improper synchronization","p":["badcnt.c","How can we fix this using semaphores ?"]},{"l":"Using Semaphores for Mutual Exclusion","p":["Basic idea:","Associate a unique semaphore mutex, initially 1, with each shared variable (or related set of shared variables).","Surround corresponding critical sections with P(mutex) and V(mutex) operations.","Terminology:","Binary semaphore: semaphore whose value is always 0 or 1","Mutex: binary semaphore used for mutual exclusion","P operation: “locking” the mutex","V operation: “unlocking” or “releasing” the mutex","“Holding” a mutex: locked and not yet unlocked.","Counting semaphore: used as a counter for set of available resources. rsrc 집합에 대한 counter로 이용된 semaphore"]},{"i":"goodcntc-proper-synchronization","l":"goodcnt.c: Proper Synchronization","p":["(질문) cnt가 다른 thread에 의해 수정됨을 막기 위해 p(&mutex)로 다른 thread를 sleep시키고 cnt++ 수행 후 깨워주는 것이라고 이해했는데 맞나요?","(질문) for loop내 p가 block되고 나면 cnt++ 지나서 v까지 도달할 수 있나? v에서 이 thread를 깨워줘야 하는데, v까지 도달할 수 없지 않는가?","(질문) semaphore 방식을 이용해도 cnt변수는 volatile로 선언해야만 하나요?","(질문) semaphore 변수도 여러 thread가 접근가능한데, 여기서 문제 생기지 않는 이유는 P, V 함수들이 atomic하기 때문인가?","(질문) thread 여러 개를 깨울 때 이 순서가 암묵적으로 정해져 있나? 완전 랜덤인가?","(질문) 코드상 volatile로 선언안하면 memory가 아니라 반드시 cache에서 가져와서 문제가 되는것인가?","→ 무작위적으로 들어가고 지금은 순서를 정해 들어감","= 직렬화 됨 -> 느림","c code를 단순히 변환해주는 것만이 아닌","cacheing되지 않도록, memory에 직접 쓸 수 있도록","cnt 접근할 때 memory r/w 보장해줌","cnt++ 했는데 cache에 있을 수 있으니까 cacheing방지용으로 volatile 선언","correctness에 문제 생길 수 있음 : unexpected 문제를 막기 위해","correctness에서 문제가 생길수도 있음","Define and initialize a mutex for the shared variable cnt:","lock을 건다 = 순서대로 들어간다, 순서가 부여","optimization이 들어가서, code 최적화를 통해 code를 빠르게 하나","P, V에 의해 만들어진 forbidden region : multiple thread가 포함된 critical section의 Instruction을 항상 실행할 수 없게 해 준다 = semaphore 연산은 critcal section으로 mutual exclusive approach를 보장해준다.","p부터 resume해서 진행됨","question","sem_t : unsigned integer","Surround critical section with P and V:","thread routine에서 P, V연산으로 shared variable cnt를 둘러싸 renew 보호","volatile 같은 것도 선언하여 항상 memomry에서 읽고 쓸 수 있게. 항상 결과값을 memory에 저장해두고 진행하는 것이 volatile의 역할","Volatile 선언 → memory 변수 cnt","volatile 선언 안하게 되면 →","volatile로 선언","Warning: It’s orders of magnitude slower than badcnt.c.","다 깨워놓고 그 중 경쟁에서 이긴 thread가 그 다음순서가 됨","동시에 실행할 수 있으면 빠름 - 동시에 실행하되 critical session 부분은 순서에 따라 들어가야 함","맞다. volatile로 안 선언하면 memory가 아니라 cache에서 가져와서 문제생김","맞다. 막아주고 lock을 가지고 들어갔기 때문에 다른 thread는 들어오지 못함.","맞다. 한 thread가 decrement increment하는 일 자체가 atomic하기 때문에 맞다.","어떤 compiler는 code opt 중 every step memory r/w하는 것이 아닌 Register 값으로 Code optimization해줄 수 가 있음","직렬화되어 있음 : 하나만 들어가고, badcnt 는 마구잡이로 critical session에 들어감","하나만 들어갈 수 있도록"]},{"l":"Why Mutexes Work","p":["s<0 : unsafe region을 둘러싼 Forbidden region 정의 - 모든 가능한 궤적이 unsafe region과 닿음을 방지","s<0 : unsafe region을 둘러싼 Forbidden region 정의","모든 가능한 궤적이 unsafe region과 닿음을 방지","P, V의 조합이 forbidden region이라 불리는 state set을 생성한다 : s<0","semaphore invariant으로 인해 forbidden region state를 포함하는 궤적이 존재하지 않음+ forbidden region이 완전히 unsafe region을 감싸므로 모든 가능한 궤적들은 위험 영역의 모든 부분을 지날 수 없다.","→ 모든 trajectory는 safe + Runtime instruction order와 무관하게 정확하게 Counter 증가","Provide mutually exclusive access to shared variable by surrounding critical section with P and V operations on semaphore s (initially set to 1)","Semaphore invariant creates a forbidden region that encloses unsafe region and that cannot be entered by any trajectory.","forbidden region으로도 들어가지 않는다."]},{"l":"Summary","p":["Programmers need a clear model of how variables are shared by threads.","Variables shared by multiple threads must be protected to ensure mutually exclusive access.","Semaphores are a fundamental mechanism for enforcing mutual exclusion."]}],[{"i":"8-synchronization-advanced","l":"8. Synchronization: Advanced"},{"l":"Review"},{"l":"Semaphore","p":["non-negative global integer synchronization variable. : int s; (\\geq0)","Manipulated by P and V operations. : semaphore variable을 바꿀 수 있는 방법 p, s 를 통해 manipulate","manipulate : int var 를 증가, 감소시킴 (+복잡)","Binary semaphore vs Counting semaphore","initialize as 1(binary) 5, 10","semaphore의 초기 value는 critical session에 들어갈 수 있는 thread 개수","critical session에는 딱 하나 thread 밖에 못 들어감","Counting semaphore는 그 값을 5로 초기화해두었다면 5개 cricial session에 들어갈 수있음","critical session에 들어가고 나서 : P를 통해 들어갈지 안들어갈지 보고,","내가 들어갔다","= Semaphore val = 1","critical session에서 작업하고 나올 때 누군가가 내가 아직 critical session에서 있을 때 들어오려고 하면 P에서 blocked ( semaphore val = 0) =","\\rightarrow blocked, suspended","내가 나올 때 unlock","→ V fn 호출한다."]},{"i":"ps","l":"P(s)","p":["(binary semaphore기억하고 설명) Semaphore가 1로 initialize -> 두 thread가 P/V","**s \\neq 0: 0이 아니면 → 1을 빼고 나서 끝난다**","→ blocked 된 상태로 남아있고 그 semaphore에 나는 wait하고 있다며 매달려 있음","→ 깨어나게 되면, s라는 variable을 decrement하고 진행됨","→ 즉 0보다 크거나 같은 값을 계속 체크하지 않고 suspended되어 있다가 signal오면 깨어나는 형태","= CPU Cycle을 소모하지 않는다.","After restarting, the P operation decrements s and returns control to the caller.","critical session을 앞 뒤로 쌓아서 lock을 가져다 lock을 얻으면 들어가고 얻지 못하면 기다림","If s is nonzero, then decrement s by 1 and return immediately.","If s is zero, then suspend thread until s becomes nonzero and the thread is restarted by a V operation.","Process state transition diagram에서 보면 run 상태에서 block상태로","s \\neq 0","s=0","s=0: 본인이 suspend된다","semaphore s 를 Decrement한다","sleep하고 누군가가 깨워줄 때까지 suspend된다.","s라는 variable이 0인지 아닌지 봄","Test and decrement operations occur atomically(indivisibly)","until 0보다 큰 값이 될 때 : var x를 0보다 크게 만든 다음 깨워줄 때까지 기다림 (signal 받을 때까지)","그 값이 0보다 크면 decrement,","나올 땐 lock을 풀어주는 구조","내가 이 var보고나서 이 함수 안에서 여러 thread중 누군가가 decrement했다는 것→ 나는 그 값이 0보다 큰 값이 될 때까지 기다릴 것이다 (suspend, sleep)","만약에 들어가려 했는데 semaphore 값을 봤는데 0이다","이 P 라는 것은 semaphore value를 가져다 확인하고, 그 값이 0이 아니라면 decrement","정리","최초로 1로 되있을 때 들어간다고 하면 decrement하여 0으로 만들고, 그리고 critical session으로 들어감"]},{"i":"vs","l":"V(s):","p":["‘Atomically’","→ 그 thread가 decrement할수 있게 해줌","→ 그리고 나서 만일 s variable을 기다리고 있던 suspend thread가 있다면 그 중 한명을 깨워주고","→ 깨어나 ready 상태로 가 scheduler에 의해 행사되어 critical session으로 들어감","→ 여러 thread가 다같이 깨어남 : thundering herd","→ 여러 thread중 누군가 하나를 wake시켜서 decrement할 수 있게끔 한다.","→ 여러 개의 thread가 하나의 Semaphore를 가지고 있을 때 어떤 것이 V의 결과로 재시작되는지는 예측 불가능","→ 이 semaphore value의 기다리고 있떤 blocked된 thread를 깨워 줌","= p라는 함수는 실행이 되거나, 안 되거나 둘 중 하나이다.","atomic하게 increment시키고 누군가가 s라는 variable을 decrement하지 못해서 pending되어있는 경우 (suspended된 경우),","block되어 기다리던 thread를 깨워 줌","If there are any threads blocked in a P operation waiting for s to become non- zero, then restart exactly one of those threads, which then completes its P operation by decrementing s.","Increment operation occurs atomically :","Increment s by 1","indivisibly - 쪼개질 수 없는 함수이다.","P,V는 atomically 수행된다","Semaphore invariant: (s >= 0)","semaphorevalue s 를 increment","Semaphore를 중단 없이 load, 증가, 저장하기 때문","s라는 variable을 increment해줌","S를 increment하고, 이 semaphore value에 기다리고 있던 blocked 된 thread를 깨워줌","test와 감소 연산은 semaphore s가 0이 아니면 s의 감소가 중단 없이 일어난다는 의미에서 개별적으로 일어남. V에서도 증가연산 개별적.","V 의 정의 : 기다리고 있는 thread들이 재시작되는 순서를 정의하지 않는다.","variable이 뭔지 test하고 이 variable을 어떤 값으로 setting해줌 (decrement)","v또한 Atomically increment해주기 때문에 변수를 하나 증가해줌","요구하는 유일한 사항은 V 가 정확히 한 개의 waiting thread를 restart","정리하면,"]},{"l":"Using semaphores to protect shared resources via mutual exclusion","p":["여러 thread가 해당 코드를 구동한다고 생각했을 때","Mutex 값은 초기에 1 → 0으로 바꾸어 주고 thread 1번 : block → waiting(blocked, suspended 상태)","critical session에서 나와 mutex 에서 thread 2번이 기다리고 있고 이를 깨워준다.","다시한번 mutex를 잡으려고 한다","→ 잡혀 critical session으로 들어간다","Basic idea:","Associate a unique semaphore mutex, initially 1, with each shared variable (or related set of shared variables)","Surround each access to the shared variable(s) with P(mutex) and V(mutex) operations"]},{"l":"Using Semaphores to Coordinate Access to Shared Resources","p":["shared resources = data structure coordinate tech : semaphore","Basic idea: Thread uses a semaphore operation to notify another thread that some condition has become true","Use counting semaphores to keep track of resource state and to notify other threads","Use mutex to protect access to resource","Two classic examples:","The Producer-Consumer Problem","The Readers-Writers Problem"]},{"l":"Producer-Consumer Problem","p":["Untitled"]},{"i":"producer-consumer-problem-","l":"producer-consumer problem :","p":["생산자와 소비자 (여러 명의 생산자) (여러 명의 소비자) - front와 rear가 만나면 empty buffer","classical한, 상당히 잘 사용되는 concurrency example.","생산자 : 무언가 item을 생산하고 있음 (Insert)","item store @ Shared buffer (multiple slot)","생산자는 slot에다가 앞에서부터 하나씩 차곡차곡 쌓는다.","내가 어디까지 쌓았는지 확인하기 위해 circulared buffer : front/rear","front는 아직 소비하지 않았기 때문에 맨 처음","소비자. 무언가 item을 소비하고 있음 (Remove)","remove하게 되면 front 뒤로 이동(상황 가정) 3명의 consumer가 있고 buffer가 empty되어 있다고 하자.","소비자는 살 수 있는 item이 있는가?-> empty buffer이기 때문에 없다.","소비자는 item이 없으면 sleep하면 된다 (blocked되면 된다)","생산자 입장에서는 소비자가 소비 못하는 바람에 buffer가 없어 더 생산 불가능-> 생산자는 그 때 sleep을 한다. 이런 특성을 가진 구조 semaphore :","내가 cs에 들어갈 수 있을 때"]},{"l":"Concepts","p":["big data system에서 backend에서 개발할 수 있는 중요한 technique","buffer :개별 Frame에서 data와 관련한 encoding, decoding 시간 차이로 발생한 video stream noise 제거 → producer에 slot 저장소 제공, consumer에게 encoded frame 저장소 제공","coding algorithm에 따라 나오는 data","Common synchronization pattern:","consumer : item 있는지 보고 있으면 buffer에서 remove하고 producer에게 알려서 새로 생산해도 된다고 하여 produce","Consumer retrieves events from buffer and paints the display","Consumer thread가 렌더링","Consumer waits for item, removes it from buffer, and notifies producer","empty slot이 있다 → 생산자는 생산하면 되고","Event-driven graphical user interfaces","Examples","item이 buffer에 있다면 -> 소비하면 되고","item이 없다면 -> producer가 produce할때까지 sleep","Multimedia processing:","Producer creates MPEG video frames, consumer renders them","Producer detects mouse clicks, mouse movements, and keyboard hits and inserts corresponding events in buffer 5 Shared buffer","Producer waits for empty slot, inserts item in buffer, and notifies consumer","producer는 buffer에 item을 넣고, semaphore 기다리는 consumer가 있다면 알려줌","producer는 empty slot을 block된 상태로 기다림 (buffer 에 item insert위해서)","semaphore의 또 다른 용도 : mutual exclusion 제공 + shared resource로의 접근 scheduling","thread : semaphore 연산을 이용하여 program state의 조건이 true가 됐음을 다른 Thread에 알림","마우스, 키보드 클릭 등 event를 받아 event buffer에 마구 집어넣는 producer-> 화면에다 display해줌","분배 : mpeg frame 생성 / consumer 렌더링 (분배)"]},{"l":"Producer-Consumer on an n-element Buffer","p":["ex. n=8이라고 하면 slot semaphore는 8로 초기화되어 8개까지는 동시에 CS에 들어가서 produce할 수 있다.","if empty buffer → consumer 는 item available 할 때까지 대기","if full buffer → producer 는 slot available 할 때까지 대기","Implemented using a shared buffer package called S_{BUF}.","item : buffer 안 item의 개수","items: counts the available items in the buffer","item을 추가하고 제거하는 것이 shared variable의 renew와 관련되어 있으므로 buffer에 접근할 때 mutex 보장 + buffer로의 접근 scheduling","limited buffer 조작","mutex : binary semaphore :0, 1","mutex semaphore : mutex buffer approach 제공","mutex: enforces mutually exclusive access to the the buffer","mutually exclusive 오로지 하나 thread만 들어가도록","Requires a mutex and two counting semaphores (slot/item):","sbuf라는 shared buffer","semaphore slot, item : counting semaphore - empty slot의 수, available item 수 확인","slot : n개의 buffer라고 할 때","slot, items : counting semaphore","slots: counts the available slots in the buffer","처음에는 empty였으니까 0으로 initialize","초기화 값에 따라 그만큼 들어갈 수 있음."]},{"l":"sbuf Package"},{"l":"Declarations"},{"l":"Implementation","p":["! (Semaphore 초기값) \\neq(critical session에 들어가는 thread의 개수)","→ decrement : n=7","0으로 초기화 = 0개만큼 들어간다는 이야기는 incorrect","0이 아니면 decrement하여 들어감","8개가 다 들어가 있다 = slot 이 없다","available slot을 기다리고, Mutex lock","binary semaphore : 1개 thread만","buffer를 위한 Heap memory 할당","consumer: consume하기 전에 item에 해당하는 semaphore value를 봄","counting semaphore : Buffer에 있는 element 개수만큼 생산할수 있기 때문에","ex. N=8","Front - rear가 empty heap을 가리키도록 설정","front에서 item을 하나 씩 빼내면 ptr을 옮기고 직렬화가 됨→ mutex semaphore를 잡아 한 녀석 한 번에 처리할 수 있도록→ item을 뺐으니 slot이 생산","Insert 여러가지 thread가 떠서 insert를 하고 있기 때문에, 그 안에는 slot이 0이 될 때까지 mutex로 잡아 둠 = item을 잡아둘 때 rear ptr를 여러 thread가 움직이면 안됨","Insert할 때 (thread들어갈 때) slot의 개수를 본다","item : buffer front에서 remove","Item insertion 후에 Mutex unlock한 후 new itemd이 available함을 알림","item 기다린 후 mutex lock","Item은 있으면 thread에 넣는다.","item을 가지고 들어가고, 나올 때는 slot을 봄","item이 0이 아니면 consume은 여러개가 같이 할 수 있음","item이 생산되었으니 increment → 1 또는 2, 3, 4","mutex unlock후 available slot임을 알림 Untitled","P(slot) / P(mutex) / CS / V(mutex) / V(item) → item을 통해 reader(consumer)중 p(item)","producer도 하나씩 순차적으로 수행해야 함,","remove","sbuf_deinit","sbuf_init","sbuf_insert","sbuf_remove","Writer (producer) - reader (consumer)","사용 마친 후 buffer space 반환","세 함수로 호출하기 전 한 번 호출","언제 block되냐 : 값이 0이 되어있을 때","직렬화를 위해 mutex lock을 가지고 하나만 실행할 수 있도록.","초기값을 semaphore에 할당"]},{"l":"Readers-Writers Problem","p":["Readers- Writers Problem","database = record 관리 : index를 tree로 관리","자료구조를 update할수도 reference할수도 있음","database안에서는 이 문제를 해결하기 위한 solution으로 semaphore / mutex"]},{"i":"concepts-1","l":"Concepts","p":["“누군가가 쓰고 있다”","“누군가가 읽고 있다” - 쓰려는 애들은 기다려야 하지만 읽고자 하는 obj는 읽게 해줌","cache에 새 페이지를 쓰는 모든 Thread에 배타적 접근","concurrent thread의 set : shared object에 approach","ex. main memory data structure, disk database","Generalization of the mutual exclusion problem","Multithreaded caching Web proxy","Occurs frequently in real systems, e.g.,","Online airline reservation system","Problem statement:","Reader threads only read the object / Writer threads modify the object","Unlimited number of readers can access the object","Writers must have exclusive access to the object - but reader는 이 object를 무수히 다른 reader과 공유해야 할 수 있음","고객 : 좌석 할당 시스템을 동시에 조사 가능","누군가 read : 다른 read가능 (누군가가 수정하고 있는 상태가 아니기 때문에)","누군가 read하고 있으면 해당 object를 write하면 안 되고 기다림","누군가 write하고 있으면 read는 대기중","무제한 Thread : 기존 page를 공유 page cache에서 가져올 수 있음","어떤 object가 있는데 이 object가 read/write 가능함","예약 : Database에 배타적 접근"]},{"l":"Variants of Readers-Writers","p":["A reader that arrives after a waiting writer gets priority over the writer reader는 단지 writer가 기다리고 있다고 해서 기다려서는 안 된다.","A reader that arrives after a writer must wait, even if the writer is also waiting 비록 writer가 기다리고 있을지라도 기다려야 함.","Favor for reader","Favor for Writer","First readers-writers problem (favors readers)","No reader should be kept waiting unless a writer has already been granted permission to use the object 어떠한 reader도 writer가 이미 이 객체르 이용하도록 허가하지 않았으면 계속 기다려서는 안된다","Once a writer is ready to write, it performs its write as soon as possible writer를 쓸 준비가 되었다면 가능한 한 빨리 write작업 수행할 것 요구","Or, writer가 들어가서 나오지 않으면 reader는 starvation","Second readers-writers problem (favors writers)","Starvation (where a thread waits indefinitely) is possible in both cases","w1 : starvation (Ri는 계속해서 read 가능하고, 그 중 절대 들어가지 못함)","w1을 bypass하고 r2가 읽을 수 있도록 하고, r3…가 와도 읽을 수 있도록 한다.→ write가 먼저 왔음에도 불구하고 현재 read를 하고 있으면 동일한 object에 대한 read는 계속 가능케 해 준다.","Write가 왔다 = write를 빠르게 처리해야 하기 때문에 뒤에 있는 녀석들을 처리하지 않는다→ writer가 끝난 다음에 reader를 처리한다 (최대한 빠르게 writer를 처리한다)→ write에게 favor준다 하더라도 reader가 들어가서 안나오면 starvation","사실 누구에게나 starvation이 발생하고 해결할 수 있는 solution이 아님","어떤 object가 있다고 할 때 R1이 읽고 있다고 가정하자→ W1이 오면, W1는 wait하여야 한다 : 누군가가 read하고 있기 때문에→ R2가 오면 : R2는 wait없이 읽어도 된다. (Read에 favor)","영원히 정지하고 진행하지 못하게 되는 thread"]},{"l":"Solution to First Readers-Writers Problem","p":["starvation에 대한 solution을 제공하지 않음","reader가 어느정도 이상이 되면 막는 coding : reader가 무한대로 들어오면 안 됨","Starvation을 막기 위한 코드는 어떻게 구현하여야 하는가","→ 일정 threshold 까지 들어가게 되면 writer가 한 번 정도 들어가도록 수정","**w semaphore: shared obj 접근하는 critical section으로의 접근 제어**","**mutex semaphore: shared readcnt var로의 접근 보호**","현재 critical section에 있는 reader수 count","**writer: w mutex critical section에 들어갈 때마다 lock, 떠나면 unlock**","→ critical section에 최대 하나의 Writer만 존재하도록 보장","critical section에 처음으로 들어가는 reader만 w lock, critical section을 가장 마지막으로 떠나는 reader만이 이를 unlock하여 풀어준다 : 한 개의 reader가 W mutex를 가지고 있는 한 무수한 Reader가 critical section에 아무 방해 없이 들어갈 수 있음을 의미","w가 1인 것은 : Reader, writer 둘 중 하나만 들어가야 함 대신 reader가 들어가면 여러개가 들어갈 수 있음","if condition이 없으면 Reader 들어가거나 writer들어가거나→ 약간 extension하면 reader에게 favor→ reader가 계속 들어갈 수 있어서, 조건문을 통해 read가 한 번 들어가 있다고 하면 그제서야 semaphore가지고 들어가고 Readcnt가 1보다 크게 되면 semaphore를 하지 않음","(질문) packet loss 발생 시 문제?-> 문제 안됨","socket 통신 : socket열어서 send receive information API 밑단 TCP IP Kernel에서 보정해줌","packet loss 가 생기더라도 tcp쓴다고 하면 kernel의 tcp ip stack에서 protocol이 다 보정함-> 잃어버리게 되면 다시 data 달라고 하여 줌"]},{"l":"Prethread"},{"i":"putting-it-all-together-prethreaded-concurrent-server","l":"Putting It All Together: Prethreaded Concurrent Server","p":["Untitled","server : main thread - multiple work thread","main thread : 반복해서 client accept request → 연결 식별자를 buffer에 저장","work thread : 반복해서 remove descriptors, client service 이후 descriptor 기다림","Thread pooling : thread를 만들어 놓고, 필요한 thread만 wake하여 사용하는 방식","Thread를 미리 만들어 놓고 안 쓰는 thread는 sleep","지금까지는 connfd나오면 thread spawn한 다음 해당 thread가 connfd와 client끼리 connect하여 channel 로 echoing - 여기서는 Pool of worker thread","Shared buffer : master thread가 accept할 때마다 connect descriptor","master thread가 accept할 때마다 connected descriptor를 하나 씩 채워줌 (P=S model)"]},{"l":"Prethreaded Concurrent Server Configuration","p":["Prethreaded concurrent echo server : sbuf로 구현","thread란 함수는 뒤에서 main thread가 joinable할 필요 없으면 Pthread_Detach","자기는 joinable하고 While에 들어가 Buffer produce에서 Connfd를 하나씩 뺀다","worker thread 하나씩 빼고 connfd를 주되, buffer에다 집어넣었으니까 하나씩 빼내어감","sbuf remove, sbuf insert : 앞의 함수를 사용하면 됨","Sem_init(&mutex, 0, 1);","mutex 초기화 하고 byte count - 총 echoing한 byte count 보내는 코드","여러 thread가 echoing했으니까 내가 echo할 때마다 몇 byte echoing했는지 shared variable로 global하게 잡아서 byte count에 increment"]},{"i":"crucial-concept-thread-safety","l":"Crucial concept: Thread Safety","p":["Class 1: Functions that do not protect shared variables→lock variable","Class 2: Functions that keep state across multiple invocations→ rand var","Class 3: Functions that return a pointer to a static variable→ thread safe하게 바꾸는 기술 알려줄 것 : lock n copy","Class 4: Functions that call thread-unsafe functions","Classes of thread-unsafe functions:","correct한 것이란: 추상적 개념으로 thread safe : 내가 expect한 결과대로 나오면 safe한데 expected 결과로 나오지 않는다면 unsafe","expected : thread-safe : Thread가 그 함수를 호출했을 때 thread-safe하다.","Functions called from a thread must be thread-safe: A function is thread-safe thread에서 호출된 함수가 thread safe하다****\\iff it will always produce correct results when called repeatedly from multiple concurrent threads 여러 thread가 concurrently 호출하고, 각 thread들이 excution flow에 따라 항상 correct한 결과가 나온다.","system call을 변환한 것들이 있는데 개발자로서 ctime과 비슷한 함수를 만들었다고 하면 thread safe한지, thread unsafe한지 확인","thread safe하게 바꾼 것이 rand_r, ctime_r이라던지 thread safe하게 만들었다.","thread safe하다의 의미가 무엇인지 개념적으로 배워보자.","thread unsafe하면 multi threading할 때 문제가 생길 수 있음을 인지하기 시작했으므로 ex. 격투기에 쓰이는 여러 가지 기술처럼 프로그래밍도 처음부터 짜는 것이 아닌, 자신만의 기술을 가지고 있어야 함 - 간헐적으로 발생하여 debug하기가 굉장히 어렵다.","Thread-Safe하지 않는 function의 특징 네가지(case를 이해하면 쓰기 어렵지 않음)","그러나 unix programming하면은 thread-unsafe한 함수를 쓴다.","기억해야 하는 이유 : 정보처리기사 자격증에서 외워 쓰는 것이 아니라, 실제 프로그래밍할 때 이런 규칙들이 있다 보니 신경써야 한다. 개발자가 할 부분이고, 그럼에도 실수하기 때문이다. bug free한 프로그램(질문) 내가 한 번 호출하면 1이고 100이고 200이고. seed값이 변하지 않으면 정해진 sequence에 대하여 random : seed값이 바뀌지 않으면 항상 같은 결과값이 나온다. rnadom한 pattern이 동일하게 나옴을 보장할 수 없다. → seed를 누군가가 바꿀수도 있는데 이를 못 바꾸게 해 달라는 것. 동일하게 생성되어야 하는데 그렇지 않은 경우","대부분 여러 system call은 thread safe하게 구현되어 있으니 thread unsafe한 함수가 이렇게 존재한다.","모든 함수가 safe하지도 unsafe하지도 않다.","옛날 multiprocessing하려고 할 때 single processor, serialized된 상태였다.","옛날의 함수를 지금 사용하려고 하니까 오류","요즘과 같은 multi processor 시대에서는 thread unsafe하네 라는 문제들이 왕왕 생기게 되어 thread safe된 함수를 쓰라고 되어 있다."]},{"i":"thread-unsafe-functions-class-1","l":"Thread-Unsafe Functions (Class 1)","p":["Failing to protect shared variables","Fix: Use P and V semaphore operations","Example: goodcnt.c","Issue: Synchronization operations will slow down code","goodcnt : shared var이 있는데 count하는 var이고 초기화가 0으로 되어 있고 0으로 된 이 thread var을 increment","한 번씩 increment했으니까 2가 되어야 함 (expected, thread safe)","count increment하는 함수가 thread safe하지 않다 (thread unsafe)","binary semaphore하여 mutex lock을 걸어 앞 뒤를 보호했다.","thread safe한 함수를 만들게 되면, 여러 thread가 increment할 때 cnt++ 하는 과정이","세 가지 instruction으로 구성되어 있는데 중간에 interleaving되는 경우가 나오지 않아 thread safe하여 항상 2가 나온다.","mutex lock 사용: thread safe","mutex lock 비사용: thread unsafe"]},{"i":"thread-unsafe-functions-class-2","l":"Thread-Unsafe Functions (Class 2)","p":["Relying on persistent state across multiple function invocations","Example: Random number generator that relies on static state","매번 random함수를 호출하는데 state를 계속 keep해야 한다.","Global var을 적게 사용하고 Call by ref로 들어가면 다른 thread에 unavailable","→ 없애는 방법을 서라. global variable을 최대한 피해라.","next를 static하게 공유하게 해 놓는다.","→ deterministic하게 시작한 처음의 seed가 1이니까 순서대로 나온다. (매 invocation마다 state를 keep하는 형태로 구현)","seed를 바꾸는 srand함수","문제가 되는 이유: 임의의 번호 1 3 5 7 9 생산한다고 가정","seed가 1부터 시작, 2씩 더하여 리턴하는 함수 srand","내가 state를 가지고 있으니 다음, 다음 다음, 넘어간다. thread가 중간에 들어가 next를 갑자기 3에서 3000으로 바꾸어 버리면 Rand를 다시 시행한다 하더라도 그 sequence를 다시 생성할 수 없다.","correct하지 않다. / thread safe하지 않다.","왜 이렇게 프로그램을 짰는가? 모든 것을 thread safe하게 만들면 되는게 아닌가? 의문"]},{"l":"Thread-Safe Random Number Generator","p":["Rand에서는 parameter로 void로 넘어갔지만","nextp pointer : 내 seed와 공유되는 변수가 아닌 것","Rand_r caller에서 선언한 local var의 ptr를 넘겨주기 때문에 자신 seed가지고 increment","→ thread unsafe한 것을 safe하게 바꾸어 줄 수 있다.","→ arg 의 일부로 state를 넘겨라","Pass state as part of argument / arg 의 일부로 state를 넘겨라","and, thereby, eliminate global state","next는 thread들이 모두 호출할 수 있다.","여러 thread들이 각자 공유하고 있기 때문에 생기는 문제","→ global state가 발생하지 않도록 만드는 방법","Consequence:programmer using rand_r must maintain seed"]},{"i":"thread-unsafe-functions-class-3","l":"Thread-Unsafe Functions (Class 3)","p":["(ctime 자체가 기지고 있는 문제) 시간이 흘르며 s1→e1 도중 s2→e2에서 time이 들어간다.","→ 내가 호출한 시점이 아닌 다음 시점에 ctime으로 내용이 바뀔 수 있다. 나는 모르고 interrupted 된 시간으로 return받을 수 있다.","ctime : 현재의 시간을 가져다 return해주는 function (from time_t struct)","ctime을 수행하고 읽어오는 사이에 우연치 않게 interrupt 걸려 switch된다면","Fix 1. Rewrite function so caller passes address of variable to store result","Fix 2. Lock-and-copy lock을 잡고 copy해라","fix1 : ctime을 다 뜯어 고칠수 있다","fix2 : ctime을 그대로 쓰되 mutex lock : ctime_ts를 부르는 caller가 있으니가, 해당 caller는 call by reference를 그대로 받을 수 있다.","global variable로 되어 있는데 이를 읽어 오는 것 (by system call)","However, caller must free memory.","lock and copy","lock을 잡고 return되면 copy하여 줌 : lock을 잡았기 때문에 이를 풀어야지 들어갈 수 있음","private으로 받되, caller의 ptr로 받는다면 자기 것으로 받는다","ptr를 받은 후 strcpy하는데 caller의 변수 stack에 있는 var의 address를 넘겨주니까 이를 dereference하며 lock and copy를 수행함","Requires changes in caller and callee","Requires simple changes in caller (and none in callee)","Returning a pointer to a static variable","함수 자체가 문제 있음 → lock : breakable하지 않게, atomic하게 잡아 중간에 누군가가 interleaving하여 들어오지 않게 함."]},{"i":"thread-unsafe-functions-class-4","l":"Thread-Unsafe Functions (Class 4)","p":["Calling thread-unsafe functions","Calling one thread-unsafe function makes the entire function that calls it thread-unsafe","Fix: Modify the function so it calls only thread-safe functions"]},{"l":"Reentrant Functions","p":["Def: A function is reentrant\\iff it accesses no shared variables when called by multiple threads.","지금 봤던 것은 : function들은 unsafe하냐, safe하냐로 나누어짐","thread safe 중 어떤 것들은 reentrant :","thread가 호출했을 때 shared variable을 Thread가 같이 접근하지만 safe하지 않을 때 safe하게 만들기: 피해나가는 방법.","그 shared variable이 없는 것<책에서 없는 내용>","safe, not reentrant, safe, reentrant","unsafe를 safe하게는 만들어주는 능력은 필요하다.","(unsafe, reentrant)는 큰 의미는 없다.","Important subset of thread-safe functions","Require no synchronization operations","Only way to make a Class 2 function thread-safe is to make it reetnrant (e.g., rand_r)","Untitled"]},{"l":"Thread-Safe Library Functions","p":["All functions in the Standard C Library (at the back of your K&R text) are thread-safe","Examples: malloc, free, printf, scanf","printf는 thread-safe하긴 하다 (여러 thread 동시접근시) / but not async-signal-safe→ NOT reentrant","Most Unix system calls are thread-safe, with a few exceptions: Untitled"]},{"i":"one-worry-races","l":"One worry: Races","p":["A race occurs when correctness of the program depends on one thread reaching point x before another thread reaches point y","thread라는 fn 실행하여 call by reference로 해서 들어와서, I는 main thread의 local variable","-> 주소값을 넘김","→ 새로 생성된 thread는 그 주소값을 myid라는 local variable을 stack에 copy하고 print해줌","If) n=2→ iteration은 2번돈다."]},{"l":"Race Illustration","p":["i라는 것을 dereference하여 print하려고 프로그램을 작성했는데 myid가 1이 나올수도 있다","→ myid가 0인줄 알고 실행했는데 i=1로 증가시키면 그 주소값을 보고 있기 때문에 0이 아닌 1이 print된다","이런 상황이 존재하면 thread간 race가 있다.","잘못된 상황이 발생하면","Untitled","between increment of i in main thread - dereference of vargp in peer thread","If dereference happens while i = 0, then OK","Otherwise, peer thread gets wrong id value"]},{"i":"could-this-race-really-occur","l":"Could this race really occur?","p":["Race Test","If no race, then each thread would get different value of i","Set of saved values would consist of one copy each of 0 through 99"]},{"l":"Experimental Results","p":["Untitled thread for iteration하여 100번 실행 → ideally, 0~ 99번까지 원래는 한 번씩 찍히는 게 맞다. 그러나 race가 있기 때문에","single cpu laptop에서 구동시켰더니","1, 8, 16, 42가 두 번 찍힌다 = 한 번도 찍히지 않은 것들이 생긴다","cpu에 hyper threading까지 되어 virtual cpu 8개 까지 수행됨 (3)","안찍히는 게 너무 많다.","single cpu에서 multi cpu server로 시켰더니 cpu 개수가 많이자게 되면,control","multicore cpu.arcitecture을 설계하게 되면 나중에"]},{"l":"Race Elimination","p":["Avoid unintended sharing of s tate","원래는 main 함수에다가 heap variable을 잡아 두고 thread를 가져다 각각의 ptr를 넘겨준다","각각에 대해서, heap variable을 보고 print하기 때문에 항상 한 번씩만 찍히게 된다.","i를 가지고 넘기게 되면 iteration이 빨리 돌아올 수 있기 때문에","heap var : 각 thread가 각자 들어가기 때문에 문제 해결 가능."]},{"i":"another-worry-deadlock","l":"Another worry: Deadlock","p":["Def: A process is deadlocked\\iff it is waiting for a condition that will never be true","서로서로 기다리는 상태에서 전진하지 못하고 hanging하는 상태","Typical Scenario","Processes 1 and 2 needs two resources (A and B) to proceed / thread 1, 2번이 있는데 Process 1 acquires A, waits for B / t1은 a라는 자원을 가진 후 b라는 자원을 가져야 진행할 수 있다. Process 2 acquires B, waits for A / t2은 b라는 자원을 가진 후 a라는 자원을 가져야 진행할 수 있다. 공교롭게도 a,b를 각각 잡은 상태에서 t1은 b를 기다리고 t2는 a를 기다린다.","Both will wait forever!","둘다 rsrc를 획득하려고 하는데 서로의 rsrc를 기다리고 있는 이런 상태라고 보면 된다.","두 thread가 hanging하여 진행하지 못함."]},{"l":"Deadlocking With Semaphores","p":["concurrent programming 기술 중 하나","mutex한거 같은데 왜 hanging하고 있지 할 때 solution","Deadlock 해결 → 같은 ordering을 주게 되면 deadlock을 해결할 수 있음","t1 : a -> b / t2 : b -> a 에서 a->b","같은 순서로 획득할 수 있게 하면 deadlock을 회피할 수 있다"]},{"l":"Deadlock Visualized in Progress Graph","p":["Untitled","Locking introduces the potential for deadlock: waiting for a condition that will never be true","Any trajectory that enters the deadlock region will eventually reach the deadlock state, waiting for either s0 or s1 to become nonzero","deadlock region : overlap되는 구간을 반드시 지나야 함","Other trajectories luck out and skirt the deadlock region","Unfortunate fact: deadlock is often nondeterministic (race)"]},{"l":"Avoiding Deadlock Acquire shared resources in same order"},{"l":"Avoided Deadlock in Progress Graph","p":["(여담) 김영재 교수님석사 시절,","critical software들은 정말 조심해서 test도 많이 하고 bug fix도 잘 해야한다.","deadlock은 항상 회피해야 하는데 발생할 수 있으므로 차량용 급발진 등 example이 나온다.","No way for trajectory to get stuck","Order in which locks released immaterial","overlap되는 부분을 들어가지 않으면 됨.","Processes acquire locks in same order","project 2 : Thread pooling을 해 보았다는 것 자체로도 자부심을 가져도 괜찮다","Race가 발생할 수 있으니까 조심해야 하고","thread가 여러개 돌아가는데 서로 msg 주고 받는 프로그램 → 정말 간헐적으로 생김","Untitled","그 개념을 알고있다는 것 자체로도 cs core에 도달해 있다. 어렵긴 하다.","내가 짠 sw위에 benchmark를 돌리는데, 어떤 complexity로 돌리느냐에 따라서 정말 잘 돌아가거나 천번에 한번 안 돌아가거나 등 코드가 복잡해지다 보니 나도 모르게 실수하기도 한다 (deadlock 등)","마구 달려들기 보단 thread safe-unsafe","순서를 바꾸어 수행하게 되면 → forbid region이 변화함","요즘 자동차들도 sw로 구현 :sw bug가 언제든지 나타날수 있다","죽지도 않고 그대로 멈춰 있어서 debug하기가 너무 힘들었다.","하다가 그냥 멈춘다 : 내가 benchmark 1시간 돌리다가"]}],[{"l":"9. Thread-Level Parallelism"},{"l":"Today","p":["Parallel Computing Hardware","Multicore","Multiple separate processors on single chip","Hyperthreading","Efficient execution of multiple threads on single core","Thread-Level Parallelism","Splitting program into independent tasks","Example: Parallel summation","Consistency Models","What happens when multiple threads are reading","writing shared state 2"]},{"l":"Exploiting parallel execution","p":["(기존) single.multi,manicore 신경 안쓰고 풀었음","→ load store, alu, fpu등 여러개가 있다 보니까 동시에 사용할 수 있게 해 줌으로서 pc 2개, register set 2개 있어 실제 function unit을 interleaving하며 동시에 사용할 수 있도록 함.","by organizing it as multiple parallel sub-tasks 3","Can also write code to make one big task go faster thread끼리 공유하는 자료구조 : parallel하게 완전히 실행되기는 어려운 면 존재","CPU안에 instruction 처리하는 unit (control) : register 동일한 것들을 두개를 복제해 놓고 실제 계산하는 ALU FPU, 이런 것들을 공유하는 방식","e.g., one thread per client to prevent one from delaying another -","e.g., running many applications or serving many clients","Happens automatically, if many independent tasks independent task를 가지고 있어 실행하게 함","hypertheading되건 안되건 cpu 여러개 환경 가정,","Hyperthreading cpu :","hyperthreading 안 되던 시절 : pc 1개, register set도 결국 여러 개 inst 공유하도록 되어있지 않아 불가능","Multi-core/Hyperthreaded CPUs offer another opportunity","multicore","single chip 안에 여러가지의 processor : cpu 여러 개","So far, we’ve used threads to deal with I/O delays","Spread work over threads executing in parallel","thread실행하게 되면 물리적으로 각각 mapping되어 실행 가능","물리적 cpu 8개인것과 완전히 같지는 않지만 유사한 기능","지금까지 봤던 것 : CS에 여러가지가 들어갈 수 없으니까 한 thread가 들어가 있을 때 다른 thread가 들어가지 못하게 하여 sync문제 해결","하이퍼스레딩 가능하다고 하면 multicore 4인게 hyperthreaded되어 8개처럼 보인다"]},{"l":"Typical Multicore Processor","p":["6.38.","cpu cache : processor 내 processor cache","CPU chip - (bus) - main memory","Private cahce : L1 cache, l2 cahce","자기만 접근할수 있는 cache","실제 data 접근할 때 register/l1/l2 cache 뒤져 데이터 접근","다른 core에서의 register/l1/l2 접근 불가","cpu 쪽에 가까워질수록 access latency가 짧음",": (1) register에서 가져오는 것이 제일 빠름 - (2) l1 cache - (3) l2 cache","L1 cache : instruction-data cache (computer architecture)","Shared cache : L3 cache","core들이 동시에 접근할 수 있음","main memory : DRAM - cache는 SM으로 만듬","storage hierarchy 의 이해를 해야 최적화된 코드를 작성할 수 있음."]},{"l":"Benchmark Machine","p":["Get data about machine from /proc/cpuinfo","Shark Machines","Intel Xeon E5520 @ 2.27 GHz","Nehalem, ca. 2010","8 Cores","Each can do 2x hyperthreading 5"]},{"i":"example-1-parallel-summation","l":"Example 1: Parallel Summation","p":["Sum numbers 0, ..., n-1","Should add up to ((n-1)* n)/2","Partition values 1, ..., n-1 into t ranges","\\frac n t values in each range","Each of t threads processes 1 range","For simplicity, assume n is a multiple of t","Let’s consider different ways that multiple threads might work on their assigned ranges in parallel","0 ~ n-1까지의 합을 구하는 간단한 프로그램","→ 병렬적으로 계산한다고 하면 0 ,1, 2, … n-1","T라는 range를 갖는 partition을 만들어보자 : t개의 element partition","partition당 개수 = 전체 개수 / partition개수","n의 값이 굉장히 크다면 Thread를 cpu 개수만큼 띄운 다음 일부 덧셈하고 각각을 aggregation하는 방법 취하기"]},{"i":"first-attempt-psum-mutex","l":"First attempt: psum-mutex","p":["Simplest approach:","Threads sum into a global variable protected by a semaphore mutex.","thread 개수를 nthread 개수만큼 띄운다."]},{"l":"psum-mutex Thread Routine","p":["Simplest approach: Threads sum into a global variable protected by a semaphore mutex.","여러 개 thread spawn한 다음","gsum이라는 global variable을 만들어 놓고 이를 주기적으로 update","→ 모든 thread들이 각각 얼마만큼 실행하면 매번 iteration 돌 때마다 gsum update","$0~ n-1$까지의 값을 가지게 될 것이다","mutex :","이렇게 코딩하면 여러 thread들이 동시에 접근하는 global variable이기 때문에 mutex를 걸어 두어 동시에 update하지 않도록 함","expensive하지만 cs 보호를 위해 잡아 둠"]},{"l":"psum-mutex Performance","p":["Shark machine with 8 cores, n=2^{31}","Nasty surprise:","Single thread is very slow","Gets slower as we use more cores 10","계속해서 slow down","single cpu 자체도 느림 : 혼자 돈다 하더라도 mutex lock을 계속 잡고 풀고 overhead","→ multicore또한 더 느림","→ 병렬 프로그래밍 어려움","Untitled"]},{"i":"next-attempt-psum-array","l":"Next Attempt: psum-array","p":["partial sum array 만들기","다 끝나면 처음부터 k개 element까지 더함","마지막에 array를 더하기하고","자기가 중간에 계산한 값을 gsum에서 sum하지 않고 각자 자신의 array 공간을 가지고 수행","앞서 사용했던 mutex가 불필요 : 각자 자기 변수의 작업을 하기 때문에 psum[myid] += i","앞에서 보여준 것처럼 thread끼리 compend하는 경우가 없을 것","Peer thread i sums into global array element psum[i]","Main waits for theads to finish, then sums elements of psum","Eliminates need for mutex synchronization"]},{"l":"psum-array Performance","p":["Orders of magnitude faster than psum-array","thread개수가 줄어들며 실행 시간이 쭉 쭉 줄어듦.","cpu mutex lock unlock할 때는 시간이 너무 많이 들었으나 1/5수준으로 성능이 향상됨 Untitled"]},{"i":"next-attempt-psum-local","l":"Next Attempt: psum-local","p":["Reduce memory references by having peer thread i sum into a local variable (register)","→ 개선 :","array를 gloabl var로 쓰는게 아닌, 각 thread가 자신의 local var을 가지고 중간값을 저장할 것→ compiler가 register에 있는 값으로 memory 값 update","memory가 아닌 실제 register에서 update되는 local variable","iteration을 돌며 중간값 sum (@register) → psum이라는 array에 최종 update","즉 본인 register에서 update하고 최종적으로 local psum에서 update(장점) Memory reference overhead 줄일 수 있음 (local var의 활용) memory lv까지 가지 않고"]},{"l":"psum-local Performance","p":["Significantly faster than psum-array","Untitled"]},{"l":"Characterizing Parallel Program Performance","p":["→ efficiency = 2/4 = 50%만큼의 성능 손실","→ S4 = 1/0.25 = 4이므로","→ S4 = 1/0.5 = 2 :process는 1개~ 4개했지만 speedup은 2개","absolute speedup if T1 is running time of sequential version of code running on 1 core.","Absolute speedup is a much truer measure of the benefits of parallelism.","characterize : 얼마만큼 성능을 내는지 분석","Def. Efficiency E_p = \\frac{S_p}{p} = \\frac{T_1} {pT_p}= speedup / process 개수","Def. Speedup: S_p=\\frac{T_1} {T_p }","E4 = 4/4 = 1 -> 결국 100% (손실이 전혀 없다)","ex","k<p, k = 4 / thread를 4개 띄운 형태","Measures the overhead due to parallelization","p processor cores, Tk is the running time using k cores","p=8 / 8개 core를 활용하는 CPU","relative speedup if T1 is running time of parallel version of the code running on 1 core.","Reported as a percentage in the range (0, 100].","S4 : 4개의 cpu를 활용하여 얼만큼 속도가 빨라지는지 = T1/T4","T1 : 순수하게 하나의 CPU에서 sequential -> absolute speedup : 혼자 돌았을 때","t1 = 1인데 t4=0.5","T4개 돌았을 때 시간이 있다면 S4 = T1/T4","순수하게 thread 1개 넣은 t1 = 1, t4 = 0.25","이상적으로 바라는 100%까지는 도달하지 못함","이상적으로 효율적으로 parallellize"]},{"l":"Performance of psum","p":["Untitled","loss가 커지는 게 Sp가 어느정도 가다가 성능은 더 좋아졌지만 도움이 되지 않는다","효율이 떨어지기 시작한다 → 가장 최적의 성능을 갖는 8 core까지 돌림","pt : 성능을 가장 잘 낼 수 있는 point","Efficiencies OK, not great -","Our example is easily parallelizable -","Real codes are often much harder to parallelize 16"]},{"l":"Memory Consistency","p":["memory에 두 변수가 있고 Thread1 : a -> 2, print / Thread2 : b -> 200, print","execution order가 이미 정해져 있음","값이 deterministic하지 않음 : thread1<->thread2 순서 interleaving 가능","각각 실행되는 순서에 ordering을 강제화하지 않는다면 값을 알수 없음","→ 실행되는 순서에 따라 달라지는 값","Untitled","What are the possible values printed?","Depends on memory consistency model","Abstract model of how hardware handles concurrent accesses","Sequential consistency : 순서에 따라 실행될 수 있게","만일 순서에 따라 실행되지 않는다고 하면, 나올 수 있는 결과값을 보장할 수 없음.","전체적인 결과가 각 thread의 실행 순서에 따라 결정되고 interleaving에 따라 변화","Overall effect consistent with each individual thread","Otherwise, arbitrary interleaving 17 Thread2: Wb: b = 200; Ra: print(a);"]},{"l":"Sequential Consistency Example","p":["Untitled","Impossible outputs","100, 1 and 1, 100","Would require reaching both Ra and Rb before Wa and Wb"]},{"l":"Non-Coherent Cache Scenario","p":["Untitled","Write-back caches, without coordination between them","cache → 더 복잡해짐/ a=1, b=100","thread 1 : a =2 @ cache","thread 2 : b =200 @ cache 라고 하자.","memory의 값","cpu에 register만 있는 것이 아니라 memory까지 가는 길목에 cache 존재","a,b의 contents copy본이 어디엔가 존재","thread가 실행하며 update했는데 그 값이 main memory의 original copy본과 과 다름","memory에서는 복제 값을 가지고 있고 thread로부터 최종 update하지 않은 상태","→ b=100 print","문제 상황 : 이렇게 하면 안됨 (문제상황)","thread 1번은 thread 2번이 b라는 것을 cpu cache에서 b=200으로 바꾼 것을 모름","thread 2번은 thread 1번이 a라는 것을 cpu cache에서 a=2으로 바꾼 것을 모름","각 cahce에 복제본을 가지고 update한 다음 실행하게 되면 a =1 프린트하고 b=100을 print하게 됨 (최신의 값으로 update되지 않음)"]},{"l":"Snoopy Caches","p":["→ exclusive tag","→ 실제 순수하게 cache간 값을 share하는 overhead는 감수한다. (0은 아님)","a라는 copy본을 가지고 있지 않지만 다른 cpu cache에 a라는 값이 복제본 가짐을 알 수 있는 방법","Cache coherensive protocol을 hw적으로 implement (by snoopy)","main memory로부터 cache로 copy본을 가지고 있어 값을 바꾼 후 update되지 않은 상태","Set tag to S","snoopy cahces :","SP하는 입장에서 보면 HW적으로 메커니즘이 구현되어 있기에","Supply value from cache","thread 1에서 b를 접근할 때 thread 1에서 exclusive tag를 가지고 있다면 이를 가져와 print","Untitled","Untitled|Status|Contents||------|---|| Invalid | Cannot use value || Shared | Readable copy || Exclusive | Writable copy |","When cache sees request for one of its E-tagged blocks","각 CPU에서 돌아가는 memory contents에 cacheing될 때 tag를 붙여 둠","내부적인 multicore로 봤을 때의 개념 기억하기, 성능 상의 차이","누가 어떤 contents를 가지고, tag를 가지는지를 서로 확인할 수 있게 하는 방법이 hw적으로 구현","만약, thread2번이 a를 접근하는 경우에","읽을 때 thread 1의 contents를 shared로, thread 2의 contents 를 sahre Untitled Untitled"]}],[{"i":"10-dynamic-memory-allocation-basic-concepts","l":"10. Dynamic Memory Allocation: Basic Concepts","p":["Dynamic Memory Allocation: Basic Concepts"]},{"l":"Basic concepts"},{"l":"Dynamic Memory Allocation","p":["Untitled","heap이 어떻게 관리가 되고 있는지에 대한 고민은 해 본적 없는 것 같다.","영역 내 빈 공간을 관리하는게 malloc allocation이 해 주는 역할","space manager라 해도 과언이 아님 : space 관리를 어떻게 해 줄것이냐","brk ptr : 0부터 top에 해당하는 크기만큼 할당하고 이 안에서 가장 공간 효율성을 높이며, 성능을 그렇게 저하하지 않으면서 이 방식에 따라 할당함 -> 더이상 할당 할 공간이 없으면 brk pt를 올려 줌","→ sbrk라는 system call을 통해 ‘늘려줘’ 명령하여 library의 ptr 값이 늘어남 : 공간 관리","application에서도 malloc-free 등 지속하다가 더이상 할당할 부분이 없으면 sbrk를 통해 쭉 늘려줌","처음부터 왕창 늘려놓으면?","물론 그래도 되지만, application 필요한 만큼만 할당해주면 되지 미리 줄 필요가 없다.","heap 관리자를 어떻게 만들 것이냐 : 주된 목표이자 하고자 하는 내용","Programmers use dynamic memory allocators (such as malloc) to acquire VM at run time.","For data structures whose size is only known at runtime."]},{"l":"Dynamic memory allocator","p":["→ c에서 사용하는 explicit allocator로 설명해보자","Allocator입장에서 heap은 ‘collection of variable sized blocks’ : allcoated / free","c++ new / delete를 사용해서 memroy 할당 및 해제","code, data 부분 제외하고 heap부터 시작","dynamic memmory allocator를 활용해 가상 메모리 공간 안 heap space memory를 run time시 할당하고 해제할 수 있다. Dynamic memory allocators manage an area of process virtual memory known as the heap.","E.g., malloc and free in C","ex. JAVA, ML, LISP에서는 할당된것 중 사용 안되는 것들을 collect함","Exlicit allocator: application allocates and frees space","explicitly하지 않고 내부적으로","garbage collector : 자동적으로 사용안되는 block 중 자동으로 free해줄 수 있음","Implicit allocator: application allocates, but does not free space","language마다 다름","language에서 malloc, free같은 함수를 통해 직접 해 줘야 함","process의 가상메모리 공간에 0부터 max에 해당하는 process의 가상메모리 공간","Types of allocators","프로그래밍할 때 메모리 공간을 요청하고 free하는 행위"]},{"i":"heap","l":"‘Heap’","p":["→ brk ptr가 가리킴","→ chunk 3개 가진 block을 할당하고, chunk 2, chunk 1 할당 / 나머지 공간은 free한 공간","→ 이 메모리를 가져다 : 가변적 크기를 가진 이 block들의 allocate된 것들과 free된 것들의 집합. 각각은 allocate 되어 있거나 free되어 있다.","→ 이 지금 말한 heap 부분이 지금 말한 부분에 해당함","0번지부터 brk : heap 의 크기","3 chunk - 2 chunk - 1 chunk block","brk ptr = heap의 top","Brk ptr로부터 증가 : sbrk라는 system call","c language 같은 경우 standard c malloc library 할당하는 system library","ex. malloc을 사용해 block 선언 / chunk 크기 3","explicit allocator","Heap : 동일한 크기의 chunk로 이루어진 array이다.","implicit allocator","memory alloc 관점엥서 보면 Allocate되어 있고 / free한 상태이고","runtime 시에 필요한 vm 값을 요청하기 위함 : dynamic memory allocator","top heap brk ptr → heap의 top에 해당하는 주소이다.","vm 공간안에서 있는, 0부터 max값이라고 하면 code, data 부분을 제외하고 heap이라고 되어 있는 부분에 top에서 Brk가 가리키는 ptr","Will discuss simple explicit memory allocation today","가상 메모리 공간 = process마다 각자 자신의 가상 메모리 공간을 가짐","내가 사용할 수 있는 heap이라는 공간은 그 크기만큼 사용할 수 있다","내부적인 malloc같은 sbrk system call을 통해 brk ptr를 증가시킬 수 있음","어떤 특정한 시점에서는 변하지 않은 값으로 저장","이 공간을 가져다 사용 : brk ptr를 증가시켜줌으로서 heap의 공간이 더 커질 수 있음","일반적으로 얼만큼 data가 필요한지 모르니, static하게 잡기보다도 runtime시에만 필요로 하는 자료구조 크기가 알려진 경우 dynamic memory allocator 사용하여 malloc","일부 영역 ‘heap’ - brk ptr : heap 공간 크기를 결정할 수 있는 range를 가리킬 수 있음"]},{"l":"The malloc Package","p":["(until OS kernel이 최소로 필요로 하는 공간 (cspro 500MB))","(실제 OS의 rsrc를 print했을 때 나오는 값보다 → process에게 그 이상은 주지 못한다)","→ memory가 없다라고 실토함 : 현재 가용 가능한 memory를 tracking하다가 없으면 failuress","→ 그 때 heap 공간에서 free하지만 원하는 공간이 continuous하길 원한다.","8 byte의 word 크기 : 1byte만큼 활용하면 - 7byte만큼 사용 x","allocator 안에서 사용되는 system call","a가 3개 allocate -> 4개로 늘려주는 역할","brk ptr: os kernel이 가짐","brk ptr를 올리거나 내리는, heap을 조절해주기 위한 함수","calloc: Version of malloc that initializes allocated block to zero.","CPU 에 따라서 requested size보다 크거나 같은 사이즈","ex. * p가 f 부분을 가리킨다 → ‘aa’부분을 free해준다.","free할 메모리의 크기는 내부적으로 알 수 있다 : meta정보를 읽고 word 2개 사이즈를 free하는구나","heap space, Heap 안 다양한 메모리에서 p라는 block을 return p라는 가상 메모리 ptr가 가리키는 memory","heap stage에서 할당할 부분이 없는 경우","If size == 0, returns NULL","internal fragment 등으로 활용가능","malloc은 brk","malloc은 heap 영역에 다음과 같이 할당하면 allocate되어 있지만 해당 공간은 초기화가 되어 있지 않음","memory contents를 깨끗하게 지우고 싶다고 하면 해당 공간을 calloc이라는 함수를 사용하여 호출하면 malloc과 동일하게 할당하고, contents = 0으로 초기화한다 (initialize)","Other functions","p must come from a previous call to malloc or realloc","ptr 값을 받아 가상 메모리 주소, 크기 -> 그에 맞추어 size 조절","realloc: Changes the size of a previously allocated block.","Returns the block pointed at by p to pool of available memory","sbrk: Used internally by allocators to grow or shrink the heap 5","sbrk도 요청해서 할당받고 하면 top of the heap을 가져다 brk ptr를 증가시키고 언젠가는 실패 : kernel안에서 sbrk system call handler가 threshold를 가지고 있음","sbrk로 heap 영역을 최대로 늘리고도 부족한 경우에 발생하는가?","Successful : boundary에 align되는 memory block allocate한 후 ptr return","Successful: Returns a pointer to a memory block of at least size bytes aligned to an 8-byte (x86) or 16-byte (x86-64) boundary","top of the heap를 setting해 놓고 그 공간 안에 더이상 빈 공간을 찾을수 없다고 하면 sbrk를 지속적으로 늘려 주면","top of the heap이 넘쳐나는 경우에는 내부적으로 sbrk라는 system call을 통해 증가","Unsuccessful: returns NULL (0) and sets errno","virtual memory의 시작 주소 return","void *malloc(size_t size)","void free(void *p)","공간이 없어서 error를 return 하는 경우가 있을 수 있다= 성공하지 못해 메모리를 할당할 수 없다.","나중에 free하게 됐을 때 이 free한 부분이 모종의 status 관리하는 tag에 의해 free","동적으로 결정되는 크기 : program 실행 순서에 따라 결정되는 값","실험"]},{"l":"malloc Example","p":["굳이 그렇게 할 필요 없다 : API만 프로그래머에게 전달해주면 되는 상황이다.","사용자 입장에서 api 안에서 제공되는 함수 사용","malloc의 class version을 만들겠다, pm hint를 주겠다","인접하게 할당하는 등 mymalloc에서 그렇게 구현하면 됨","allocator","word 크기 4byte 가정할 때 heap 관리자, heap 공간 중 free한 공간","모종의 알고리즘을 통해 할당할 공간을 찾는다.","n=3 -> 3","각각의 4byte만큼 떨어지며 0, 1, 2 ~~ 25’","공간들은 free가 됨"]},{"l":"Assumptions Made in This Lecture","p":["(몇가지 가정 후 설명 진행)","→ free를 할 때 p가 가진 memory 두 개 공간이 있는데 이를 free하면 됨","DB : record 관리, file형태로 담아 놓고 필요한 record 찾고 수정하고 집어넣는 관점에서 볼 때 상당히 비슷한 부분이 많음.","Heap : 연속된 가상 메모리 공간","malloc-DB","memory address : 가장 최소 단위 word (8byte or 16byte)","Memory is word addressed.","memory 공간 할당자","memory 크기는 딱 두개의 word로 되어 있다","Untitled","Words are int-sized.","word를 어떻게 free할것이냐에 대한 내용은 논의하지 않음 (나중에 배울 예정)","두 칸을 가져다 free하는데, free후 p만 인자로 받음","빈 공간이 생기면 그들끼리 묶어두면 된다","실제 memory allocator 구현하는 입장에서 보면 생각할 게 많음","어떤 data의 영역을 관리하기 위한 system을 어떻게 build할 것이냐로 확장할 수 있음","어떤 요청에서 빈공간을 찾아 return해주면 된다"]},{"l":"Allocation Example","p":["동적 memory allocator : gdc에서 효율적으로 잘 짜여 있음","두 가지의 metric.","allocator이 잘 동작하느냐에 대한 correctness (malloc-free combination이 잘 동작하느냐)","space effectivity에 대해서 실제 효율적이냐, 성능에서도 malloc 이 좋은가","가상 메모리 공간 continguous","OS가 해줘야 하는 역할 / 프로그래머 입장에서는 Vm 공간 중 heap이라는 일부 공간을 contiguous하게 할당받아 그 공간들만 할당해주고 해제해주고","block storage","다음과 같은 heap이라는 공간이 있다.","chunk 크기로 된 연속적인 공간","Untitled","free(p2): p2가 가리키는 block 안 chunk 5개가 free된다.","Free할 때 ptr를 찾아가게 되면 정보가 있고 여기서부터 연속 5개는 하나의 block안에 포함됨을 알고 다섯개를 free시켜준다.","p4=malloc(2) : 2개의 chunk를 할당하는데 어디다 할당할 것이냐?","→ 모종의 방법을 통해 다음과 같이 할당된다.","이런 식으로, block storage 관점에서 보더라도 상당히 비슷하다. 가상 메모리 공간에서 contiguous한 공간이고, 크기 공간들 중 빈 공간들을 관리하는 관리자라고 보면 됨"]},{"l":"Constraints","p":["6-5-4 순서 바꾸어 할당하겠다 하면 허용이 안됨","8-byte (x86) or 16-byte (x86-64) alignment on Linux boxes 32bit machine -> 8byte, 64bit -> 16byte 나머지는 unused 부분","allocated된 부분에 allocate하면 안됨","Allocators","Applications","buffering하지 않기 때문에 순서를 바꾸지도 않음","Can issue arbitrary sequence of malloc and free requests","Can manipulate and modify only free memory","Can’t control number or size of allocated blocks 이미 할당된 block들 : block 크기, 개수도 임의로 바꿀 수 없음","Can’t move the allocated blocks once they are malloc’d","free request must be to a malloc’d block","i.e., can only place allocated blocks in free memory allocate하게 되면 free한 memory에 할당","i.e., can’t reorder or buffer requests","i.e., compaction is not allowed","malloc, free라는 동적 memory allocator fn","memory alloc/free req sequence를 보되, 이 sequence는 arbitrary. Issue라고 바라봐도 됨","Must align blocks so they satisfy all alignment requirements","Must allocate blocks from free memory","Must respond immediately to malloc requests 일단 malloc이라는 allocator같은 경우 요청에 대한 즉각 응답하여 할당","이미 allocate된 block을 free해주는 것이 free이다."]},{"i":"performance-goal-throughput","l":"Performance Goal: Throughput","p":["→ allocate 5개를 빨리 찾고 해당 공간을 할당해주어야 함.","→ 이를 처리할 수 있는 allocator 1000개의 operation per second보다 낮아질수도 있음","→ 첫 목표 : throughput 높이는 것","5,000 malloc calls and 5,000 free calls in 10 seconds","Example:","free하게 되면, 해당 ptr가 어디있는지 찾아 free시켜야됨","Given some sequence of malloc and free requests: 어떤 program에서 malloc. & free request","Goals: maximize throughput and peak memory utilization","Number of completed requests per unit time","R_0, R_1, ..., R_k, ... , R_{n-1 }","These goals are often conflicting","Throughput is 1,000 operations/second 10","Throughput:","throughput을 높인다= allocate요청했을 때 immediately respond 즉각 반응","throughput이 1000보다 높을수도 낮을수도 있다.","나중에 설계, 구현을 보면 알 수 있음","상위 개념에서 보면, allocator","어떤 allocator를 설계해서 5000개의 malloc과 free를 처리"]},{"i":"performance-goal-peak-memory-utilization","l":"Performance Goal: Peak Memory Utilization","p":["8 byte alignment","After request R_k has completed, the aggregate payload Pk is the sum of currently allocated payloads","Assume Hk is monotonically nondecreasing","Block : 10byte -> 10byte","Def: Aggregate payload P_k","Def: Current heap size Hk","Def: Peak memory utilization after k+1 requests U_k = \\frac{\\max_{i\\leq k}P_i}{H_k}","Given some sequence of malloc and free requests:","heap 크기가 늘어날","hk : Hk까지 요청했을 때 당시 heap의 크기를 가져다 h_k","i.e., heap only grows when allocator uses sbrk","k번째까지 malloc을 성공했다 → Pk 현재 allocate","malloc Pk라고 할 때, 해당 p라는 것은 요청 memory에 block하나를 할당받는데 실제 요청한 data가 저장되는 data 크기","malloc(p) results in a block with a payload of p bytes","payload Pk","Programmer는 vm 공간이 내가 가진 가상 memory더라도 실제 가지고 있는 memory 공간이 굉장히 크다고 판단하지만 실제 물리적으로 1GB밖에","R_0, R_1, ..., R_k, ... , R_{n-1 }","utilization","내 물리적 공간이 아닌 다른 부분에. 그런 관점에서 최대한 활용해 utilization을 높이 ->","앞과 example은 똑같고, 다음과 같은 def를 이해해야 한다.","요청할 때마다 쉽게 할당해주는 공간 -> 처리를 높임 한번에 응답할 때 응답 시간을 줄임.","해당 값을 maxmize하여 해당 memory 최대한 사용할 수 있게, 빈 공간을 찾ㅇ아 꾸역꾸역 넣어야 함"]},{"l":"Fragmentation","p":["Poor memory utilization caused by fragmentation","internal fragmentation","external fragmentation"]},{"l":"Internal Fragmentation 내부 단편화","p":["For a given block, internal fragmentation occurs if payload is smaller than block size Untitled","Caused by","Overhead of maintaining heap data structures","heap을 관리하는 data structure의 overhead","Padding for alignment purposes","Explicit policy decisions","큰 block을 return해야 하는 경우(e.g., to return a big block to satisfy a small request)","Depends only on the pattern of previous requests","이전에 어떤 게 왔는지에 따라 왕왕 생김","Thus, easy to measure","10byte + 나머지 6byte 앞과 뒤에 나뉘어 짐","나머지 6byte는 사용되지 않음","구현에 따라 internal fragmentation을 상당히 줄일 수 있음"]},{"l":"External Fragmentation","p":["Untitled","연속적으로 이어진 공간이 5개, 2개임 (free(p2))","Occurs when there is enough aggregate heap memory, but no single free block is large enough - external fragmentation 발생하면 할당하지 못하는 경우가 발생할 수 있음","Depends on the pattern of future requests 미래에 어떤 요청을 하는지에 따라 생길수도 생기지 않을수도 있음","Thus, difficult to measure"]},{"l":"Implementation Issues","p":["→ memory utilization이 maximize되지 않는다.","→ 그러나, 이렇게 구현하면 memory ineffective","→ 둘을 가져다 allocate상태로 만들어 주고 나머지 뒤는 free하게 만들어 줌.","1byte, 2byte로 표현할 수 있는 것을 32byte","allocate가 이렇게 되어있는 상태에서 free한다고 가정하자.","allocate된 것을 pool로 어떻게 return할 것인가.","fast: 뒤로 forwarding하면서 return하면 됨","free(ptr) : ptr이. 가리키는 object가 있는데, 이 object가 32byte라 하면 free시키는 시점에 obj가 32b라는 것을 어떻게 아느냐?","free한 공간보다 작을 때 padding을 붙이거나 다른 공간을 사용하거나","How do we keep track of the free blocks? 2. 어떤 free한 공간이 있는지 track하기- heap이라는 공간은 앞서 이야기한대로 쭉 vm에서 allocate-free된 형태로 남아있다.- free한 space들을 tracking해야 하는데 이를 어떻게 해야 하느냐?- block 크기들은 가변적","How do we know how much memory to free given just a pointer?","How do we pick a block to use for allocation -- many might fit? 4. allocation하려 하는데 free block이 여러개 있다. 그럼 어떤 block을 선택할 것이냐?","How do we reinsert freed block? 5. free block 어떻게 return할 것이냐?","malloc (3)을 한다고 하면 2+3 부분을 가리키고 old ptr를 return","malloc을 직접 구현하며 ptr를 exercise, memory allocator 개념을 이해할 수 있을 것","malloc할 때마다 앞으로 가는 쪽을 보면 무조건 free","memory allocator를 어떻게 design하고 구현하느냐에 따라 여러가지 issue","naive한 구현 시","point) 뒤로는 절대로 안 돌아간다.- 중간중간 fere하게 되면 빈 공간이 생기는데 다시 절대 reuse할 수 있는 구현이 아님. 말 그대로 naive implementation의 경우임- feed forward하며 alloc을 효율적으로 할 수 있으나 memory utilization- → throughput은 좋으나 peek는 성능이 좋지 않아짐.- 그냥 구동만 하면 되는거 아니냐? 하지만, memroy가 굉장히 중요한 작은 embedded환경에서는 절대 허용되지 않는다.- system 관점에서 보면 작은 memory를 어떻게 utilize해서 꾸겨 넣을 것인가에 좌우된다.","Pointer","Ptr = malloc(2) : 이전에 있던 결국은 oldptr","ptr로 가리키고 있는 memory object를 free시킨다고 할 때, 그 memory object 크기가 얼만큼 되는지 어떻게 아느냐?","What do we do with the extra space when allocating a structure that is smaller than the free block it is placed in? 3. free block에 allocate하려고 하는데 자료구조가 내가 받은 free block보다 작아서 그 block을 다 사용하지 못한다고 하면 extra space는 어떻게 할 것이냐?- Ex. Free block하나를 할당 받았고 그사이즈는 64byte이다.- 내가 쓰려고 하는 data 공간은 48byte이다. 그럼 나머지 부분은 어떻게 할 것이냐?","모두 free block인데 어떤 block을 선택할 것이냐?","앞의 그림처럼 이런식으로 heap을 가져다 large array로 보고, 처음엔 p를 0으로 두어 구현됨","어떤 것을 가져다 선택할 것인가","얼마만큼 free하면 되는지도 알고 있어야 함","오래된 p를 stack에 집어 넣고 ( push(p)), oldptr = pop(p)"]},{"l":"Knowing How Much to Free","p":["For issue 1","block 맨 앞에다가 word size를 4byte라고 하자. 4byte로 되어 있는 크기에 무엇을 집어넣을 것인지 : header field, header","block의 크기를 가져다 적을 것이다.","Standard method","Keep the length of a block in the word preceding the block.","This word is often called the header field or header","Requires an extra word for every allocated block p0 p0 = malloc(4) 5 free(p0) 16 block size payload","Untitled","block의 크기 만큼을 free시켜주면 됨","p0 가 가리키는 block의 크기가 5였음을","P0 가 가리키는 word를 읽어 봄으로써 사이즈를 읽어내 deallocate할 수 있다."]},{"l":"Keeping Track of Free Blocks","p":["-> 공간 효율이 떨어짐","→ complicated, intelligent","→ logically linking 가능 : ptr값이 있으면 다음 다음 block을 계속하여 traverse 가능","→ 그러면 free block들을 관리할 때, 같은 크기의 group으로 묶어 class로 만들자.","block의 크기를 가지고 free block을 track하는 방법","Can use a balanced tree (e.g. Red-Black tree) with pointers within each free block, and the length used as a key 17","Different free lists for different size classes","For 2nd issue","free block size가 다양한 block들","free block을 어떻게 track할 것인가.","Method 1: Implicit list using length—links all blocks Untitled","Method 2: Explicit list among the free blocks using pointers 5462","Method 3: Segregated free list","Method 4: Blocks sorted by size","Ptr를 heap의 맨 시작부터 읽기 시작하면 첫 번째 block의 크기이기 때문에 p에서 5를 더해주면 그 다음 block의 첫 번째 앞을 보게 되고, 4를 더해주면 다음 block 맨앞, 2 더해주면 다음 block맨 앞","suffistigated than 1, 2 method","Untitled","그 다음의 free block을 가리키는 word를 할당함. :주소 정보 다음 word에 그 다음 free word의 주소값을 가지고 있다.","내가 요청하는 block의 크기가 작다고 하면, class1에 해당하는 block 중 하나를 찾고 크기가 크다고 하면 3에 해당하는 block 중 탐색","단점) extra로 그 다음 free block을 가리키는 만큼의 extra memory 비용을 지불해야 함","단점) method1 : 모든 block을 linking하기 때문에 실제 우리가 필요한 건 allocated block보다는 free bock이다. 심지어 allocated block까지 traverse해야 하는 단점.","맨 앞 word size 앞에 적혀진 size","모든 block size로 balanced tree를 만들되 각각을 free block을 맏늘도록 하고 요구되는 크기보다 크기에 딱 맞는, sorted order로 되어 있는 balanced tree를 찾아낸다","모든 block들 : 5 free block / 4 alloc block / 6 free block / 2 alloc block","모든 block을 traverse해보면서 free var tracking 가능","앞의 것과는 다름 : free block을 track하기 위해 link로 만든 것을 활용해서 모든 block을 traverse하는 앞의 것 / 앞의 size 정보를 사용해 다음 block으로 갔다","앞의 모든 block들을 free","직접 free한 block으로 가고 싶지만 못한다 (모든 block 앞의 크기 정보를 가지고 모든 block을 traverse하다보니 linking할수는 있지만 free block만을 traverse는 불가능)"]},{"l":"Implicit free lists","p":["크기가 가변적인 block : 어떤 block은 가변적이더라도 어떤 chunk에 alignment 되어 있음 : 8byte-16byte-24byte 등 multiples of 8byte","→ 5byte malloc(payload) + 3byte padding = 8byte mallc","header : payload의 크기","LSB : allocated or deallocated bit (1 : allocated / 0 : free)","For example, if a block is imposed a double word alignemnt, the block size is a multiple of 8 and the 3 low order bits of the block size are always zero.","31 … 4 3 2 1 0/ 29bit를 가지고 size를 표현함","맨 끝 2 - 1 - 0: 0th bit에서는 allocate or deallocate indicator, 실제로 2-1th bit는 unused형태","Heap이라는 것은 결국 block의 집합이다 : free block 3 / block 3"]},{"i":"method-1-implicit-list","l":"Method 1: Implicit List","p":["(1) 각각의 block은 status 정보를 가지고 있어야 함 : free or allocated","(2) traverse하기 위해서는 ptr를 가지고 ptr size만큼을 더해주어야 하기에 각각의 size 정보를 가지고 있어야 함 : size","(가정) 주어진 block에 대해 앞서 이야기한 대로, size 정보가 앞에 존재한다. status 정보도 필요해서 각각을 가져다가 8byte씩 할당했다고 가정하자. (Word size : 8byte)","→ 각각 8byte word로 저장한다고 하면,","→ 그러면 이 안에서, 맨 마지막 bit를 allocated. Free status를 구분하기 위해 flag로 사용해도 되지 않을까? 어차피 alignment되어 있기 때문에 사용하지 않으니까, 저 장소에 embedding하자","→ 최하단 세 bit들은 항상 0이다.","1 : allocated / 0 : free / 나머지 bit는 size로 쓰면 됨","1 million block * 2 * 8 = 16MB / 1 million block * 8 = 8MB","16byte = 0…010000","32byte = 0…011000","8 byte alignment되어 있다면 : block size가 8-16-24-32-48-56-64-…의 형식","8 byte를 2진법으로 표현한다고 하면, 8byte = 64bit 00..001000","8byte가 alignment되는 unit이고 malloc(5)라고 하면 1byte : size / allocation status 나머지 5byte : payload 그리고 2byte : padding(Spatial cost를 다음과 같이 줄일 수 있다)","8MB만큼의 비용을 더 지불해야 함. : 16byte로 저장해야 하는걸 8byte로 지불하자","Block들은 alignment되어 있는데, 어떤 system architecture이느냐에 따라서 8byte or 16byte alignment되어 있을 것이다.","Could store this information in two words: wasteful!","For each block we need both size and allocation status","Format of allocated and free blocks","If blocks are aligned, some low-order address bits are always 0","Implicit list","Instead of storing an always-0 bit, use it as a allocated/free flag","size와 allocation status를 16byte가 아니라 8byte만큼 저장할 수 있지 않을까?","Standard trick","When reading size word, must mask out this bit","두 가지 정보를 가지고 있어야 함.","두 가지를 저장하기 위해 16byte spatial cost 지불"]},{"l":"Detailed Implicit Free List Example","p":["Untitled","word size : 4byte인 경우에 대해 설명해보자.","block 각각이 8/16/32/16byte, word size information / LSB : 0 free 1 allocated","dotted :double word에 대해 align된 point","payload는 2word니까 allocate되어 있지만 사용되지 않는 부분","advantage : simplicity","Disadvantage :","any operation requires a search of the free list, such a placing allocated blocks","Free block을 찾기 위해 traverse를 계속 해야 함. -> free list를 찾아야 하는 time overhead","여러 free block이 있을 때 어떤걸 선택할 것이냐?"]},{"i":"implicit-list-finding-a-free-block","l":"Implicit List: Finding a Free Block","p":["→ 그 만큼의 크기를 더해준다는 의미로 jump해줌","→ 항상 내가 한 번 찾으면 처음부터 search하고, 처음에 검색하고 그다음부터 쭉","0을 가져다 만드려면 and operation을 할 때","11…110으로 된 operation : 2’s complement하면 -2를 가지고 and를 취하게 되면, 결국 * p ptr 값이 무슨 값이든간에 lsb는 무조건 0이 됨","allocate되어 있다고 하면 무조건 skip하는 세번째 condition","allocation하기 전 free 한 부분을 찾는 것이 시작","Best fit:","block 처음부터 scanning을 쭉 함","Can take linear time in total number of blocks (allocated and free) 항상 앞에서부터 시작해야 하기에 느림","First fit:","free block을 찾기 위해 쭉 들어가 있는데 들어와서 찾고 들어와서 찾고 …","In practice it can cause “splinters” at beginning of list","Keeps fragments small—usually improves memory utilization","left over 되는 block이 작은 것들","Like first fit, but search list starting where previous search finished","Next fit:","next fit은 앞에서부터 찾을 필요가 없어 일반적으로 first fit보다 빠름 : rescanning할 필요는 없으니까 반드시 그렇진 않음 : 이전에 할당한 것으로부터 free space가 생기면 앞에서 찾는게 더 빠를 수도 있음","Search list from beginning, choose first free block that fits:","Search the list, choose the best free block: fits, with fewest bytes left over","Should often be faster than first fit: avoids re-scanning unhelpful blocks","Some research suggests that fragmentation is worse","Will typically run slower than first fit","word 크기가 4byte였다고 하면, 32bit 중 31bit (size) + 1bit(1 or 0)","공간적 utilization의 최대화 : 내가 요구하는 memory를 가장 근접하게, allocate했을 때 free block이 사용되지 않는 internal fragmentation을 찾는 것 : best fit","만일) 1이라는 값과 non allocate였으면 * p<=len 확인","찾아서 내가 필요로 하는 크기보다 작은것을 요구했음에도 처음부터 또 들어가 찾아내고","처음부터 찾는게 아니라, 다음 부터 찾음","최선의 선택을 위해 처음부터 끝까지 다 뒤져봄 -> 느리다."]},{"i":"implicit-list-allocating-in-free-block","l":"Implicit List: Allocating in Free Block","p":["free block을 찾아 splitting","Addblock(p,4) 6개가 빈 공간이기 때문에 4만큼을 그 공간에 할당","allocate : 4 / freed 2 (나누어 주어야 함)","Allocating in a free block: splitting","Since allocated space might be smaller than free space, we might want to split the block","예전에 있던 oldsize = 6","맨 밑 low bit를 mask out해주고 새로운 size에는 일단 allocate되어 있으니가 allocate 되어 있음을 표시해줌","len = 4. Len =5를 집어 넣어보고 round up to even을 확인해봐라.","double word alignment되어 4 byte의 multiple인데 4, 8, 12 -> even number를 곱해줘야 함","Masking이라고 해서 맨 끝에 alignment를 맞추어 줌 (mask out low bit)"]},{"i":"implicit-list-freeing-a-block","l":"Implicit List: Freeing a Block","p":[": 메모리 공간 효율적으로 사고하기","→ 5개짜리를 allocate할 수 없음 : 연속 5 free block이 없기 때문에 (false fragmentation)","→ heap","→ 지금과 같이 4개 / 2개로 분리됨.","4를 free시키고 싶으면 4 word를 return해야 함","allocate : 비교적 simple","But can lead to “false fragmentation”","Contiguous한 공간이 없어 false fragmentation :","free(p)","free는 복잡합 : false fragmentation","malloc(p)→ OOPS!","malloc안에서 sbrk를 호출하여 brk라는 top of the heap를 늘려 줌","memory allocator 입장에서 free를 볼 때, 최대한 합쳐서 큰 chunk를 많이 만들어 놓는게 좋다","Need only clear the “allocated” flag","Oops! There is enough free space, but the allocator won’t be able to find it","P부분을 free 시켰다고 하자 : allocate bit를 free로","Simplest implementation:","Untitled","공간이 있음에도 없다고 보고받아 sbrk를 통해 늘려주게 됨.","그렇지 말고 fragment들끼리 합칠 수 있으면 합쳐야 함 : correlasing","내가 만족하는 free한 block을 찾을 때 까지, 앞에서 끝까지 다 scan해서 최적의 여분을 가장 적은 frag을 남기는 free를 찾던, allocation 한 후 split하면 됨.","연속적으로 이 2개가 쪼개져있다 보니 allocate할 수 없음"]},{"i":"implicit-list-coalescing","l":"Implicit List: Coalescing","p":["→ 그 값은 4에다가 next에 해당하는 2를 더해 값을 update해줌","→ 다음 block에 있는 현재 free하단 block이랑 합침.","4 & -2 연산 : 00000010, 11111101 +1 ->11111110","But how do we coalesce with previous block?","coalesce","Coalescing with next block","Even한 double word로 alignment하여 값을 뽑아오고","free(p)","free(p): 가상 주소를 가지고 빈 공간으로 free list를 return하는 상황으로 고려","free할 때 그 다음에 있는 녀석을 합쳐주는 것 Or 내가 free할 때 걔랑도 합쳐 줌","Join (coalesce) with next/previous blocks, if they are free","join한다","pt가 가진 obj가 앞과 뒤를 보고, free인지 확인한 후 합칠지 안 합칠지 결정.","Untitled","Word size 4인 block : free할 때","그 block에 and operation : 다음 block이 free라고 하면","그 다음 block이 현재 pointer p에서 값을 더한 것이 다음 block","내가 free하고자 하는 block의 앞과 뒤를 보고 -> free하다면 합쳐주는 것","이전 block은 어떻게 합칠 것인가? (이 슬라이드에서는 forward)","이전 block이 free인지를 봐야하는데, 이전 block을 reference할 수 있는 방법이 없다 : 문제 발생","코드 설명 :"]},{"i":"implicit-list-bidirectional-coalescing","l":"Implicit List: Bidirectional Coalescing","p":[": 각 block의 bottom에다 size에 해당하는 word만큼을 복제해보자","*p: p를 free한다고 하자","→ header가 아니라 footer를 가져다 boundary tag 삽입","Allows us to traverse the “list” backwards, but requires extra space","backward.: 이전의 word의 ptr 값을 보면, 이전 block의 크기를 알 수 있기 때문에 전의 시작 주소를 알 수 있음 -> LSB 값을 보고 이전 block이 free인지 allocate인지 알 수 있음","Boundary tags [Knuth73] - bidirectional coalescing : 앞, 뒤 모두를 합치는 방법","double word alignment를 해서 그 다음이 누군지 addressing할 수 있었음","forward :","header라는 block에 이 block의 크기라는 hint를 심어둔 것.","Important and general technique!","Replicate size/allocated word at “bottom” (end) of free blocks","Untitled","간단하지만 유명하다","단점 : extra space 필요","사실 backward로 갈 수 있는 size에 대한 정보를 word 크기만큼 추가적으로 사용한 것 : 실제 data를 저장할 공간 payload를 backward traverse 가능한 meta info로 활용한 것이기에 실제 extra space heap space는 줄게 됨.","원래 : 그 다음으로 forward하며 traverse하는 방법은 현재 block의 크기 header를 알면 그 다음 block의 시작 주소를 알 수 있었음","이전 block size를 알 수 있는 방법이 있다면 이전 block을 찾아볼 수 있음"]},{"l":"Constant Time Coalescing Case","p":["coalescing 하는 방법","heap안에서 이전과 이후, 각 상황을 네가지로 분리","이전 block과 다음 block이 allocate되어 있는 block","Alloc - free","Free - alloc","Free - free","Untitled"]},{"l":"Case 1","p":["Alloc-alloc","-> coalescing자체가 발생하지 않음","Untitled"]},{"l":"Case 2","p":["Allocate - free","-> n(1), m2(0)이므로 n+m2 (0) merge","Untitled"]},{"l":"Case 3","p":["case 2와 동일","-> Size 정보 update","Untitled"]},{"l":"Case 4","p":["앞, 뒤 둘다 free 인 경우에 각각의 block size를 더해 n + m1 + m2 (0)","이미 allocate 되어 있었다 하면 앞 뒤를 합쳐 first fragmentation 최고화, contiguous 하게 최대한 크게 만들어서 free list를 구축해 free block 발견","Untitled"]},{"l":"Disadvantages of Boundary Tags","p":["→ internal fragmentation 발생 확률 커짐","→ trick : 이전에 있는게 free 아니라면 footer가 굳이 필요없다.","→ 수 byte를 alloc하지만 앞 뒤 header footer를 둠으로서 상대적으로 payload 크기가 작아 extra overhead를 지불해야 함","block 자체가 free였으면 바로 이전까지는 쉽게 갈 수 있음","Can it be optimized?","extra로 padding을 payload로 사용할 수 있었는데 동일한 정보임에도 duplicate를 해야 함","footer를 사용하 back traverse","free block -> footer / allocated -> footer 굳이 필요 없음.","Free(p) : boundary tag를 보고 나서 allocate/free 구분","free인지는 그 이전으로 돌아가야 함.","free할 때 관심있는 것은 : 이전 block이 free일 때만 corelasing","Internal fragmentation","What does that mean?","Which blocks need the footer tag?","만일 allocate되어있다면 합칠 이유가 없음(allocate되어 있으면 footer 필요 없음 = 앞으로 갈 일이 없음)","만일 그래프같은 연산을 한다면 node, edge에서 node가 작은 크기의 memory alloc해준다고 하자","앞 block이 allocate인지 구분 :","이전에는 bounday point가 없었다.","현재 이전의 block이 free인지 아닌지 식별할 bit를 보고, 만일 이전의 block이 allocate되어 있다면 안에서 질책"]},{"l":"Summary of Key Allocator Policies","p":["Placement policy:","First-fit, next-fit, best-fit, etc.","Trades off lower throughput for less fragmentation","Interesting observation: segregated free lists (next lecture) approximate a best fit placement policy without having to search entire free list","Splitting policy:","When do we go ahead and split free blocks?","How much internal fragmentation are we willing to tolerate?","Coalescing policy:","Immediate coalescing: coalesce each time free is called","Deferred coalescing: try to improve performance of free by deferring coalescing until needed. Examples:","Coalesce as you scan the free list for malloc","Coalesce when the amount of external fragmentation reaches some 32 threshold","여러개가 동시에 free한다고 하면 새로 써 주고 free","필요하면 처믐부터 scan해가며 할 수도 있을 것"]},{"i":"implicit-lists-summary","l":"Implicit Lists: Summary","p":["Implementation: very simple","Allocate cost:","linear time worst case","Free cost:","constant time worst case","even with coalescing","Memory usage:","will depend on placement policy","First-fit, next-fit or best-fit","Not used in practice for malloc/free because of linear-time allocation","used in many special purpose applications","However, the concepts of splitting and boundary tag coalescing 33 are general to all allocators"]}],[{"i":"11-dynamic-memory-allocation-advanced-concepts","l":"11. Dynamic Memory Allocation: Advanced Concepts","p":["Dynamic Memory Allocation: Advanced Concepts CSE4100: System Programming Youngjae Kim (PhD)"]},{"l":"Explicit Free List"},{"l":"Keeping Track of Free Blocks","p":["Untitled","forward traverse : 모든 것을 scan하여 뒤져야 free block을 찾을 수 있음","adv ) spatial : 4/5만큼을 사용 가능","free block을 찾기 위해 모두 뒤져 정책에 찾아 free block","explicit free list : Size가 아니라 word를 가져다 다음의 free block을 가리키는 방법","adv) linear search할 때 method2 : allocated block skip 가능해서 빠름","disadv ) successor에 해당하는 3/5만큼을 사용 가능","Class 마다 linked list로 연결 - 굉장히 빠르게 가장 fit할수 있는 block을 빠르게 찾을 수 있는 기법.","크기에 따라 븐류한 block"]},{"l":"Explicit Free Lists","p":["Header, footer : coleascing - 앞과 뒤","successor- precedesor : Explicit한 방법으로 free list 관리 가능.","Untitled","Maintain list(s) of free blocks, not all blocks","The “next” free block could be anywhere","So we need to store forward/back pointers, not just sizes","Still need boundary tags for coalescing","Luckily we track only free blocks, so we can use payload area","lucky하게도 free list만 관리 가능 → payload 영역 사용의 단점","Logically: Untitled","Physically: blocks can be in any order AB Untitled"]},{"l":"Allocating From Explicit Free Lists","p":["Doubly linked list로 연결되어있다고 하자 :","회색 해당한 만큼을 allocate → free list에 있을 필요 없으므로 split하고 남은 block과 연결해줌","ptr update를 통해 앞에서부터/뒤에서부터 연결, splitting","Untitled"]},{"l":"Freeing With Explicit Free Lists","p":["Insertion policy: Where in the free list do you put a newly freed block?","복잡 : free list를 관리해야 하는데 가져다 return하게 되면 insertion해야 하는데 그 policy","→ search time overhead가 큼","LIFO (last-in-first-out) policy","Insert freed block at the beginning of the free list 맨 앞에다 free block을 가져다 연결시켜줌","Pro: simple and constant time","Con: studies suggest fragmentation is worse than address ordered","Address-ordered policy","Insert freed blocks so that free list blocks are always in address order:","addr(prev) addr(curr) addr(next)","Con: requires search","Pro: studies suggest fragmentation is lower than LIFO","insert되는 block들이 작은 주소부터 높은 주소 순으로 sorting","→ addr ordered 방법보다 fragmentation 경감","실제 allocation할 때 어떤 block을 allocation하느냐를 Allocation해야 하기 때문에, address에 따라 순서대로 search하며 선택해야 하는 문제가 있음"]},{"i":"freeing-with-a-lifo-policy-case-1","l":"Freeing With a LIFO Policy (Case 1)","p":["다른 free한 block을 가리킨다고 하자.","block이 memory상 어딘가 존재할 것 : 앞 뒤에 있는 것을 header-footer 방법을 통해 조사함","→ 앞뒤 allocated면 생각보다 간단하게","header 다음 next에 해당하는 ptr를 다음을 가르키게 함","즉) 앞 뒤가 allocate되면 상대적으로 simple","Untitled","Insert the freed block at the root of the list"]},{"i":"freeing-with-a-lifo-policy-case-2","l":"Freeing With a LIFO Policy (Case 2)","p":["Untitled","Splice out successor block, coalesce both memory blocks and insert the new block at the root of the list"]},{"i":"freeing-with-a-lifo-policy-case-3","l":"Freeing With a LIFO Policy (Case 3)","p":["Untitled","Splice out predecessor block, coalesce both memory blocks, and insert the new block at the root of the list"]},{"i":"freeing-with-a-lifo-policy-case-4","l":"Freeing With a LIFO Policy (Case 4)","p":["Untitled","Splice out predecessor and successor blocks, coalesce all 3 memory blocks and insert the new block at the root of the list"]},{"l":"Explicit List Summary","p":["모든 block을 뒤지지 않아 좀 더 빠른 속도를 가지지만 좀 복잡함 : free state 관리 구현","block의 크기가 최소 5word 이상이어야 함","Comparison to implicit list:","Allocate is linear time in number of free blocks instead of all blocks","Much faster when most of the memory is full","Slightly more complicated allocate and free since needs to splice blocks in and out of the list","Some extra space for the links (2 extra words needed for each block)","Does this increase internal fragmentation?","Most common use of linked lists is in conjunction with segregated free lists Free block들을 ptr로 연결하여 ll로 관리함","Keep multiple linked lists of different size classes, or possibly for different types of objects","LIFO queue","단점 : free block을 link했지만 각 block 크기 가변적","→ fragmentation이 작은 block을 찾으려면 best fit policy에 따라 처음부터 끝까지 뒤져봐야 함."]},{"l":"Segregated Free List","p":["어떻게 segregate : n개의 size class를 만들어 n개의 free block을 안에다 집합","→ 다른 크기의 size class에 따라서 각각 다른 free list 관리하는 기법"]},{"i":"segregated-list-seglist-allocators","l":"Segregated List (Seglist) Allocators","p":["Untitled","Each size class of blocks has its own free list","Often have separate classes for each small size","For larger sizes: One class for each two-power size","이전 explicit free list : 하나의 단일 lifo queue","→ 지금 : 각각의 size을 가지는 list","장점 : best fit - fragmentation 최소화할 수 있는 block을 찾았다면 여기서는 class 별 로 나누었기에 내게 맞는 class를 찾을 수 있는 기법"]},{"l":"Seglist Allocator","p":["(구현 별 문제 : 나머지 fragment를 어떻게 처리할 것인가. 앞에다 붙이는게 빠를수도 있다 (LIFO니까))","→ 8 size block 중 나머지 2개는 1-2class로 이동한다.","→ block이 있는 경우는 block할당, 나머지 frag는 집어넣음","Advantages of seglist allocators","Allocate block of n bytes from this new memory","Better memory utilization","block의 free : 앞, 뒤를 보고 coalesce","Coalesce and place on appropriate list","ex. malloc(4)라고 하면 4를 수용하는 block을 가진 class를 찾음","Extreme case: Giving each block its own size class is equivalent to best-fit.","First-fit search of segregated free list approximates a best-fit search of entire heap.","Given an array of free lists, each one for some size class","Higher throughput) malloc을 할 때 성능이 좋다","If an appropriate block is found:","If no block is found, try next larger class 만일 block size가 없다면 더 큰 class로 이동","If no block is found:","log time for power-of-two size classes","m payload, n 실제 class의 size Payload를 고려하는 것에 따라 m>=n","malloc(6)을 요청했다면 5-8 class에서 할당받는다.","malloc(n)","Place remainder as a single free block in largest size class.","Repeat until block is found","Request additional heap memory from OS (using sbrk())","Search appropriate free list for block of size m > n 처음부터 찾는다 : m>n인 m의 크기를 가진 free list를 찾는다","size class로 나뉘어져 있기에 fragmentation을 최소화하면서 적합한 class를 빨리 찾을 수 있다.","Split block and place fragment on appropriate list (optional)","To allocate a block of size n:","To free a block:","모든 각각의 block마다 size class를 두고 나서 best fit 해당할수도 있으나 class를 너무 많이 뽑아야 함.","새롭게 요청된 메모리로부터 n개의 byte block 할당. Untitled","앞에서부터 찾더라도 나보다도 큰 공간이지만 나중에 보니 fragmentation을 최소화할 수 있는 block이 있을 수도 있다."]},{"l":"More Info on Allocators","p":["Knuth, “The Art of Computer Programming”, 2nd edition, Addison Wesley, 1973","The classic reference on dynamic storage allocation","Wilson et al, “Dynamic Storage Allocation: A Survey and Critical Review”, Proc. 1995 Int’l Workshop on Memory Management, Kinross, Scotland, Sept, 1995.","Comprehensive survey"]},{"l":"Garbage collection"},{"i":"implicit-memory-management-garbage-collection","l":"Implicit Memory Management: Garbage Collection","p":["integer pointer","int type 128 byte (32 * 4byte) (heap에 할당)","stack에 할당 (local variable)","address space를 보면 Untitled","실제 사용하지 않는 공간임에도 불구하고 자리를 차지함","garbage collection : 자동으로 heap에 할당된 storage들에 대한 reclamation","Garbage collection: automatic reclamation of heap-allocated storage—application never has to free","Common in many dynamic languages:","Python, Ruby, Java, Perl, ML, Lisp, Mathematica","Variants (“conservative” garbage collectors) exist for C and C++","However, cannot necessarily collect all garbage"]},{"i":"garbage-collection-1","l":"Garbage Collection","p":["(e.g., by coercing them to an int, and then back again)","(point하는 ptr가 없으니까 나중에 garbage collect해도 되는구나)","= program이 어떻게 실행될지 execution order를 정확히 모르면 모른다. 그러나 적어도, heap에 할당된 memory object를 point하는 ptr가 없다면 해당 allocated block은 사용되지 않는다.","All pointers point to the start of a block","But we can tell that certain blocks cannot be used if there are no pointers to them","Cannot hide pointers","c에서의 garbage collection 구현의 어려움","How does the memory manager know when memory can be freed? 내가 할당한 memory allocation이 runtime시에 언제 free될 것이냐","In general we cannot know what is going to be used in the future since it depends on conditionals","memory int type에 있는 변수 안의 값이 ptr 일수도 아닐수도 있다.","Memory manager can distinguish pointers from non-pointers","memory manager가 할 수 있다고 가정","Must make certain assumptions about pointers","ptr 는 다른 memory obj를 가리키는 address일수도, int일수도 있으나 이를 구분할 방법은 c에서는 없음.","type casting같이 ptr 숨김을 못한다.","어떤 block이든간에 시작을 point함"]},{"l":"Classical GC Algorithms","p":["Mark-and-sweep collection (McCarthy, 1960)","Does not move blocks (unless you also “compact”)","Reference counting (Collins, 1960)","Does not move blocks (not discussed)","Copying collection (Minsky, 1963)","Moves blocks (not discussed)","Generational Collectors (Lieberman and Hewitt, 1983)","Collection based on lifetimes","Most allocations become garbage very soon","So focus reclamation work on zones of memory recently allocated","For more information:","Jones and Lin, “Garbage Collection: Algorithms for Automatic Dynamic Memory”, John Wiley & Sons, 1996. Bryant and O’Hallaron, Computer Systems: A Programmer’s Perspective, Third Edition"]},{"l":"Memory as a Graph","p":["grapy로 표현 : heap memory object로 만든 direct graph","어떤 ds를 만들었는데 heap 안에 있는 object를 stack밖에서 point하는 경우","root node는 heap 안에 있는 것을 가리키는 형상","direct graph :","모종의 자료구조로 인해 binary tree를 heap 안에서 만들었다고 하면 Root로부터 시작하여 heap 안의 object를 point하는 direct graph","어느 순간에 가게 되면 외부에서 가리키는 ptr이 없어지는 경우도 존재.","ex. heap에는 이미 할당되어 있지만 함수가 return되며 point하는 local var이 사라짐","→ not-reachable garbage 생성","heap node는 이런식으로 tree로 표현되지만 실제로는 1dim array : 어떤 부분은 free하고 어떤 부분은 allocated, 어떤 부분은 reachable-not reachable","식별할 수 있다면 reachable하지 않는 놈들을 free하면 됨 : mark and sweep algorithm","We view memory as a directed graph","Each block is a node in the graph / Each pointer is an edge in the graph","Locations not in the heap that contain pointers into the heap are called root nodes (e.g. registers, locations on the stack, global variables) Untitled","A node (block) is reachable if there is a path from any root to that node.","Non-reachable nodes are garbage (cannot be needed by the application)"]},{"l":"Mark and Sweep Collecting","p":["→ not reachable은 allocated되어 있지만 mark bit이 set되어있지 않음","1dim 평면의 array의 처음부터 끝 brk까지 scan하며 mark되지 않은 block에 대하여 free","after mark - rechable한 경우 mark bit을 setting해줌","after sweep - not rechable 들은 free를 해줌 (allocated but not marked)","Allocate using malloc until you “run out of space”","Before mark - free list를 pt하는게 아닌 application 관점에서 앞서의 tree를 구현","Can build on top of malloc/free package","Header에다가 extra bit를 가져가 mark한다","malloc을 지속한다 : 공간이 없을 때까지","mark : 앞서 root에 해당하는 녀석을 인자로 돌려 reachable한 녀석들을 dfs하여 mark bit set","Mark: Start at roots and set mark bit on each reachable block","Recursively Mark를 수행하며 각 block에 reachable한 경우에 한하여 mark해줌","Sweep: Scan all blocks and free blocks that are not marked root","Untitled","Use extra mark bit in the head of each block","When out of space:","공간이 없다 = sbrk를 써서 계속 확장하더라도 malloc이 잘 안되는 경우 memory 공간이 없음"]},{"l":"Assumptions For a Simple Implementation","p":["Application","new(n): returns pointer to new block with all locations cleared","New(n) : heap memory obj를 할당하고 ptr를 return","read(b,i): read location i of block b into register","Read(), block b에서 i번째에 해당하는 값을 읽어 register에 집어넣음","write(b,i,v): write v into location i of block b","write(b,i,v) : block b의 i번째에 v를 쓴다.","Each block will have a header word 앞에는 header word가 있다고 가정하고 collector를 구현하자.","addressed as b[-1], for a block b","Used for different purposes in different collectors","functions/Instructions used by the Garbage Collector","is_ptr(p): determines whether p is a pointer p가 ptr인지 int인지 구분할 수 없지만 구분된다고 가정하자.","length(b): returns the length of block b, not including the header block b에서의 header를 제외한 word개수","get_roots(): returns all the roots"]},{"i":"mark-and-sweep-cont","l":"Mark and Sweep (cont.)","p":["Mark using depth-first traversal of the memory graph","depth-first traversal : Heap node들은 mark bit가 setting되어있지 않기에 ptr인지 아닌지 체크","→ ptr 아니었다면 return, ptr라면 밑으로","markbit set","P의 크기만큼을 보면서 p[i]를 recursive하게 돌아감 → 초록tordls reachable obj에 대해 mark해줌","Sweep using lengths to find next block","P (시작) end (breakpoint)"]},{"i":"conservative-mark--sweep-in-c","l":"Conservative Mark & Sweep in C","p":["c 언어 상 p가 가리키는 것이 memory block 중 ptr block, int block일 수 있음","memory value type를 저장하지 않기에 우리는 구분 불가능했던 것","구현 방법 : block에서 left/right해서 있는 값은 무조건 ptr라고 하고","balenced bt를 만들어 point하여 allocate block을 따라가 mark and sweep한다.","→ conservative하게 정확하게 구분할 수는 없지만 어느정도 determine 한다라고 가정","실제 가리키는게 not allocated이지만 allocated라고 가정해놓고 point","A “conservative garbage collector” for C programs","is_ptr() determines if a word is a pointer by checking if it points to an allocated block of memory","But, in C pointers can point to the middle of a block Untitled","So how to find the beginning of the block?","Can use a balanced binary tree to keep track of all allocated blocks (key is start-of-block)","Balanced-tree pointers can be stored in header (use two additional words)","Left: smaller addresses / Right: larger addresses","(Left / right)를 통해 balanced bt를 구축하게 됏을 때 left가 alloc 안되어 있지만 되어 있다는 block이라고 하면 garbage collection할 때 memory leak이 발생하기는 하나 구현할 수는 있다.","Untitled"]},{"l":"Memory-related perils and pitfalls"},{"i":"memory-related-perils-and-pitfalls-1","l":"Memory-Related Perils and Pitfalls","p":["Dereferencing bad pointers","Reading uninitialized memory","Overwriting memory","Referencing nonexistent variables","Freeing blocks multiple times","Referencing freed blocks","Failing to free blocks"]},{"l":"Dereferencing Bad Pointers","p":["The classic scanf bug"]},{"l":"Reading Uninitialized Memory","p":["Assuming that heap data is initialized to zero"]},{"l":"Overwriting Memory","p":["Allocating the (possibly) wrong sized object","Off-by-one error","Not checking the max string size","Basis for classic buffer overflow attacks","Misunderstanding pointer arithmetic","Referencing a pointer instead of the object it points to"]},{"l":"Referencing Nonexistent Variables","p":["Forgetting that local variables disappear when a function returns"]},{"l":"Freeing Blocks Multiple Times","p":["Nasty!"]},{"l":"Referencing Freed Blocks","p":["Evil!"]},{"i":"failing-to-free-blocks-memory-leaks","l":"Failing to Free Blocks (Memory Leaks)","p":["Slow, long-term killer!","Freeing only part of a data structure"]},{"l":"Dealing With Memory Bugs","p":["Debugger : gdb","Good for finding bad pointer dereferences Hard to detect the other memory bugs","Data structure consistency checker","Runs silently, prints message only on error Use as a probe to zero in on error","Binary translator: valgrind","Powerful debugging and analysis technique","Rewrites text section of executable object file","Checks each individual reference at runtime","Bad pointers, overwrites, refs outside of allocated block","glibc malloc contains checking code","setenv MALLOC_CHECK_ 3"]}],[{"l":"12. Linking"},{"l":"Linking"},{"i":"whats-linking","l":"What’s linking?","p":["A process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed 여러 코드와 데이터를 모아 memory에 load될 수 있고 executable file 하나로 만드는 작업","큰 규모의 프로그램을 한 개의 소스 파일로 구성하는 대신","별도로 editable, compilable smaller module로 나눌 수 있음","edit할 때 단순히 해당 파일을 recompile하고 다른 file을 recompile할 필요 없이 link함.","작은 프로그램을 만든다고 하면 linking이 필요 없지만 큰 프로그램을 만들면 잘게 잘게 기능을 나누어 쪼갤 필요가 있다.","Linking can be performed at compile time, load time, and run time","compile time 시 수행 - src code는 기계어로 translate됨","load time - application program에 의해 수행","run time","Linking is performed automatically by programs called linkers on modern systems","초기에는 수동으로 수행된 linking → 현재는 linker가 대신 수행해줌"]},{"i":"why-bother-learning-about-linking","l":"Why bother learning about linking?","p":["Understanding linkers will help you"]},{"l":"build large programs 큰 프로그램 작성에 도움","p":["Unless you understand how a linker resolve references, what a library is, and how a linker uses a library to resolve references, these kinds of errors will be baffling and frustrating.","발생되는 linker error들에 대한 식견","작은 프로그램 compile하고 linking하는 과정","local + external defined symbol들을 어떻게 reference할 수 있느냐.","Malloc / printf reference : 어떻게 library를 활용하여 reference하느냐","linux에서 직접 link해보면 link error가 많이 뜨는데 이해하기 쉬워질 것"]},{"l":"avoid dangerous programming errors 위험한 에러를 피할 수 있음","p":["Programs that incorrectly define multiple global variables can pass through the linker without any warnings in the default case. The resulting programs can exhibit baffling run-time behavior and are extremely difficult to debug.","global var을 여러 분야에서 잘못 선언 : run-time시에 여러 문제가 생길 수 있음","linker에서 잡아주지 못하는 / linker의 기능과 방식 을 잘 이해하지 못한 상태에서 runtime 때 찾기는 어렵다","debug하기도 어려운 상황에서→ 어떻게 권장하는지를 보고 어떻게 발생하고 회피하는지 알 수 있음"]},{"l":"understand how language scoping rules are implemented","p":["What’s the difference between global and local variables? (전역 vs 지역)","What does it really mean when you define a variable or function with the static attribute?"]},{"l":"understand other important systems concepts","p":["The executable object files produced by linkers play key roles in important systems functions such as loading and running programs, virtual memory, paging, and memory mapping","system의 중요한 여러 개념들을 이해하는 데 도움"]},{"l":"enable you to exploit shared libraries","p":["With the increased importance of shared libraries and dynamic linking in modern operating systems, linking is a sophisticated process that provides the knowledgeable programmer with significant power. 현대 사회에서 중요해진 shared library, dynamic linking의 중요성 → 주요 능력을 제공하는 process","쉬우면서도 간과하는 부분이 많은 linking","For example, many software products use shared libraries to upgrade shrink-wrapped binaries at run time.","shared library : dynamic linking 다양하게 쓰임","smaller하게 된 binary를 runtime때 upgrade","Many Web servers rely on dynamic linking of shared libraries to serve dynamic content.5","많은 sw들은 runtime 시에 linking많이 씀 : service할 때 동적으로 mapping"]},{"l":"Example C Program","p":["각각에 대해서 linking을 수행하여 하나의 executable file","sum이라는 procedure는 sum.c로부터 reference하여 구동시켜 Main 함수에서 integer array"]},{"l":"Static Linking","p":["Programs are translated and linked using a compiler driver:"]},{"l":"Compiler driver","p":["→ ./prog: prog 실행","Assembler (as) main.s→ main.o","C Compiler (cc1) : main.i→ main.s","C preprocessor (cpp) : main.c→ main.i","combine main.o and sum.o along with the necessary object files,to create the binary executable object file","Fully linked","ld 실행 : prog을 생성하기 위해 main.o / sum.o 연결","Linker (ld)","linking해야지 virtual memory 상 어디에 올라가는지 상대적인 offset 부분을 나중에 알 수 있기 때문에, 나중에 relocate되는 obj file이라고 부른다. 그러고 나서 나중에 linking되게 되면 실행 file 생성","Preprocessor, compiler, assembler, linker를 필요에 따라 user 대신하여 호출","Separately compiled relocatable obj files","Shell은 loader라는 OS Function을 호출하여, 실행 파일 prog의 code, data를 memory로 복사하고 control을 program 시작 부분으로 전환한다.","Source File","translates main.i into an ASCII assembly-language file main.s","translates main.s into a binary relocatable object file main.o","translates the C source file main.c into an ASCII intermediate file main.i","Untitled","각 symbol들의 주소, access하는 주소 memory할 때 어디에 올라가는지 VM에서 어디 부분에 올라가는지 등은 잘 정해져 있지 않기 때문에 relocate필요"]},{"i":"why-linkers","l":"Why Linkers?"},{"i":"reason-1-modularity","l":"Reason 1: Modularity","p":["Program can be written as a collection of smaller source files, rather than one monolithic mass. 구조적으로 쪼개서 작은 source file로 만든다 → 내가 필요한 부분들만 쓸 수 있게 하는데 도움이 된다","Can build libraries of common functions (more on this later)","Standard c library, math library : 다른 application에서도 사용 가능","e.g., Math library, standard C library"]},{"i":"reason-2-efficiency","l":"Reason 2: Efficiency","p":["Time: Separate compilation","sum.c code만 수정하고 sum.c만 recompile","monolithic한 프로그램이 아니라면 코드 전체를 모두 compile하는 것보다 더 빨라짐","Change one source file, compile, and then relink.","No need to recompile other source files.","Space: Libraries","Common functions can be aggregated into a single file...","하나의 compile로 만들어질 수 있음","모두다 사용하는게 아니고, 특정한 부분만 사용할 수 있기 때문에 필요한 특정한 부분만 사용하는거기 때문에 필요에 따라 linker를 돌아 사용하는게 효과적","Yet executable files and running memory images contain only code for the functions they actually use.","memory에 다 올라갈 필요가 없음 → powerful software programming"]},{"i":"what-do-linkers-do","l":"What Do Linkers Do?","p":["to make executable file → linker는 두 가지 step task를 수행해야 한다."]},{"i":"step-1-symbol-resolution","l":"Step 1: Symbol resolution","p":["Programs define and reference symbols (global variables and functions):","program 내부에서 여러 symbol을 가져다가 reference","Swap function definition - reference","xp라는 symbol : x라는 variable의 address value","Symbol definitions are stored in object file (by assembler) in symbol table.","Symbol table is an array of structs → Executable file 생성 이전 object file : section에 symbol table이 들어감.","Each entry includes name, size, and location of symbol.","compile시 preprocess다음 c compile하여 obj 파일 만들어질 때 elf라는 file format에서 symbol table 안에 저장되는데 각 symbol마다 크기, 이름, 위치 생성 정보를 가진 table","During symbol resolution step, the linker associates each symbol reference with exactly one symbol definition. symbol이 있으면 각각의 reference가 정확히 하나의 symbol definition과 대응되어야 한다.","cnt가 두 번 initialized -> linker error"]},{"i":"step-2-relocation","l":"Step 2: Relocation","p":["Merges separate code and data sections into single sections","두개의 다른 object file (code/data)를 모아 하나의 section으로 만emsek.","0번지에서 시작하는 code, data section","Executable file로 linux가 만들게 되는데 memory location에 올라가는 절대 주소로 변환 : 실제 가상메모리 주소는 어떻게 할 것이냐","Relocates symbols from their relative locations in the .o files to their final absolute memory locations in the executable.","linker : code/data section을 symbol def과 연결","→ relocate하며 모든 reference를 모두 수정하여 절대주소를 가리키도록 함","relocation entry : symbol에 대한 모든 reference 가 새로운 위치를 가리킬 수 있게 해 줌","Updates all references to these symbols to reflect their new positions.","Let’s look at these two steps in more detail...."]},{"i":"three-kinds-of-object-files-modules","l":"Three Kinds of Object Files (Modules)"},{"i":"relocatable-object-file-o-file","l":"Relocatable object file (.o file)","p":["Contains code and data in a form that can be combined with other relocatable object files to form executable object file.","Each .o file is produced from exactly one source (.c) file","Main.o, .o","code, data를 가지고 있는데 다른 relocatable file과 같이 compile되어 실행 file을 만들기 위한 code, data를 가진 object file"]},{"i":"executable-object-file-aout-file","l":"Executable object file (a.out file)","p":["Contains code and data in a form that can be copied directly into memory and then executed.","명명 of a.out","BELL Lab에서 compile하고 executable file 이름을 지정하지 않을 때 a.out으로 명명","특정한 의미는 없음"]},{"i":"shared-object-file-so-file","l":"Shared object file (.so file)","p":["Special type of relocatable object file that can be loaded intomemory and linked dynamically, at either load time or run-time.","Called Dynamic Link Libraries (DLLs) by Windows13"]},{"i":"executable-and-linkable-format-elf","l":"Executable and Linkable Format (ELF)","p":["Standard binary format for object files","One unified format for","Relocatable object files (.o),","Executable object files (a.out)","Shared object files (.so)","Generic name: ELF binaries","Untitled"]},{"i":"elf-header-16-b","l":"Elf header (16 B)","p":["Describes word size, byte ordering, file type (.o, exec, .so), machine type, file offset of section header table, etc."]},{"l":"Section header table","p":["Offsets and sizes of each section","Untitled"]},{"i":"text-section","l":".text section","p":["Code (the machine code of the compiledprogram)","compile된 program의 기계어 code가 들어가 있음","c compile후 assembly에 의해 기계어 코드 (add, multiply, load, store에 대한 assembly에 대한 기계어 코드가 들어가 있음)"]},{"i":"rodata-section","l":".rodata section","p":["Read only data: jump tables for switch","Read only data section : read only data, jump table, format string 가지고 있음"]},{"i":"data-section","l":".data section","p":["Initialized global variables","Initialized global var : int count = 6;","Local variable static : static int a =3;"]},{"i":"bss-section","l":".bss section","p":["Uninitialized global variables","아직은 yet initialized : 위치만을 가지고 잇음 (공간 할당 x)","이름 : “Block Started by Symbol”, “Better Save Space”","initialize된 global var을 구분함으로서 공간을 할당하지만 .bss는 공간을 할당하지 않아 공간 효용성을 구분할 수 있음 →Has section header but occupies no space","나중에 memory에 load될 때는 0으로 초기화 : 그 때의 메모리 공간 생성","Untitled"]},{"i":"symtab-section","l":".symtab section","p":["Symbol table with info. about functions and global variables (procedures and static variable names) that are defined and referenced in the program-"]},{"i":"reltextsection","l":".rel.textsection","p":["Relocation info for .text section","Addresses of instructions that will need to be modified in the executable","Instructions for modifying.-"]},{"i":"reldatasection","l":".rel.datasection","p":["Relocation info for .data section","Addresses of pointer data that will need to be modified in the merged executable-"]},{"i":"debug-section","l":".debug section","p":["Info for symbolic debugging (gcc -g)ELF header.text section.rodata section.data section.bss section.symtab section.rel.txt section.rel.data section.debug sectionSection header table18"]},{"l":"Symbols and Symbol Tables","p":["Each relocatable object module, m, has a symbol table","각각의 relocatable object (module) : 어떠한 module에 의해 reference / define되어 있는 symbol에 대한 정보를 가진 symbol table이 가진 정보","The symbol table contains information about the symbols that are defined and referenced by m","In the context of a linker, there are three different kinds of symbols:","Global symbols","External symbols","Local symbols"]},{"l":"Linker Symbols"},{"l":"Global symbols","p":["Symbols defined by module m that can be referenced by other modules.","E.g.: non-static C functions and non-static global variables.","다른 module에 의해 reference될 수 있는 global variable"]},{"l":"External symbols","p":["Global symbols that are referenced by module m but defined by some other module.","module에 의해서 reference되는 symbol이지만 다른 module에 의해서 defined되어 있는 것","a.c입장에서 b.c.의 count symbol"]},{"l":"Local symbols","p":["Symbols that are defined and referenced exclusively by module m.","E.g.: C functions and global variables defined with the static attribute.","Local linker symbols are not local program variables 20"]},{"l":"Local linker symbols vs. Local program variables","p":[".symtab does not contain any symbols that correspond to local non-static program variables","var 중 non static variable들은 Symbol table에 들어가지 않음 / linker에 연관 x","Local var : stack / Local symbol : symbol table에 들어감","Local non-static program variables are managed at run time on the stack and are not of interest to the linker","See more details in next slides..."]},{"i":"step-1-symbol-resolution-1","l":"Step 1: Symbol Resolution","p":["Untitled"]},{"i":"local-symbols-1","l":"Local Symbols","p":["Local static var : global variable -> .data","단 local var이기 때문에 함수를 다시 호출하게 되면 재접속 가능 Local nonstatic var : static x, 일반 local var -> @stack","f, g에서 같은 variable x를 쓰지만 다른 symbol X.1, x.2 이런식으로 compiler가 놓고 compiler가 unique한 이름을 가지도록 함.","Local non-static C variables vs. local static C variables","local non-static C variables: stored on the stack","local static C variables: stored in either .bss, or .data","단 local var이기 때문에 함수를 다시 호출하게 되면 재접속 가능","Local nonstatic var : static x, 일반 local var -> @stack","Untitled","Compiler allocates space in .data for each definition of x","Creates local symbols in the symbol table with unique names,","f, g에서 같은 variable x를 쓰지만 다른 symbol→ x.1, x.2 이런식으로 compiler가 놓고 compiler가 unique한 이름을 가지도록 함.","e.g., x.1 and x.2"]},{"l":"How Linker Resolves Duplicate Symbol Definitions","p":["Program symbols are either strong or weak","Strong: procedures and initialized globals","initialize되어 있는 variable","Weak: uninitialized globals","uninitialize되어 있는 variable","Untitled"]},{"i":"linkers-symbol-rules","l":"Linker’s Symbol Rules","p":["-> link error","compiler가 보고 나서 foo=5(p1.c) / foo=10(p2.c)","compiler가 보고 나서 foo=5(p1.c) / foo=10(p2.c) -> link error","Each item can be defined only once","Otherwise: Linker error","p2에서 foo 접근 = p1에서의 foo 접근","P2의 foo : weak-> p1의 foo : strong을 쫓아감","P2의 foo : weak-> p1의 foo : strong을 쫓아감 p2에서 foo 접근 = p1에서의 foo 접근","References to the weak symbol resolve to the strong symbol","Rule 1: Multiple strong symbols are not allowed","rule 1. : 만일 symbol이 strong하다 - 단 한번만 선언 가능","Rule 2: Given a strong symbol and multiple weak symbols, choose the strong symbol","Rule 3: If there are multiple weak symbols, pick anarbitrary one","Weak가 strong을 쫓아간다.","같은 게 strong이면 안됨","둘다 weak면 compiler가 임의로 설정","만일 symbol이 strong하다 - 단 한번만 선언 가능"]},{"l":"Linker Puzzle","p":["Untitled","link error - 모종의 이유로 version이 달라 뜨는 error","둘 중에 무엇을 선택할 지 모름 (weak)","1->2, : y를 overwrite하지 않음 / 2->1 : overwrite","→ ‘might’라는 용어 사용 : 해당 xy가 다른 strong symbol reference할 수 있기 때문이다","double로 선언한 x (8byte) - integer 로 원래 선언된 형태 → y에게도 악영향","Nightmare scenario : 2 identical weak structs, compiled by different compilers with different alignment rules (compiler dependent)","link error : 모종의 이유로 version이 달라 뜨는 error"]},{"i":"two-weak-definitions-of-x-rule-3","l":"Two weak definitions of x (rule 3)","p":["Run-time bugs","Can cause some insidious run-time bugs that are incomprehensible to the unwary programmer","compiler error가 발생하지는 않는데","둘 다 uninitialized된 형태, f 수행 후 15212로 변화 Untitled"]},{"i":"another-example-rule-2","l":"Another example (rule 2)","p":["Subtle and nasty run-time bugs!","On an x86-64/Linux machine, doubles are 8 bytes and ints are 4 bytes","Suppose the address of x is 0x601020 and the address of y is 0x601024","The assignment x = 0.0 in lin6 6 will overwrite the memory locations for x and y with the double-precision floating-point representation of negative zero! Untitled","Compile error 전혀 안 뜸","나도 모르게 y값이 바뀜, 그러나 link error를 runtime때 찾기에는 너무 어렵다","→ 주의깊게 익혀야 한다.","library에서 우연치 않게 같은 symbol을 써서 이상하게 돌아가는 경우도 발생가능","나도 모르게 y값이 바뀜","link error를 runtime때 찾기에는 너무 어렵다","-> 주의깊게 익혀야 한다."]},{"l":"Global Variables","p":["Avoid if you can","Otherwise","Use static if you can","data 에서 선언되지만 해당 함수 내에서만 접근 가능","Initialize if you define a global variable : initialize해서 가급적 문제가 발생하지 않도록 함.","Use extern if you reference an external global variable","Initialize된 형태로 써라 (쓰지 않을 수 있다면 쓰지 마라)","→ 예기치 않은 runtime bug에 빠지지 않도록 해라.","static 선언","initialize해서 가급적 문제가 발생하지 않도록 함.","extern","예기치 않은 runtime bug에 빠지지 않도록 해라."]},{"i":"step-2-relocation-1","l":"Step 2: Relocation","p":[".Text / .Data",".Text / .Data : 각 symbol에다 address assign하는 것에 대해 알아보자","₩main.c , .c₩ : 두 개의 object module을 병합하여 실제 각각의 symbol에 run time address를 부여해주는 작업 Untitled","At this point, the linker knows the exact sizes of the code and data sections in its input object modules.","ELF File Format","linker가 symbol resolution step에 따라 resolve하게 되면 모든 symbol reference는 오직 한개의 symbol definition에 associate된다","Merges the input modules and assigns run-time addresses to eachsymbol","Moe details will come in the next slides...","Now, next step is the relocation step (Step 2)","obj file 생성하게 되면 code, data에 대한 정확한 정보를 알게 됨","Once the linker has completed the symbol resolution step, it has associated each symbol reference in the code with exactly one symbol definition","relocation","relocation : 이 세 가지를 하나로 병합하는 과정","relocation step","Step1: Symbol resolution","Symbol resolution 복습","각 symbol에다 address assign하는 것에 대해 알아보자","내가 penn university에 있다가 다른 회사 사무소 주소로 바귐","내가 penn university에서 졸업하고 job을 구하면 relocate : relocate negotiation (주소 바뀌는 것에 대한 signing bonus 등)","내가 penn university에서 졸업하고 job을 구하면 relocate : relocate negotiation (주소 바뀌는 것에 대한 signing bonus 등) - 내가 penn university에 있다가 다른 회사 사무소 주소로 바귐","내가 현재 접근하는 변수의 주소를 모르기 때문에 relocate하는 과정 : 주소 찾아서 assign해줌","두 개의 object module을 병합하여 실제 각각의 symbol에 run time address를 부여해주는 작업","만일 그렇지 않다면 link error","이처럼, 내가 현재 접근하는 변수의 주소를 모르기 때문에 relocate하는 과정 : 주소 찾아서 assign해주는 작업"]},{"l":"Relocation Entries","p":["object module : Compiler 내 assembler가 기계어 code를 만들어 내는데 이를 obj module","When an assembler generates an object module, it does not know where the code and data will ultimately be stored in memory.: 이를 생성해 낼 때, 1. code, data가 나중에 executible file 생성하는 시점에서 memory 어디에 적재될지 모름","Nor does it know the location of any externally defined functions of global variables that are referenced by the module.","main.c에서 sum이라는 함수는 외부에서 externally defined : sum이라는 함수를 호출할 때 그 위치가 어디인지 모른다.","So, whenever the assembler encounters a reference to an object whose ultimate location is unknown, it generates a relocation entry that tells the linker how to modify the reference when it merges the object file into an executable.","→ 결국에는 location 어디인지 모르는 (global var, external function)은 알려져 있지 않기 때문에 relocation entry라고 해서 하나씩 만든다.","ELF file format의 .rel.text / .rel.data에 들어간다","Linker에게 ‘이 주소를 잘 모르니까 나중에 다른 obj와 merge되어 executable file만들 때 이 reference를 수정해야 한다’고 알려줌",".rel을 보고 symbol들이 address가 확인되지 않음을 보고 linking 과정에서 병합하며 그 address를 채워준다","Relocation entries for code are placed in .rel.text.","Relocation entries for data are placed in .rel.data. 32"]},{"l":"Relocated .text section","p":["Untitled","Relocation: 앞의 obj module들을 병합한 다음에 각 symbol에 대해 runtime address","(Vm address O, not physical) E8 05 00 00 00","instruction 수행할 때 relative","현재 주소 : PC는 항상 다음 주소 (명령어 fetch하는 그 순간에) PC가 가리키는 주소에 5 더하면 의 주소가 나온다 :","상대적인 주소 : detail은 assembler, linking / 2 path scanning을 하기 때문에"]},{"l":"Loading Executable Object Files","p":["Untitled","ELF 보면 되고 process address space : 0x400000~ 2^ 48 -1 (process)","kernel","shaerd library : 동적으로 linking 만들어지는 library, API memory map을 위함","Heap : break point만큼 heap의 크기","segment : r/w data","Shared memory 하나 올라오고 Application a, b 뜰 때 필요에 따라 reference함","(그냥 copy하는게 아님)","c가 shared library라고 할 때 ptr로 그냥 갈 수 있기 때문에 c는 하나만 있으면 되어 duplicate하지 않아도 됨","memory mapped region에 대한 ptr가 들어가있는 것."]},{"l":"Packaging Commonly Used Functions","p":["How to package functions commonly used by programmers?","자주 쓰는 함수 모아둠 - library 형태로 모아 둠","Math, I/O, memory management, string manipulation, etc.- Awkward, given the linker framework so far:","memory management : malloc, calloc 등 모아서 자주 쓰니까 어떻게 하나의 패키지로 쓰는가","Option 1: Put all functions into a single source file","모든 함수들을 코드들에 집어넣음","Programmers link big object file into their programs","Space and time inefficient","생성되는 executable code 자체가 많이 커짐 → 시간, 공간 많이 차지함","Option 2: Put each function in a separate source file 2. modular 접근 방법처럼 기능 별로 file들을 쪼갠다","각 file들에는 특정 기능 수행하는 fn들을 따로 따로 만들어 줌","필요한 것만 링킹 - 모든 소스 파일을 다 집어넣을 필요 없음","Programmers explicitly link appropriate binaries into their programs","More efficient, but burdensome on the programmer36","효율적이지만 프로그래머가 이해해주어야 함"]},{"i":"old-fashioned-solution-static-libraries","l":"Old-fashioned Solution: Static Libraries","p":["Static libraries (.a archive files)","Concatenate related relocatable object files into a single file with an index (called an archive).","Enhance linker so that it tries to resolve unresolved external references by looking for the symbols in one or more archives.","If an archive member file resolves reference, link it into the executable.","static linking - static library","archive file","Object files 들을 concatenate해서 하나의 file로 만듬","index를 통해 archive 안에 sum, average 등의 함수를 찾아서 참조할 수 있도록 함","archive 안에서 symbol 찾아보고 나서 실행 file linking"]},{"l":"Creating Static Libraries","p":["함수별로 모듈만들어 하나의 archive로 만들어 static link 만들 수 있다. Untitled","Archiver allows incremental updates-","Recompile function that changes and replace .o file in archive.38"]},{"l":"Commonly Used Libraries","p":["libc.a(the C standard library)","4.6 MB archive of 1496 object files.","I/O, memory allocation, signal handling, string handling, data and time, random numbers, integer mathlibm.a (the C math library)","2 MB archive of 444 object files. Untitled"]},{"l":"Linking with Static Libraries","p":["libvector.a","41page - addvec.o는 무엇을 의미하는가:","Main 함수에서 사용하는 addvec","다 올리는 게 아니라 archive라는 utility를 통해서 object concatenate하는 건데 addvec만 사용하기에 이거만 빼서 link한다는 의미이다.","static link : 사용되는 object file 100개를 모아두고 archive처럼 code generation할 때 다 모아서 symbol reolution하고 link하는 것임.","static linking에서 duplication생기는 이유","똑같이 main함수 생성해서 addvec(x,y,z, 3)을 선언해서 넣었다고 하자. 이 코드들이 생성될 때 addvec.o가 proc2에 포함되어 있다. 나중에 또 proc3을 생성할 때에도 addvec.o가 들어가 있다."]},{"l":"Using Static Libraries"},{"i":"linkers-algorithm-for-resolving-external-references","l":"Linker’s algorithm for resolving external references:","p":["symbol resolving algorithm : linker가 사용하는 algorithm","Scan .o files and .a files in the command line order.","During the scan, keep a list of the current unresolved references.","As each new .o or .a file, obj, is encountered, try to resolve each unresolved reference in the list against the symbols defined in obj.","If any entries in the unresolved list at end of scan, then error."]},{"i":"problem","l":"Problem:","p":["Untitled","Command line order matters!","Moral: put libraries at the end of the command line.unix> gcc -L. libtest.o -lmineunix> gcc -L. -lmine libtest.olibtest.o: In function main': libtest.o(.text+0x4): undefined reference to libfun'42","Compiler를 통해 example - Gcc -L : object file에서 library에 있는 file을 찾는 것","Test file + library : test file 안에 선언되어 있는 걸 external reference해서 없으면 library를 찾아본다","Test라는 file obj module안에서 없으면 library안에 있으면 해결되기 때문에","library + test file 넣으면 error가 뜨게 됨. (reference 안되어 있음)","-lmine에는 있지만 libtest.o에는 없어서 그 다음으로 넘어가야 하는데 그 다음 file이 존재하지 않으므로 error 발생","command line 순서대로 수행 * order가 되게 중요 → library는 맨 뒤","scanning하면서 현재 resolve 안된 reference 기록 그리고 각각에 대해 unresolved reference를 뒤에서 찾아본다 : 있으면 resolve, 없으면 error"]},{"i":"modern-solution-shared-libraries","l":"Modern Solution: Shared Libraries"},{"i":"static-libraries-have-the-following-disadvantages","l":"Static libraries have the following disadvantages:","p":["dynamic library = shared library","Compile time때 static linking을 통한 linking","지금 돌아가는 executable file이라든지 둘 다 library를 가져다 사용하게 되면 static하게 linking했기 때문에 static이던 running중이던 동일한 file을 본인의 executable에 포함 → 중복된 contents","Duplication in the stored executables (every function needs libc)","Duplication in the running executables","Minor bug fixes of system libraries require each application to explicitly relink","bug 수정 :application 수정하고 linking 다시 해야 함"]},{"i":"modern-solution-shared-libraries-1","l":"Modern solution: Shared Libraries","p":["Object files that contain code and data that are loaded and linked 해당 library 부분만 수정해서 되는게 아니라 application을 relink시켜 또 다시 link해야 함","into an application dynamically, at either load-time or run-time","load time, runtime에 동적으로 shared library가 linking됨","Also called: dynamic link libraries, DLLs, .so files","dynamic library = shared library","Compile time때 static linking을 통한 linking","지금 돌아가는 executable file이라든지 둘 다 library를 가져다 사용하게 되면 static하게 linking했기 때문에 static이던 running중이던 동일한 file을 본인의 executable에 포함 → 중복된 contents","bug 수정 :application 수정하고 linking 다시 해야 함","해당 library 부분만 수정해서 되는게 아니라 application을 relink시켜 또 다시 link해야 함","shared: load time, runtime에 동적으로 shared library가 linking됨","Library를 여러개 dynamically 사용할 수 있어서 shared","Loading time, rumtime이 될 수 있음"]},{"i":"dynamic-linking-can-occur-when-executable-is-first-loaded-and-run-load-time-linking","l":"Dynamic linking can occur when executable is first loaded and run (load-time linking).","p":["Common case for Linux, handled automatically by the dynamic linker ( ld-linux.so).","Standard C library ( libc.so) usually dynamically linked."]},{"i":"dynamic-linking-can-also-occur-after-program-has-begun-run-time-linking","l":"Dynamic linking can also occur after program has begun (run-time linking).","p":["In Linux, this is done by calls to the dlopen() interface.","Distributing software.","High-performance web servers. Runtime library interpositioning."]},{"i":"shared-library-routines-can-be-shared-by-multiple-processes","l":"Shared library routines can be shared by multiple processes.","p":["More on this when we learn about virtual memory 44"]},{"l":"Dynamic Linking at Load-time","p":["Untitled","static link : addvec, multvec library 모두 main2.o에 concatenate했어야 했음","dynamic link : 사용되는 function 중 main2가 reference하겠다는 note정도만 partly 저장","그리고 나서 실제 program 실행할 때 library 해당하는 external reference 되어 있는 name들을 resolve하면서 나중에 loading할 때 dynamic linker에 의해 memory에 올라갈 때 비로소 shared library가 이어짐.","(둘 다 memory에 load되어 있을 때)"]},{"l":"Dynamic Linking at Run-time","p":["dlopen을 사용해서 shaerd library 선언하고 dlsym을 통해 addvec을 pointer로 넘거받음","그리고 그 함수를 가지고 원래 있는 함수처럼 사용","code 실행할 때 linking하겠다 : runtime","필요에 따라 memory에 그 때 그때 옮긴다"]},{"l":"Linking Summary","p":["Linking is a technique that allows programs to be constructed from multiple object files.-","여러 개의 object로 하나의 file을 만들 때 사용됨","Linking can happen at different times in a program’s lifetime: 언제 하느냐에 따라 /방법에 따라 여러 많은 error들을 확인하여 resolve할 수 있음","실제 memory 사용량, 실행 시간 등의 장단점을 구분할 수 있음","Compile time (when a program is compiled)","Load time (when a program is loaded into memory)","Run time (while a program is executing)-","Understanding linking can help you avoid nasty errors and make you a better programmer."]},{"i":"713-case-study-library-interpositioning","l":"7.13. Case study: Library interpositioning","p":["Library interpositioning : powerful linking technique that allows programmers to intercept calls to arbitrary functions","Interpositioning can occur at:","Compile time: When the source code is compiled","Link time: When the relocatable object files are statically linked to form an executable object file","Load/run time: When an executable object file is loaded into memory, dynamically linked, and then executed."]},{"l":"Some Interpositioning Applications","p":["Behind the scenes encryption","Characterize call sites and arguments to functions","Code in the SPDY networking stack was writing to the wrong location","Compile time","Confinement (sandboxing)","Count number of calls to functions","Debugging","Detecting memory leaks","Developer가 기존의 function들을 본인의 function으로 intercept하여 실행하고 다시 돌아올 수 있도록 하는 기법","executable file 만들 때","Generating address traces52","In 2014, two Facebook engineers debugged a treacherous 1-year old bug in their iPhone app using interpositioning","Link time","Load, run time","Malloc tracing","Monitoring and Profiling","obj file이 load될 때 동적 link","Security","Solved by intercepting calls to Posix write functions ( write, writev, pwrite)","Source: Facebook engineering blog post at https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/","src code compile 될 때 interpositioning. Malloc함수 자체를 내가 짠 코드로 interpositioning"]},{"l":"Example program","p":["32byte 할당하여 tracking","compile time에 mymalloc, myfree로 대치","지금 배우고 있는 interposition technique","compile, link, loadtime 때 할 수 있다.","Goal: trace the addresses and sizes of the allocated and freed blocks, without breaking the program, and without modifying the source code.","Three solutions: interpose on the lib malloc and free functions at compile time, link time, and load/run time."]},{"l":"Compile-time Interpositioning","p":["mymalloc code","C library에서 제공해 주는 malloc을 사용한 후 그 다음에 무엇을 할 것이냐 : 기존 c library에서 제공하는 malloc을 사용하는 게 아니라 내가 작성한 mymalloc, myfree로 replace (@compile time)","-> 즉, 현재 mymalloc은 기존의 malloc의 wrapper함수처럼 쓰여지는데 앞에 있던 코드에서 malloc을 compile time때 mymalloc/myfree으로 대치되어 실행하도록 할 수 있다.","mymalloc/myfree trace하기 위해서 printf code","기존에는 malloc에다 ptr을 가져다가 안에서 mymalloc으로 대치함으로써 실제 malloc을 내부적으로 call하지만 tracing위한 printf 삽입하여 - 어떤 block이 alloc/free되었는지 확인","preprocessing","compilie할 때 내부의 malloc이 mymalloc / free가 myfree로 바뀌어 구동되게 된다.","(linux print 결과)","int.c, mymalloc.c 같이 compile","원래는 아무것도 print하지 않는데 mymalloc, myfree를 통해서 원하는 정보를 tracing할 수 있게 됨. -> 이 주소에다가 우리가 allocate했음을 알고 vm주소를 deallocate했음을 확인할 수 있음"]},{"l":"Link-time Interpositioning","p":["linktime 때 하는 경우","→ object를 만들고 Wl option을 주고 —wrap, malloc/free","The -Wl flag passes argument to linker, replacing each comma with a space.","-wl flag 자체가 argument를 linker에게 넘겨주어 각각의 comma로 되어 있는 것을 space로 바꾸어 대치하라는 command","The --wrap_malloc arg instructs linker to resolve references in a special way:","나중에 —wrap,malloc/free를 gcc compiler에게 넘겨줌으로서 linker에 이야기 : reference되어 있는데 Linker에게 gcc compilier가 이런 식으로 resolve하라고 만든다.","malloc → wrap malloc","Real malloc→ malloc","Refs to malloc should be resolved as __ wrap_malloc","Refs to __ real_malloc should be resolved as malloc","→ link time에 그 값을 가져다 reserve한 다음 원하는 대로 interposition"]},{"i":"loadrun-time-interpositioning","l":"Load/Run-time Interpositioning","p":["Load/runtime interpositioning","dlsym : Library malloc의 address를 받아오기 위함","mallocp(size) : malloc이라는 wrapper 함수와 free라는 wrapper 함수가 있는데 나중에 동적으로 malloc이라는 wrapper함수에서 동적으로 malloc이 호출되는 그 순간에 malloc의 ptr address를 return하고 이를 가지고 print하게 하는 방법","동적으로 interpositioning을 malloc./ free","동일하게 free함수 호출했을 때 address를 받아오고 free를 한다음 printf를 통해 ptr값에 해당하는 heap에 있는 address 공간을 free","The LD_PRELOAD environment variable tells the dynamic linker to resolve unresolved refs (e.g., to malloc) by looking in mymalloc.so first.","‘LD Preload 환경 변수’를 통해 내가 찾고자 하는 함수를 code 안에서 찾을 수 있음.","순차적으로 찾고 동적으로 실행되는 그 때, 앞에 print하고자 하는 value들과 size를 print하고 free하며 끝남","환경 변수가 dynamic link에게 mymalloc.so file (shared library)를 찾아보고 malloc으로 대체할 수 있도록 하는 역할을 수행함"]},{"l":"Interpositioning Recap","p":["Compile Time","compile time : macro 확장처럼 mymalloc","Apparent calls to malloc/free get macro-expanded into calls to mymalloc/myfree","Link Time","link time : linker에게 trick을 불러 이름 resolution을 바꾸어 준다","Use linker trick to have special name resolutions","malloc → __wrap_malloc","__real_malloc→ malloc","Load/Run Time","load/run time : dynamic linking을 통해서 실제 malloc, free를 다른 이름으로 load할 때 대치하게 함으로서 원하는 interpositioning을 수행할 수 있음","Implement custom version of malloc/free that use dynamic linking to load library malloc/free under different names","→ 세 가지 방법 중 load/runtime, compile time때 많이 수행. 물론 compile의 경우 preprocess 단계에서 내 것으로 가로채기 할 수 있으나 다 같이 compile해야 하는 문제점","load/runtime의 경우에는 이에 반해 따로 compile할 필요 없고, so file을 찾도록 하여 내가 작성한 함수로 interpositioning 기술을 적용할 수 있다"]}],[{"i":"13-virtual-memory-concepts","l":"13. Virtual Memory: Concepts"},{"l":"Address spaces"},{"l":"A System Using Physical Addressing","p":["Untitled","address space : 주소 공간","process가 보는 address space -> virtual address","Physical memory가 보는 -> physical address","CPU입장에서 보자.","CPU가 main memory 접근을 하게 되면 CPU가 addressing하는 주소는 physical address에 해당하는 주소에 있는 data를 load/store할 수 있게 한다","ex. Physical memory고 load 를 통해 word를 가지고 옴","→ Used in “simple” systems like embedded microcontrollers in devices like cars, elevators, and digital picture frames Physical address (PA) CPU 4 3 ... CPU가 볼 때 물리적으로 load/store하며 수행하는 simple한 system에서 활용","VM지원하지 않는 경우에는 physical memory로 활용 (VM 개념자체가 없다)"]},{"l":"A System Using Virtual Addressing","p":["Untitled","CPU에서 virutal addreessing : 접근하는 주소가 virtual address (Not Physical addressing)","MMU : (memory managing unit) : 4100번지에서 load/store한다고 하면 physical address로 변환해 주는 HW (CPU안에 들어가 잇음)","Microcontrolloer 처럼 사실 CPU가 굉장히 간단했는데 VM 해주는 system에서는 CPU chip 자체가 앞에 있는 것 보다 복잡해졌는데, virtual address를 physical address로 변환해주는 역할을 MMU에서 수행(4100(VA) - 4(PA))","Used in all modern servers, laptops, and smart phones","One of the great ideas in computer science M-1: ..."]},{"i":"address-spaces-1","l":"Address Spaces","p":["\\{0, 1, 2, 3 ... \\}","\\{0, 1, 2, 3, ..., M-1\\}","\\{0, 1, 2, 3, ..., N-1\\}","ex. $n=4$면 $N = 2^ 4 = 16$이므로 {0 ~ 15}까지 VA로 표현됨","Linear address space:","n개의 bit로 표현한다고 하면 N = 2^ n만큼으로","Ordered set of contiguous non-negative integer addresses","Physical address space:","Set of M = 2m physical addresses","Set of N = 2n virtual addresses","VA>PA인 경우가 많음 (일반 modern PC에서는)","VA를 PA로 표현하기 위한 N > M (N!=M)","Virtual address space:","물리적인 주소로 표현","순서화 되어 있는 음수가 아닌 continguous한 정수 주소","어떻게 va-> pa 변환될까?일단 정의부터 살펴보자."]},{"i":"why-virtual-memory-vm","l":"Why Virtual Memory (VM)?","p":["(의문) Linear address 그냥 쓰면 되는데 왜 VA/PA 쓰는 것일까?","→ 다른 process의 memory와 interference (접근 못하게) 방지","0~ 특정한 값까지 동일하게","address space를 각 process마다 자신의 address space만 사용하게 고립시키자 :서로 isolate되어 있어 서로의 영역에 대해 접근할 수 없게 한다.","Each process gets the same uniform linear address space","Isolates address spaces","kernel은 접근할 수 있지만 process끼리는 서로 접근 못하게 하고 process는 kernel 정보를 touch하지 못하게 하여 access/modify 못 하게 해주기 위해 필요한 기술 중 하나.","One process can’t interfere with another’s memory","Simplifies memory management","Use DRAM as a cache for parts of a virtual address space","User program cannot access privileged kernel information and code 6","Uses main memory efficiently DRAM을 좀 더 효과적으로 사용하기 위하여 VM 사용","VA에 해당하는 모든 주소 공간에 있는 것들을 모드 memory에 올려놓을 필요는 없고, 자주/많이 접근되는 부분들만 VA일부로 하여 올려두겠다. DRAM은 정말 비싼 자원이기에 정말 필요한 것만 올려두는 역할을 수행하도록 한다.","VA의 일부만 DRAM에 올려 둔다 : process 공부할 때 text/ data /heap/ stack도 있고, 실제 process가 보는 virtual한 space","그냥 물리적 주소였다면 그냥 memory mapping을 하면 됨","모든 process가 자기가 접근하는 VA의 값을 0~ 특정 공간까지 관리할 수 있도록 해 주자","실제 program이 수행되면 .text, .data, .heap, .stack이 있을 것이고 중간에 memory map이 존재할 것이다.","프로그램이 실행되면 text나 data의 경우에도 time의 축에서 VM의 모든 구역을 다 memory에 올려둘 필요 없이 필요에 따라 DRAM에 올려 둔 main memory 공간을 cache: 특정 w time 구간동안 접근."]},{"l":"VM as a Tool for Caching","p":["![Untitled](13/Untitled 2.png)","= 어떤 process가 있다고 하면 contiguous한 linear addreess (0~)","4KB/8KB page : 동일한 page들을 가상 주소가 disk에 mapping되어 있는 연속된 n개의 byte array로 표현한다고 가정하고 생각을 해 보면 실제 main memory에 올라온 physical memory 영역에서는 cached 부분만 올라옴","conceptually, process가 실제 memory에 올라와 구동되게 되는데, 개념적으로 VM이라는 것은 disk 공간에서 n개의 연속된 byte array로 보겠다는 것이다.","Conceptually, virtual memory is an array of N contiguous bytes stored on disk.","DRAM Cache : disk에 있다고 하면 (virtual page )","main memory에 있는 건 DRAM에 있는 disk 주소 공간의 cache (physical page)","process가 보는 memory = VM","The contents of the array on disk are cached in physical memory (DRAM cache)","These cache blocks are called pages (size is P = 2p bytes)","virtual memory를 cacheingg하기 위한 tool이라고 볼 수 있다!","개념적으로 어떻게 표현할 것인가","그리고 실제 main memory에 있는 공간은 : VM에 0번지 ~ N-1번지 까지 N개의 page가 있었다고 하면, PM에 0 ~ M-1번지, M<N","물리적 메모리를 가져다 가상 메모리의 cache처럼 본다.","실제 가상 memory의 특정 page들이 사용되서 main meory에 mapping되어 올라와 있는 경우에 다음처럼 보인다. 나머지는 empty된 상태이다.","활성화된 active page들만 memory에 올라와 있음"]},{"l":"DRAM Cache Organization","p":["(1) write through","(2) write back","(L1, L2): cpu chip 안에 있어서 on chip cache","(L3): off chip cache - 바로 밖에 붙어 있음","Any VP can be placed in any PP","cached page에 대해 mapping function 관리","Consequences","CPU 밖의 main memory를 이야기 중.","CPU안에서 instruction fetch할 때 활용","Disk is about 10,000x slower than DRAM","DRAM : CPU 밖 memory, l3 옆 가장 붙어 있는 memory","DRAM cache organization driven by the enormous miss penalty","DRAM is about 10x slower than SRAM","Fixed 크기의 block : page / block이라고 이야기함","Fully associative","Highly sophisticated, expensive replacement algorithms","HW로도 구현 : main memory중 어떤 memory에 cache한다고 할 때 누구를 쫓아내는가 등은 실제 program이 실행 될 때 cycle을 많이 소요 -> HW로 faster 구현","Large page (block) size: typically 4 KB, sometimes 4 MB","page는 통상적으로 4KB (가끔 4MB)","PP를 씀과 동시에 같이 쓸 것이냐","PP에 먼저 쓰고 나중에 evict할 때 VP와 동기화 할 것이냐","PP에서 cached page 제외 나머지 empty공간을 내가 못 쓴다고 하면 다른 녀석을 가져다 caching하게 될 때 누군가를 쫓아내야 함 -> 굉장히 복잡하지만 그 알고리즘도 overhead가 됨","Requires a “large” mapping function – different from cache memories","SRAM Cache : CPU chip안에 있는 processor cache가 hw적으로 설계됨","SRAM Cache는 CPU안에 있음","SRAM>DRAM>Disk","Too complicated and open-ended to be implemented in hardware","virtual page들을 physical page로 mapping할 수 있는데 어느 VP도 어느 PP로 들어갈 수 있다. = CPU Cache는 VP가 물리적 slot에 어디나 들어가도 된다","VM 개념을 도입했는데 실제 구현하려면","write 하게 되면 cache에 있는 page가 있어 실제 disk공간에 있는 page들인데","Write-back rather than write-through 9","먼저 DRAM(cache)에 있는 것을 써 놓고 나중에 disk 공간에 있는 page가 evict될 때 VP와 동기화하여 씀"]},{"i":"enabling-data-structure-page-table","l":"Enabling Data Structure: Page Table","p":["(PM) 실제 physically mapped : cached 영역 (1,2,7,4) to PP 0,1,2,3","(VM) unallocate / allocate되어 있지만 아직 cached 안 됨","→Disk공간이라고 봐도 되고 page table을 통하여 주소 변환을 해 주는 역할을 감당하게 된다.","A page table is an array of page table entries (PTEs) that maps virtual pages to physical pages.","CPU 개수랑은 완전히 orthogonal : process 개수 만큼","Entry는 가상 주소에 해당하며 이를 보게 되면 0번부터 N에 해당하는 index에서 N=8이라고 하면 PTE 0~ 7,","entry안의 내용을 보게 되면 실제 physical page number가 들어가 있음","fork하면 child process는 parent process와 같은 page table을 공유하는가? 그럼 같은 virtual memory가 서로 다른 physical memory를 가리키게 되는가? -> page table이 복제되는데 새로은 page table로 update됨 (공유하지 않음) 부모 것 하나, 자식 것 하나 각각 따로따로 가지고 있음. 즉, 서로 다른 physical memory를 가리키게 됨.","inear table의 entry가 VA를 PA로 변환해주는 역할을 수행(translator)","page : unallocated/ cached / uncached …","page : 각각의 memory에서의 물리적인 공간","page table size : 1MB/4MB (OS시간에 배움)","page table 자체가 DRAM에 저장됨. 자체 주소는 process의","Page Table은 kernel이 보는 것이고, kernel은 physical 주소를 본다. Virtual 주소도 보기는 하지만 physical 주소와도 1대1 대응하기에 Page table자체의 주소는 물리주소로 저장된다고 봐도 될 듯.","page table을 통해서 주소 변환","Per-process kernel data structure in DRAM Untitled","process 공간에서 data와 text로 보게 되고 heap을 쓰게 되면 위로 올라감/ 중간에 allcoate되지 않는 공간이 있을 것임.","process마다 process control block이라고 해서 자료구조가 있는데 여기서 page table에 대한 주소를 가지고 있음. 그 주소에 대한 page table이 선형적으로 들어가 있고, 나중에는 base line register에다가 process가 context switch될 때 주소를 가져다 넣는다.","process마다 가지고 있는 OS의 data structure: OS Kernel DS로서 10개 프로세스에 해당하는 다음과 같은 table을 process마다 가지고 있음","무언가 어쨌든 이 주소를 VP1이 PP1에 mapping되어있다는 정보 + page들의 mapping 정보. 다시 말하면 어떤 page들이 어떤 물리적 page에 mapping되어 있는가에 대한 정보가 필요함. 이를 관리하기 위한 table이 page table","앞에 있었던(8) : VA->PA로 mapping function","영역을 할당하게 되면 위쪽PTE=0이 text/code, n-1쪽으로부터 heap이 쭉 올라간다고 보면 됨","일정 크기의 page (block)을 mapping하기 위한 entry가 table에 들어가 있음","질문"]},{"l":"Page Hit","p":["Untitled","Page hit: reference to VM word that is in physical memory (DRAM cache hit)","나중에 VM을 가지고 mem copy를 한다고 하면 다른 VM으로 copy하게 되는데 그 주소는 ‘VA’","결국 내부적으로는 PA를 접근해야 한다. OS기저로 들어가면 내부 변환 작업을 수행해주어야 한다.","가상 주소가 DRAM에 있는가, Disk에 있는가는 page table 앞의 validity를 본다.","1인경우에만 main memory에 올라가 있는 형태: DRAM Cache에서 hit가 일어나서 DRAM에 접근하면 됨","0인경우: allocate 안 되어 있거나 VA가 실제 disk에 연결","해당하는 Validty를 확인한 후 DRAM Cache를 뒤져봄","Fault 발생","실제 접근했는데 접근하는 Page의 validity가 0으로 되어 있음 : physical하게 dram cache에 있는 게 아니라 dram cache에 있음"]},{"l":"Page Fault","p":["Page fault: reference to VM word that is not in physical memory (DRAM cache miss)","Page가 없기 때문에 page missing →fault handling 필요 Untitled"]},{"l":"Handling Page Fault","p":["Untitled","Page miss causes page fault (an exception)","Page Fault Handler가","PP 0~ 3 중 모종의 이유로 PP3을 쫓아내겠다고 결정 (evict)","evict하게 될 때 VP4는 VM으로, VP3은 PM으로 이동","3번이 올라왔으니깐 virtual page number 3번으로 이동하게 된다. 이러한 어떤 작업을 수행해주어야 한다.","→ Fault가 나오게 되면 누군가를 evict시켜주고 page table 을 update해주어야 한다. (4를 disk mapping, 3은 DRAM에 mapping)","demand paging","누군가를 evict하고 누군가를 가져와야 함","Page miss causes page fault (an exception) Untitled","Page fault handler selects a victim to be evicted (here VP 4) Untitled Untitled","Offending instruction is restarted : page hit Untitled"]},{"l":"Allocating Pages","p":["Allocating a new page (VP 5) of virtual memory. Untitled"]},{"i":"locality-to-the-rescue-again","l":"Locality to the Rescue Again!","p":["Virtual memory seems terribly inefficient, but it works because of locality.","At any point in time, programs tend to access a set of active virtual pages called the working set","Programs with better temporal locality will have smaller working sets","process 관점에서 봤을 때, VA를 PA로 바꾸어 주는 과정 자체가 내가 접근되는 memory주소에 따라서 어떤 놈은 DRAM, 어떤 놈은 DIsk에 있기 때문에 handling overhead가 상당히 큼","→ working set : 가상 메모리 페이지들의 집합.","If (working set size < main memory size) Working set < 내가 가진 main memory size","Good performance for one process after compulsory misses(Page fault가 발생하지 않을 것이니까)","If ( SUM(working set sizes) > main memory size ) Working set > 내가 가진 main memory size","Thrashing: Performance meltdown where pages are swapped (copied) in and out continuously 18","working set이 커지게 되면 thrashing문제 발생 : 자꾸 disk mapping / dram 이랬다 저랬다 하면 disk 접근 때문에 발생하게 된다. (어떤 페이지가 in and out from disk -> 성능이 완전히 melt down된다)","cache size라는 것은 어느정도 적당한 크기로 보장되어야 함.","CPU 성능도 중요하지만 메모리 성능이 중요한 이유이다: 여러 프로그램을 돌리기 때문에 각 process마다 지금과 같은 process마다 dram cache영역이 확보되어야 한다.","구동시키는 프로그램(웹/다양한 프로그램)들로 인한 in n out으로 인해 thrashing 이 발생하여 속도가 완전히 죽어버림.","→ 가급적이면 memory 큰 pc를 구입"]},{"l":"VM as a Tool for Memory Management"},{"i":"key-idea-each-process-has-its-own-virtual-address-space","l":"Key idea: each process has its own virtual address space","p":["It can view memory as a simple linear array","Mapping function scatters addresses through physical memory","Well-chosen mappings can improve locality Untitled","VM as a Tool for Memory Management","Simplifying memory allocation","Each virtual page can be mapped to any physical page","A virtual page can be stored in different physical pages at different times","Sharing code and data among processes","Map virtual pages to the same physical page (here: PP 6)","Untitled"]},{"l":"Simplifying Linking and Loading","p":["Untitled","Linking","Each program has similar virtual address space","Code, data, and heap always start at the same addresses.","Loading","execve allocates virtual pages brk for .text and .data sections & creates PTEs marked as invalid","The .text and .data sections are copied, page by page, on demand by the virtual memory system"]},{"l":"VM as a Tool for Memory Protection","p":["Extend PTEs with Permission bits","MMU checks these bits on each access"]}],[{"l":"Contact"},{"l":"How to reach me","p":["link"]}],[{"l":"Retype Software License Agreement"},{"i":"version-182","l":"Version 1.8.2","p":["THIS DOCUMENT IS A LEGAL AGREEMENT (the \"License Agreement\") BETWEEN OBJECT.NET, INC. (\"We,\" \"Us\") AND YOU OR THE ORGANIZATION ON WHOSE BEHALF YOU ARE UNDERTAKING THE LICENSE DESCRIBED BELOW (\"You\",\"Your\") IN RELATION TO THE RETYPE SOFTWARE LIBRARY(IES) (THE \"Software\"), IN BOTH SOURCE AND OBJECT CODE FORM, AND/OR ALL RELATED MATERIALS.","BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING THE SOFTWARE, YOU ACCEPT THE FOLLOWING TERMS AND CONDITIONS. IF YOU DO NOT AGREE WITH ANY OF THE TERMS OR CONDITIONS OF THIS LICENSE AGREEMENT, DO NOT PROCEED WITH THE DOWNLOADING, COPYING, INSTALLATION OR ANY OTHER USE OF THE SOFTWARE OR ANY PORTION THEREOF AS YOU HAVE NO RIGHTS TO DO SO. THE SOFTWARE IS PROTECTED BY UNITED STATES COPYRIGHT LAWS AND INTERNATIONAL COPYRIGHT LAWS, AS WELL AS OTHER INTELLECTUAL PROPERTY LAWS AND TREATIES. THE SOFTWARE IS LICENSED, NOT SOLD.","THIS LICENSE AGREEMENT DESCRIBES YOUR RIGHTS AND RESTRICTIONS WITH RESPECT TO THE SOFTWARE AND ITS COMPONENTS."]},{"l":"1. DEFINITIONS","p":["\"Application\" means any software, application, or elements that Your Designated Users develop using the Software or Modifications in accordance with this Agreement; provided that any such Application(i) must have substantially different functionality than the Software, and (ii) must not allow any third party to use the Software or Modifications, or any portion thereof, for software development or application development purposes.","\"Designated User\" shall mean a single distinct person for whom You have purchased a license to use the Software, whether such person is an employee acting within the scope of their employment with You or Your consultant or contractor acting within the scope of the services they provide for You. A Designated User can be replaced with a new Designated User only after being a Designated User for a minimum of six (6) months.","\"End User\" means an end user of Your Application who acquires a license to such solely for their own internal use and not for distribution, resale, user interface design, or software development purposes.","\"Modification\" means: a) any addition to or deletion from the contents of a file included in the original Software or previous Modifications created by You, and/or b) any new file that leverages any part of the original Software or previous Modifications.","\"Sample Code\" means sample source code included with the Software and designated as \"sample code,\"\"samples,\" \"sample application code,\" and/or \"snippets,\" and/or found in directories labeled\"samples\", \"learn\", \"docs\", \"examples\" or \"examples explorer\"."]},{"l":"2. LICENSE GRANT","p":["Subject to the payment of the fee required, and subject to your compliance with all of the terms and conditions of this Agreement, We grant to You a revocable, non-exclusive, non-transferable and non-sublicensable license (i) for Designated User(s) to use the Software to create Modifications and Applications; (ii) for You to distribute the Software and/or Modifications to End Users solely as integrated into the Applications; and (iii) for End Users to use the Software as integrated into Your Applications in accordance with the terms of this Agreement.","In addition to the other terms contained herein, We grant to You a revocable, non-exclusive, non-transferable and non-sublicensable license to install and use the Software (the \"Free License\") for Your internal evaluation, review, and production purposes. The Free License may contain restricted functionality. You are explicitly not permitted to distribute the Software to any user outside the Organization on whose behalf you have undertaken this license. We reserve the right to terminate Your License at any time in Our absolute and sole discretion. Without the purchase and inclusion of a License Key, the Software may contain restricted functionality, which from time-to-time may differ in its limitations. If you wish to remove these restrictions, you are required to purchase a Retype License Key; otherwise you must leave this limitation intact and not attempt to modify or circumvent it in any way.","In addition to the other terms contained herein, in the event You have downloaded or received beta or pre-release versions of the Software (the \"Beta Software\") from Us, We grant to You a revocable, non-exclusive, non-transferable and non-sublicensable license to install and use the Beta Software strictly for Your internal evaluation and review purposes and not for production purposes (the\"Beta License\"). You are explicitly not permitted to distribute the Software to any user outside the Organization on whose behalf you have undertaken this license. Your rights to use the Beta Software will immediately terminate upon the earlier of (i) the expiration of the evaluation period established by Us, or (ii) such time that You purchase a license to a non-evaluation version of the Software. We reserve the right to terminate Your Beta License at any time in Our absolute and sole discretion.","YOU ACKNOWLEDGE THAT TRIAL AND/OR BETA SOFTWARE MIGHT PLACE WATERMARKS ON OUTPUT, CONTAIN LIMITED FUNCTIONALITY, FUNCTION FOR A LIMITED PERIOD OF TIME, OR LIMIT THE FUNCTIONALITY OR TIME OF FUNCTIONING OF ANY OUTPUT. ACCESS TO AND/OR USE OF ANY FILES OR OUTPUT CREATED WITH SUCH SOFTWARE IS ENTIRELY AT YOUR OWN RISK. WE ARE LICENSING THE SOFTWARE ON AN \"AS IS\" BASIS AT YOUR OWN RISK AND WE DISCLAIM ANY WARRANTY OR LIABILITY TO YOU OF ANY KIND.","You may modify the \"Sample Code\" solely for the purposes of designing, developing and testing Your own Applications. However, You are permitted to use, copy and redistribute Your modified Sample Code only if all of the following conditions are met: (a) You include Our copyright notice (if any) with Your Application, including every location in which any other copyright notice appears in such Application; and (b) You do not otherwise use Our name, logos or other of Our trademarks to market Your Application, unless otherwise agree by Us in writing."]},{"l":"3. OWNERSHIP","p":["This is a license agreement and not an agreement for sale. We reserve ownership of all intellectual property rights inherent in or relating to the Software, which include, but are not limited to, all copyright, patent rights, all rights in relation to registered and unregistered trademarks(including service marks), confidential information (including trade secrets and know-how) and all rights other than those expressly granted by this Agreement.","We may provide You with source code so that You can create Modifications and Applications. While You retain all rights to any original work authored by You as part of the Modifications, We continue to own all copyright and other intellectual property rights in the Software.","You must not remove, obscure or interfere with any copyright, acknowledgment, attribution, trademark, warning or disclaimer statement affixed to, incorporated in or otherwise applied in connection with the Software."]},{"l":"4. PROHIBITED USES","p":["You may not redistribute the Software or Modifications other than by including the Software or a portion thereof within Your Application. You may not redistribute the Software or Modifications as part of any Application that can be described as a development toolkit or library, an application builder, a website builder or any Application that is intended for use by software, application, or website developers or designers. You may not redistribute any part of the Software documentation. You may not change or remove the copyright notice from any of the files included in the Software or Modifications.","UNDER NO CIRCUMSTANCES MAY YOU USE THE SOFTWARE FOR AN APPLICATION THAT IS INTENDED FOR SOFTWARE OR APPLICATION DEVELOPMENT PURPOSES.","UNDER NO CIRCUMSTANCES MAY YOU USE THE SOFTWARE (INCLUDING WITHOUT LIMITATION THE SOURCE CODE THEREOF) AS THE BASIS FOR OR IN CONNECTION WITH A PRODUCT THAT CONTAINS THE SAME, OR SUBSTANTIALLY THE SAME, FUNCTIONALITY AS THE SOFTWARE.","You are required to ensure that the Software is not reused by or with any applications other than those with which You distribute it as permitted herein. For example, if You install the Software on a customer's server, that customer is not permitted to use the Software independently of Your Application, and must be informed as such."]},{"l":"5. TERMINATION","p":["This Agreement and Your right to use the Software and Modifications will terminate immediately if You fail to comply with any of the terms and conditions of this Agreement. Upon termination, You agree to immediately cease using and destroy the Software or Modifications, including all accompanying documents. The provisions of sections 4, 5, 6, 7, 8, 9, and 11 will survive any termination of this Agreement."]},{"l":"6. DISCLAIMER OF WARRANTIES","p":["TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, WE AND OUR RESELLERS DISCLAIM ALL WARRANTIES AND CONDITIONS, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND TITLE AND NON-INFRINGEMENT, WITH REGARD TO THE SOFTWARE. WE DO NOT GUARANTEE THAT THE OPERATION OF THE SOFTWARE OR THE CODE IT PRODUCES WILL BE UNINTERRUPTED OR ERROR-FREE, AND YOU ACKNOWLEDGE THAT IT IS NOT TECHNICALLY PRACTICABLE FOR US TO DO SO."]},{"l":"7. LIMITATION OF LIABILITIES","p":["TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT SHALL WE OR OUR RESELLERS BE LIABLE UNDER ANY LEGAL OR EQUITABLE THEORY FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION OR ANY OTHER PECUNIARY LAW) ARISING OUT OF THE USE OF OR INABILITY TO USE THE SOFTWARE OR THE CODE IT PRODUCES OR ANY OTHER SUBJECT MATTER RELATING TO THIS AGREEMENT, EVEN IF WE OR OUR RESELLERS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. IN ANY CASE, OUR ENTIRE LIABILITY WITH RESPECT TO ANY SUBJECT MATTER RELATING TO THIS AGREEMENT SHALL BE LIMITED TO THE GREATER OF (I) THE AMOUNT ACTUALLY PAID BY YOU FOR THE SOFTWARE OR (II) ONE HUNDRED DOLLARS ($100)."]},{"l":"8. PAYMENT AND TAXES","p":["If credit has been extended to You by Us, all payments under this Agreement are due within thirty(30) days of the date We mail an invoice to You. If We have not extended credit to You, You shall be required to make payment concurrent with the delivery of the Software by Us. Any value added tax, use tax, sales tax or similar tax (\"Transaction Taxes\") shall be your sole responsibility. Each party shall pay all taxes (including, but not limited to, taxes based upon its income) or levies imposed on it under applicable laws, regulations and tax treaties as a result of this Agreement and any payments made hereunder (including those required to be withheld or deducted from payments); provided that You shall be responsible for all Transactions Taxes and shall pay or reimburse Us for the same upon invoice. Each party shall furnish evidence of such paid taxes as is sufficient to enable the other party to obtain any credits available to it, including original withholding tax certificates. Notwithstanding the foregoing, Software ordered through Our resellers is subject to the fees and payment terms set forth on the applicable reseller invoice."]},{"l":"9. MISCELLANEOUS","p":["The license granted herein applies only to the version of the Software available when purchased in connection with the terms of this Agreement, and to any updates and/or upgrades to which you may be entitled. Any previous or subsequent license granted to You for use of the Software shall be governed by the terms and conditions of the agreement entered in connection with purchase or download of that version of the Software. You agree that you will comply with all applicable laws and regulations with respect to the Software, including without limitation all export and re-export control laws and regulations.","While redistributing the Software or Modifications thereof as part of Your Application, You may choose to offer acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this Agreement. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on our behalf. You shall indemnify Us and our resellers, or at Our option, defend Us and our resellers against any claim, suit or proceeding brought against Us or our resellers (i) arising by reason of Your accepting any such support, warranty, indemnity or additional liability; or (ii) arising out of the use, reproduction or distribution of Your Application, except to the extent such claim is solely based on the inclusion of the Software therein. Further, You agree only to distribute the Software pursuant to an enforceable written agreement for Our benefit that includes all the limitations and restrictions of this Agreement and is as protective of Us and Software as is this Agreement. For clarity, You must purchase Designated User licenses for each contractor or consultant who uses the Software to create an Application on your behalf (including system integrators), whether or not such contractor or consultant has its own license to the Software.","You agree to be identified as a customer of ours and You agree that We may refer to You by name, trade name and trademark, if applicable, and may briefly describe Your business in our marketing materials and web site.","You may not assign or transfer this Agreement without Our prior written consent. This Agreement may be assigned by Us in whole or part and will inure to the benefit of Our successors and assigns. Notwithstanding the foregoing, in any instance in which You transfer ownership of an Application on a work for hire basis, You may assign licenses for the total Designated Users that have used the Software to develop said Application under this Agreement to another party (Assignee) provided (i) you provide written notice to Us prior to the effective date of such assignment; and(ii) there is a written agreement, wherein the Assignee accepts the terms of this Agreement. Upon any such transfer, the Assignee may appoint new Designated Users.","You acknowledge that this Agreement is complete and is the exclusive representation of our agreement. No oral or written information given by Us, Our resellers, or otherwise on Our behalf shall create a warranty or collateral contract, or in any way increase the scope of this Agreement in any way, and You may not rely on any such oral or written information. No term or condition contained in any purchase order shall have any force or effect.","There are no implied licenses or other implied rights granted under this Agreement, and all rights, save for those expressly granted hereunder, shall remain with Us and our licensors. In addition, no licenses or immunities are granted to the combination of the Software and/or Modifications, as applicable, with any other software or hardware not delivered by Us or Our resellers to You under this Agreement. Your rights under this Agreement apply only to Software, Modifications, and/or Applications for which all Designated Users are duly licensed hereunder.","If any provision in this Agreement shall be determined to be invalid, such provision shall be deemed omitted; the remainder of this Agreement shall continue in full force and effect. If any remedy provided is determined to have failed for its essential purpose, all limitations of liability and exclusions of damages set forth in this Agreement shall remain in effect.","This Agreement may be modified only by a written instrument signed by an authorized representative of each party. The failure of either party to enforce any provision of this Agreement may not be deemed a waiver of that or any other provision of this Agreement.","This Agreement is governed by the law of the Province of Alberta, Canada and all parties irrevocably submit to the jurisdiction of the courts of the Province of Alberta and further agree to commence any litigation which may arise hereunder in the courts located in the judicial district of Edmonton, Alberta, Canada.","If the Software or any related documentation is licensed to the U.S. Government or any agency thereof, it will be considered to be \"commercial computer software\" or \"commercial computer software documentation,\" as those terms are used in 48 CFR § 12.212 or 48 CFR § 227.7202, and is being licensed with only those rights as are granted to all other licensees as set forth in this Agreement."]}],[{"l":"Roadmap"}]]