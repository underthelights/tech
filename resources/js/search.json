[[{"l":"KyuHwan Shim"},{"l":"Research Area"},{"l":"Featured Project"},{"l":"Education"},{"l":"Military Service"},{"l":"Scholarships"},{"l":"Research Experience"},{"l":"Work Experience"},{"l":"Contact"}],[{"l":"Biology"}],[{"l":"고급생명과학 정리"},{"l":"BIOLOGY_hyper"}],[{"i":"2arrays--structures","l":"2.Arrays & Structures"}],[{"i":"21-arrays","l":"2.1. Arrays"},{"i":"arrays-chapter-21","l":"Arrays (Chapter 2.1)"},{"i":"211-arrays-as-an-abstract-data-type","l":"2.1.1 Arrays as an abstract data type"},{"i":"212-arrays-in-c","l":"2.1.2 Arrays in C"},{"i":"program-21-ex002","l":"Program 2.1 [ex002]"},{"i":"program-22-ex003","l":"Program 2.2 [ex003]"}],[{"i":"22-dynamically-allocated-arrays","l":"2.2. Dynamically Allocated Arrays"},{"i":"dynamically-allocated-arrays-chapter-22","l":"Dynamically Allocated Arrays (Chapter 2.2)"},{"i":"221-one-dimensional-arrays","l":"2.2.1 One-dimensional arrays"},{"i":"one-dimensional-arrays-ex004","l":"One-dimensional arrays [ex004]"},{"i":"222-two-dimensional-arrays","l":"2.2.2 Two-dimensional arrays"},{"i":"program-23-ex005","l":"Program 2.3 [ex005]"}],[{"i":"23-structures-and-unions","l":"2.3. Structures and Unions"},{"i":"structures-and-unions-chapter-23","l":"Structures and Unions (Chapter 2.3)"},{"i":"231-structures","l":"2.3.1 Structures"},{"i":"232-unions-ex007","l":"2.3.2 Unions [ex007]"},{"i":"233-internal-implementation-of-structures","l":"2.3.3 Internal Implementation of Structures"},{"i":"234-self-referential-structures","l":"2.3.4 Self-Referential Structures"},{"l":"Notes on struct"}],[{"i":"24-polynomials","l":"2.4. Polynomials"},{"i":"polynomials-chapter-24","l":"Polynomials (Chapter 2.4)"},{"i":"241-polynomials","l":"2.4.1 Polynomials"},{"l":"Specification of ADT Polynomial"},{"i":"242-polynomial-representation","l":"2.4.2 Polynomial Representation"}],[{"i":"arrays-and-structures-chapter-2","l":"Arrays and Structures (Chapter 2)"},{"i":"sparse-matrix-chapter-25","l":"Sparse Matrix (Chapter 2.5)"},{"i":"251-sparse-matrix-adt","l":"2.5.1 Sparse Matrix ADT"},{"i":"252-sparse-matrix-representation","l":"2.5.2 Sparse Matrix Representation"},{"i":"253-transposing-a-matrix-ex010","l":"2.5.3 Transposing a Matrix [ex010]"}],[{"i":"arrays-and-structures-chapter-2","l":"Arrays and Structures (Chapter 2)"},{"i":"strings-chapter-27","l":"Strings (Chapter 2.7)"},{"i":"271-adt-strings","l":"2.7.1 ADT Strings"},{"i":"272-strings-in-c---representation","l":"2.7.2 Strings in C - Representation"},{"i":"273-pattern-matching","l":"2.7.3 Pattern Matching"},{"i":"kmp-knuth-morris-pratt-algorithm","l":"KMP (Knuth-Morris-Pratt) Algorithm"},{"l":"Try-It-Yourself"}],[{"i":"3stack--queue","l":"3.Stack & Queue"}],[{"i":"31-stacks","l":"3.1. Stacks"},{"i":"stacks-chapter-31","l":"Stacks (Chapter 3.1)"},{"l":"Definition of Stack"},{"l":"Analogy"},{"i":"stack-lifo-behavior","l":"Stack: LIFO behavior"},{"i":"stack-example-usage","l":"Stack: Example Usage"},{"i":"stack-abstract-data-type","l":"Stack: Abstract Data Type"},{"l":"Ordered Lists"},{"l":"Implementation of a stack"},{"i":"implementing-push-and-pop-ex018","l":"Implementing push and pop [ex018]"},{"i":"example-tower-of-hanoi","l":"Example: Tower of Hanoi"},{"i":"example-rat-in-a-maze","l":"Example: Rat in a Maze"}],[{"i":"32-a-note-on-asymptotic-time-complexity","l":"3.2. A Note on Asymptotic Time Complexity"},{"i":"a-note-on-asymptotic-time-complexity-chapter-32","l":"A Note on Asymptotic Time Complexity (Chapter 3.2)"},{"l":"Big O"},{"l":"Limitation of asymptotic time complexity"},{"l":"Omega"},{"l":"Theta"}],[{"i":"33-queues","l":"3.3. Queues"},{"i":"queues-chapter-33","l":"Queues (Chapter 3.3)"},{"l":"Definition of Queue"},{"i":"queue-analogy","l":"Queue: analogy"},{"i":"queue-fifo-behavior","l":"Queue: FIFO behavior"},{"i":"queue-abstract-data-type","l":"Queue: Abstract Data Type"},{"i":"queue-implementation","l":"Queue: implementation"}],[{"i":"36-evaluation-of-expressions","l":"3.6. Evaluation of Expressions"},{"i":"evaluation-of-expressions-chapter-36","l":"Evaluation of Expressions (Chapter 3.6)"},{"i":"361-expressions","l":"3.6.1 Expressions"},{"i":"362-evaluating-postfix-expressions","l":"3.6.2 Evaluating Postfix Expressions"},{"i":"363-infix-to-postfix","l":"3.6.3 Infix To Postfix"}],[{"i":"4linked-list","l":"4.Linked List"}],[{"i":"41-singly-linked-lists-and-chains-representing-chains-in-c","l":"4.1. Singly Linked Lists and Chains Representing Chains in C"},{"i":"singly-linked-lists-and-chains-representing-chains-in-cchapter-41-2","l":"Singly Linked Lists and Chains Representing Chains in C(Chapter 4.1-2)"},{"l":"Representation of Lists"},{"i":"review-pointers","l":"Review: Pointers"},{"i":"linked-lists-concept","l":"Linked Lists: Concept"},{"l":"Singly Linked List"},{"l":"Doubly Linked List"},{"i":"linked-lists-representation","l":"Linked Lists: Representation"},{"i":"linked-lists-reading-an-element-ex024","l":"Linked Lists: Reading an Element [ex024]"},{"i":"linked-lists-deleting-an-element","l":"Linked Lists: Deleting an Element"},{"i":"linked-lists-inserting-an-element","l":"Linked Lists: Inserting an Element"},{"i":"example-a-linked-list-of-integers-ex025","l":"Example: A Linked List of Integers [ex025]"}],[{"i":"44-representing-polynomials-using-linked-lists","l":"4.4. Representing Polynomials using Linked Lists"},{"i":"representing-polynomials-using-linked-lists-chapter-44","l":"Representing Polynomials using Linked Lists (Chapter 4.4)"},{"l":"Polynomials"},{"i":"442-adding-polynomials-ex026","l":"4.4.2 Adding Polynomials [ex026]"},{"i":"443-erasing-polynomials","l":"4.4.3 Erasing Polynomials"},{"i":"444-representing-polynomials-as-circular-lists","l":"4.4.4 Representing Polynomials as Circular Lists"}],[{"i":"45-additional-list-operations","l":"4.5. Additional List Operations"},{"i":"additional-list-operations-chapter-45","l":"Additional List Operations (Chapter 4.5)"},{"i":"451-operations-for-chains","l":"4.5.1 Operations for Chains"},{"i":"452-operations-for-circularly-linked-lists","l":"4.5.2 Operations for Circularly Linked Lists"}],[{"i":"46-equivalence-classes","l":"4.6. Equivalence Classes"},{"i":"equivalence-classes-chapter-46","l":"Equivalence Classes (Chapter 4.6)"},{"l":"Equivalence Classes"}],[{"i":"48-doubly-linked-lists","l":"4.8. Doubly Linked Lists"},{"i":"doubly-linked-lists-chapter-48","l":"Doubly Linked Lists (Chapter 4.8)"},{"l":"Doubly Linked Lists"}],[{"i":"5trees","l":"5.Trees"}],[{"i":"51-introduction-to-the-trees","l":"5.1. Introduction to the Trees"},{"i":"introduction-to-the-treeschapter-51","l":"Introduction to the Trees(Chapter 5.1)"},{"i":"511-terminology","l":"5.1.1 Terminology"},{"i":"512-representation-of-trees","l":"5.1.2 Representation of Trees"}],[{"i":"52-binary-trees","l":"5.2. Binary Trees"},{"i":"binary-treeschapter-52","l":"Binary Trees(Chapter 5.2)"},{"i":"521-the-abstract-data-type","l":"5.2.1 The Abstract Data Type"},{"i":"522-properties-of-binary-trees","l":"5.2.2 Properties of Binary Trees"},{"i":"523-binary-tree-representations","l":"5.2.3 Binary Tree Representations"}],[{"i":"53-binary-tree-traversal","l":"5.3. Binary Tree Traversal"},{"i":"binary-tree-traversalchapter-53","l":"Binary Tree Traversal(Chapter 5.3)"},{"l":"Binary Tree Traversals"},{"i":"lvr--inorder-traversal","l":"LVR : Inorder traversal"},{"i":"vlr-preorder-traversal","l":"VLR: Preorder traversal"},{"i":"lrv-postorder-traversal","l":"LRV: Postorder traversal"},{"l":"Iterative inorder traversal"},{"l":"Level order traversal"},{"i":"exerciseex036","l":"Exercise[ex036]"}],[{"i":"54-additional-binary-tree-operations","l":"5.4. Additional Binary Tree Operations"},{"i":"additional-binary-tree-operations-chapter-54","l":"Additional Binary Tree Operations (Chapter 5.4)"},{"i":"541-copying-binary-trees","l":"5.4.1 Copying Binary Trees"},{"i":"542-testing-for-equality-of-binary-trees","l":"5.4.2 Testing For Equality of Binary Trees"},{"i":"543-the-satisfiability-problem","l":"5.4.3 The Satisfiability Problem"}],[{"i":"55-threaded-binary-trees","l":"5.5. Threaded Binary Trees"},{"i":"threaded-binary-trees-chapter-55","l":"Threaded Binary Trees (Chapter 5.5)"},{"l":"Inorder traversal"},{"l":"Finding the inorder successor of a node"},{"l":"Inserting a node into a threaded binary tree"}],[{"i":"56-heaps","l":"5.6. Heaps"},{"i":"heaps-chapter-56","l":"Heaps (Chapter 5.6)"},{"i":"561-the-heap-abstract-data-type","l":"5.6.1 The Heap Abstract Data Type"},{"i":"562-priority-queues","l":"5.6.2 Priority Queues"},{"i":"563-insertion-into-a-max-heap","l":"5.6.3 Insertion into a Max Heap"},{"i":"564-deletion-from-a-max-heap","l":"5.6.4 Deletion from a Max Heap"},{"i":"565-summary","l":"5.6.5. Summary"}],[{"i":"57-binary-search-trees","l":"5.7. Binary Search Trees"},{"i":"binary-search-treeschapter-57","l":"Binary Search Trees(Chapter 5.7)"},{"i":"571-definition","l":"5.7.1 Definition"},{"i":"572-searching-a-binary-search-tree","l":"5.7.2 Searching a Binary Search Tree"},{"i":"573-inserting-into-a-binary-search-tree","l":"5.7.3 Inserting into a Binary Search Tree"},{"i":"574-deletion-from-a-binary-search-tree","l":"5.7.4 Deletion from a Binary Search Tree"},{"i":"576-height-of-a-binary-search-tree","l":"5.7.6 Height of a Binary Search Tree"}],[{"i":"59-forests","l":"5.9. Forests"},{"i":"forests-chapter-59","l":"Forests (Chapter 5.9)"},{"i":"590-definition","l":"5.9.0. Definition"},{"i":"591-transforming-a-forest-into-a-binary-tree","l":"5.9.1 Transforming a Forest into a Binary Tree"},{"i":"592-forest-traversals","l":"5.9.2 Forest Traversals"}],[{"i":"treeschapter-5","l":"Trees(Chapter 5)"},{"i":"disjoint-sets-chapter-510","l":"Disjoint Sets (Chapter 5.10)"},{"i":"5101-representation-of-disjoint-sets","l":"5.10.1 Representation of Disjoint Sets"},{"i":"5102-union-and-find-operations","l":"5.10.2 Union and Find Operations"},{"i":"5103-equivalence-classes","l":"5.10.3 Equivalence Classes"}],[{"i":"treeschapter-5","l":"Trees(Chapter 5)"},{"i":"selection-treeschapter-58","l":"Selection Trees(Chapter 5.8)"},{"i":"581-introduction","l":"5.8.1 Introduction"},{"i":"582-winner-trees","l":"5.8.2 Winner Trees"},{"i":"583-loser-trees","l":"5.8.3 Loser Trees"}],[{"i":"6graph","l":"6.Graph"}],[{"i":"61-the-graph-abstract-data-type","l":"6.1. The Graph Abstract Data Type"},{"i":"the-graph-abstract-data-type-chapter-61","l":"The Graph Abstract Data Type (Chapter 6.1)"},{"i":"611-introduction","l":"6.1.1 Introduction"},{"i":"612-definitions","l":"6.1.2 Definitions"},{"i":"613-graph-representations","l":"6.1.3 Graph Representations"}],[{"i":"62-elementary-graph-operations","l":"6.2. Elementary Graph Operations"},{"i":"elementary-graph-operations-chapter-62","l":"Elementary Graph Operations (Chapter 6.2)"},{"i":"621-depth-first-search-dfs","l":"6.2.1 Depth First Search (DFS)"},{"i":"622-breadth-first-search-bfs","l":"6.2.2 Breadth First Search (BFS)"},{"i":"623-connected-components","l":"6.2.3 Connected Components"},{"i":"624-spanning-trees","l":"6.2.4 Spanning Trees"},{"i":"625-biconnected-components","l":"6.2.5 Biconnected Components"},{"i":"ex043","l":"[ex043]"}],[{"i":"63-minimum-cost-spanning-trees","l":"6.3. Minimum Cost Spanning Trees"},{"i":"minimum-cost-spanning-trees-chapter-63","l":"Minimum Cost Spanning Trees (Chapter 6.3)"},{"i":"631-kruskals-algorithm","l":"6.3.1 Kruskal's Algorithm"},{"i":"632-prims-algorithm","l":"6.3.2 Prim's Algorithm"},{"i":"633-sollins-algorithm","l":"6.3.3 Sollin's algorithm"}],[{"i":"64-shortest-paths-and-transitive-closure","l":"6.4. Shortest Paths and Transitive Closure"},{"i":"shortest-paths-and-transitive-closure-chapter-64","l":"Shortest Paths and Transitive Closure (Chapter 6.4)"},{"i":"641-single-sourceall-destinations-nonnegative-edge-costs","l":"6.4.1 Single Source/All Destinations: Nonnegative Edge Costs"},{"i":"642-single-sourceall-destinations-general-weights","l":"6.4.2 Single Source/All Destinations: General Weights"},{"i":"643-all-pairs-shortest-paths","l":"6.4.3 All Pairs Shortest Paths"},{"i":"644-transitive-closure","l":"6.4.4 Transitive Closure"}],[{"i":"8hashing","l":"8.Hashing"}],[{"i":"81-hashing","l":"8.1. Hashing"},{"i":"hashing-chapter-8","l":"Hashing (Chapter 8)"},{"l":"Introduction"},{"i":"hashing-overview","l":"Hashing: Overview"},{"i":"hashing-example","l":"Hashing: Example"},{"i":"hashing-collision-and-overflow","l":"Hashing: Collision and Overflow"},{"i":"hashing-loading-density-loading-factor","l":"Hashing: Loading Density (Loading Factor)"},{"l":"Issues in Hashing"},{"l":"Hash Functions"},{"l":"Popular Hash Functions"},{"i":"division-example","l":"Division: Example"},{"i":"hash-functions---converting-keys-to-integers","l":"Hash Functions - Converting Keys to Integers"},{"l":"Overflow Handling"},{"i":"overflow-handling-chaining","l":"Overflow Handling: Chaining"},{"l":"Performance Analysis"}],[{"l":"R"},{"l":"자료구조 Data Structure"},{"l":"2. Arrays and Structures"},{"l":"3. Stacks and Queues"},{"l":"4. Linked List"},{"l":"5. Trees"},{"l":"6. Graphs"}],[{"l":"About"},{"i":"credits","l":"Credits \uD83D\uDC4F"},{"l":"License"}],[{"l":"Computer Vision"},{"l":"Computer Vision"},{"l":"CNN Architecture"},{"l":"Visualizing CNNs"},{"l":"Weakly Supervised Localization"},{"l":"Object Detection"},{"l":"Semantic Segmentation"},{"l":"Style Transfer"},{"i":"siamese-triplet-network","l":"Siamese, Triplet Network"},{"l":"Mobile"},{"i":"etc","l":"Etc."}],[{"l":"Contact"},{"l":"How to reach me"}],[{"l":"Retype Software License Agreement"},{"l":"1. DEFINITIONS"},{"l":"2. LICENSE GRANT"},{"l":"3. OWNERSHIP"},{"l":"4. PROHIBITED USES"},{"l":"5. TERMINATION"},{"l":"6. DISCLAIMER OF WARRANTIES"},{"l":"7. LIMITATION OF LIABILITIES"},{"l":"8. PAYMENT AND TAXES"},{"l":"9. MISCELLANEOUS"}],[{"l":"Roadmap"},{"i":"v200","l":"v2.0.0"},{"i":"v1100","l":"v1.10.0"},{"i":"v190-","l":"v1.9.0"},{"i":"v182-","l":"v1.8.2"},{"i":"v181","l":"v1.8.1"},{"i":"v180","l":"v1.8.0"},{"i":"v170","l":"v1.7.0"},{"i":"v160","l":"v1.6.0"},{"i":"v150","l":"v1.5.0"},{"i":"v140","l":"v1.4.0"},{"i":"v130","l":"v1.3.0"},{"i":"v120","l":"v1.2.0"},{"i":"v110","l":"v1.1.0"},{"i":"v100","l":"v1.0.0"}]]