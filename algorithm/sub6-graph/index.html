<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="turbo-root" content="/tech">
    <meta name="turbo-cache-control" content="no-cache" data-turbo-track="reload" data-track-token="2.3.0.709808373793">

    <!-- See retype.com -->
    <meta name="generator" content="Retype 2.3.0">

    <!-- Primary Meta Tags -->
    <title>Graph</title>
    <meta name="title" content="Graph">
    <meta name="description" content="Algorithm Design & Analysis[Sub6] Graph" />

    <!-- Canonical -->
    <link rel="canonical" href="/tech/algorithm/sub6-graph/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="/tech/algorithm/sub6-graph/">
    <meta property="og:title" content="Graph">
    <meta property="og:description" content="Algorithm Design & Analysis[Sub6] Graph">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="/tech/algorithm/sub6-graph/">
    <meta property="twitter:title" content="Graph">
    <meta property="twitter:description" content="Algorithm Design & Analysis[Sub6] Graph">

    <script>(function () { var el = document.documentElement, m = localStorage.getItem("/tech/doc_theme"), wm = window.matchMedia; if (m === "dark" || (!m && wm && wm("(prefers-color-scheme: dark)").matches)) { el.classList.add("dark") } else { el.classList.remove("dark") } })();</script>

    <link href="../../favicon.ico" rel="icon" />
    <link href="../../resources/css/retype.css?v=2.3.0.709808373793" rel="stylesheet" />

    <script type="text/javascript" src="../../resources/js/config.js?v=2.3.0.709808373793" data-turbo-eval="false" defer></script>
    <script type="text/javascript" src="../../resources/js/retype.js?v=2.3.0" data-turbo-eval="false" defer></script>
    <script id="lunr-js" type="text/javascript" src="../../resources/js/lunr.js?v=2.3.0.709808373793" data-turbo-eval="false" defer></script>
    <script id="prism-js" type="text/javascript" src="../../resources/js/prism.js?v=2.3.0.709808373793" defer></script>
    <link href="../../resources/css/katex.css?v=2.3.0" rel="stylesheet" />
    <script id="katex-js" type="text/javascript" src="../../resources/js/katex.js?v=2.3.0" defer></script>
</head>
<body>
    <div id="docs-app" class="relative text-base antialiased text-gray-700 bg-white font-body dark:bg-dark-850 dark:text-dark-300">
        <div class="absolute bottom-0 left-0 bg-gray-100 dark:bg-dark-800" style="top: 5rem; right: 50%"></div>
    
        <header id="docs-site-header" class="sticky top-0 z-30 flex w-full h-16 bg-white border-b border-gray-200 md:h-20 dark:bg-dark-850 dark:border-dark-650">
            <div class="container relative flex items-center justify-between grow pr-6 md:justify-start">
                <!-- Mobile menu button skeleton -->
                <button v-cloak class="skeleton docs-mobile-menu-button flex items-center justify-center shrink-0 overflow-hidden dark:text-white focus:outline-none rounded-full w-10 h-10 ml-3.5 md:hidden"><svg xmlns="http://www.w3.org/2000/svg" class="mb-px shrink-0" width="24" height="24" viewBox="0 0 24 24" role="presentation" style="margin-bottom: 0px;"><g fill="currentColor"><path d="M2 4h20v2H2zM2 11h20v2H2zM2 18h20v2H2z"></path></g></svg></button>
                <div v-cloak id="docs-sidebar-toggle"></div>
        
                <!-- Logo -->
                <div class="flex items-center justify-between h-full py-2 md:w-75">
                    <div class="flex items-center px-2 md:px-6">
                        <a id="docs-site-logo" href="../../" class="flex items-center leading-snug text-2xl">
                            <span class="w-10 mr-2 grow-0 shrink-0 overflow-hidden">
                                <img class="max-h-10 dark:hidden md:inline-block" src="../../static/saintly-logo.svg">
                                <img class="max-h-10 hidden dark:inline-block" src="../../static/saintly-logo-dark.svg">
                            </span>
                            <span class="dark:text-white font-semibold line-clamp-1 md:line-clamp-2">S.KYUHWN</span>
                        </a>
                    </div>
        
                    <span class="hidden h-8 border-r md:inline-block dark:border-dark-650"></span>
                </div>
        
                <div class="flex justify-between md:grow">
                    <!-- Top Nav -->
                    <nav class="hidden md:flex">
                        <ul class="flex flex-col mb-4 md:pl-16 md:mb-0 md:flex-row md:items-center">
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="../../">Home</a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://github.com/underthelights/">GitHub</a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://drive.google.com/file/d/1lcEg4fXJvTQlCKW5mWai_ej8NZGg21yT/view">Resume</a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://www.linkedin.com/in/kyuhwan-shim/">Linkedin</a>
                            </li>
                            <li class="mr-6">
                                <a class="py-2 md:mb-0 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://underthelights.github.io">GitBlog</a>
                            </li>
        
                        </ul>
                    </nav>
        
                    <!-- Header Right Skeleton -->
                    <div v-cloak class="flex justify-end grow skeleton">
        
                        <!-- Search input mock -->
                        <div class="relative hidden w-40 lg:block lg:max-w-sm lg:ml-auto">
                            <div class="absolute flex items-center justify-center h-full pl-3 dark:text-dark-300">
                                <svg xmlns="http://www.w3.org/2000/svg" class="icon-base" width="16" height="16" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation"  style="margin-bottom: 1px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                            </div>
        
                            <input class="w-full h-10 transition-colors duration-200 ease-in bg-gray-200 border border-transparent rounded md:text-sm hover:bg-white hover:border-gray-300 focus:outline-none focus:bg-white focus:border-gray-500 dark:bg-dark-600 dark:border-dark-600 placeholder-gray-400 dark:placeholder-dark-400"
                            style="padding: 0.625rem 0.75rem 0.625rem 2rem" type="text" placeholder="Search" />
                        </div>
        
                        <!-- Mobile search button mock -->
                        <div class="flex items-center justify-center w-10 h-10 lg:hidden">
                            <svg xmlns="http://www.w3.org/2000/svg" class="shrink-0 icon-base" width="20" height="20" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation"  style="margin-bottom: 0px;"><g fill="currentColor" ><path d="M21.71 20.29l-3.68-3.68A8.963 8.963 0 0020 11c0-4.96-4.04-9-9-9s-9 4.04-9 9 4.04 9 9 9c2.12 0 4.07-.74 5.61-1.97l3.68 3.68c.2.19.45.29.71.29s.51-.1.71-.29c.39-.39.39-1.03 0-1.42zM4 11c0-3.86 3.14-7 7-7s7 3.14 7 7c0 1.92-.78 3.66-2.04 4.93-.01.01-.02.01-.02.01-.01.01-.01.01-.01.02A6.98 6.98 0 0111 18c-3.86 0-7-3.14-7-7z" ></path></g></svg>
                        </div>
        
                        <!-- Dark mode switch placehokder -->
                        <div class="w-10 h-10 lg:ml-2"></div>
        
                        <!-- History button mock -->
                        <div class="flex items-center justify-center w-10 h-10" style="margin-right: -0.625rem;">
                            <svg xmlns="http://www.w3.org/2000/svg" class="shrink-0 icon-base" width="22" height="22" viewBox="0 0 24 24" aria-labelledby="icon" role="presentation"  style="margin-bottom: 0px;"><g fill="currentColor" ><g ><path d="M12.01 6.01c-.55 0-1 .45-1 1V12a1 1 0 00.4.8l3 2.22a.985.985 0 001.39-.2.996.996 0 00-.21-1.4l-2.6-1.92V7.01c.02-.55-.43-1-.98-1z"></path><path d="M12.01 1.91c-5.33 0-9.69 4.16-10.05 9.4l-.29-.26a.997.997 0 10-1.34 1.48l1.97 1.79c.19.17.43.26.67.26s.48-.09.67-.26l1.97-1.79a.997.997 0 10-1.34-1.48l-.31.28c.34-4.14 3.82-7.41 8.05-7.41 4.46 0 8.08 3.63 8.08 8.09s-3.63 8.08-8.08 8.08c-2.18 0-4.22-.85-5.75-2.4a.996.996 0 10-1.42 1.4 10.02 10.02 0 007.17 2.99c5.56 0 10.08-4.52 10.08-10.08.01-5.56-4.52-10.09-10.08-10.09z"></path></g></g></svg>
                        </div>
                    </div>
        
                    <div v-cloak class="flex justify-end grow">
                        <div id="docs-mobile-search-button"></div>
                        <doc-search-desktop></doc-search-desktop>
        
                        <doc-theme-switch class="lg:ml-2"></doc-theme-switch>
                        <doc-history></doc-history>
                    </div>
                </div>
            </div>
        </header>
    
        <div class="container relative flex bg-white">
            <!-- Sidebar Skeleton -->
            <div v-cloak class="fixed flex flex-col shrink-0 duration-300 ease-in-out bg-gray-100 border-gray-200 sidebar top-20 w-75 border-r h-screen md:sticky transition-transform skeleton dark:bg-dark-800 dark:border-dark-650">
            
                <!-- Render this div, if config.showSidebarFilter is `true` -->
                <div class="flex items-center h-16 px-6">
                    <input class="w-full h-8 px-3 py-2 transition-colors duration-200 ease-linear bg-white border border-gray-200 rounded shadow-none text-sm focus:outline-none focus:border-gray-600 dark:bg-dark-600 dark:border-dark-600" type="text" placeholder="Filter" />
                </div>
            
                <div class="pl-6 mb-4 mt-1">
                    <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-32 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-48 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                    <div class="w-40 h-3 mb-4 bg-gray-200 rounded-full loading dark:bg-dark-600"></div>
                </div>
            
                <div class="shrink-0 mt-auto bg-transparent dark:border-dark-650">
                    <a class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by" target="_blank" href="https://retype.com/" rel="noopener">
                        <span class="text-xs whitespace-nowrap">Powered by</span>
                        <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
                    </a>
                </div>
            </div>
            
            <!-- Sidebar component -->
            <doc-sidebar v-cloak>
                <template #sidebar-footer>
                    <div class="shrink-0 mt-auto border-t md:bg-transparent md:border-none dark:border-dark-650">
            
                        <div class="py-3 px-6 md:hidden border-b dark:border-dark-650">
                            <nav>
                                <ul class="flex flex-wrap justify-center items-center">
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="../../">Home</a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://github.com/underthelights/">GitHub</a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://drive.google.com/file/d/1lcEg4fXJvTQlCKW5mWai_ej8NZGg21yT/view">Resume</a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://www.linkedin.com/in/kyuhwan-shim/">Linkedin</a>
                                    </li>
                                    <li class="mr-6">
                                        <a class="block py-1 inline-flex items-center text-sm whitespace-nowrap transition-colors duration-200 ease-linear md:text-blue-500 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200" href="https://underthelights.github.io">GitBlog</a>
                                    </li>
            
                                </ul>
                            </nav>
                        </div>
            
                        <a class="flex items-center justify-center flex-nowrap h-16 text-gray-400 dark:text-dark-400 hover:text-gray-700 dark:hover:text-dark-300 transition-colors duration-150 ease-in docs-powered-by" target="_blank" href="https://retype.com/" rel="noopener">
                            <span class="text-xs whitespace-nowrap">Powered by</span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="ml-2" fill="currentColor" width="96" height="20" overflow="visible"><path d="M0 0v20h13.59V0H0zm11.15 17.54H2.44V2.46h8.71v15.08zM15.8 20h2.44V4.67L15.8 2.22zM20.45 6.89V20h2.44V9.34z"/><g><path d="M40.16 8.44c0 1.49-.59 2.45-1.75 2.88l2.34 3.32h-2.53l-2.04-2.96h-1.43v2.96h-2.06V5.36h3.5c1.43 0 2.46.24 3.07.73s.9 1.27.9 2.35zm-2.48 1.1c.26-.23.38-.59.38-1.09 0-.5-.13-.84-.4-1.03s-.73-.28-1.39-.28h-1.54v2.75h1.5c.72 0 1.2-.12 1.45-.35zM51.56 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92h4.74v1.83h-6.79V5.36h6.64zM60.09 7.15v7.48h-2.06V7.15h-2.61V5.36h7.28v1.79h-2.61zM70.81 14.64h-2.06v-3.66l-3.19-5.61h2.23l1.99 3.45 1.99-3.45H74l-3.19 5.61v3.66zM83.99 6.19c.65.55.97 1.4.97 2.55s-.33 1.98-1 2.51-1.68.8-3.04.8h-1.23v2.59h-2.06V5.36h3.26c1.42 0 2.45.28 3.1.83zm-1.51 3.65c.25-.28.37-.69.37-1.22s-.16-.92-.48-1.14c-.32-.23-.82-.34-1.5-.34H79.7v3.12h1.38c.68 0 1.15-.14 1.4-.42zM95.85 5.36V7.2h-4.59v1.91h4.13v1.76h-4.13v1.92H96v1.83h-6.79V5.36h6.64z"/></g></svg>
                        </a>
                    </div>
                </template>
            </doc-sidebar>
    
            <div class="grow min-w-0 dark:bg-dark-850">
                <!-- Render "toolbar" template here on api pages --><!-- Render page content -->
                <div class="flex">
                    <div class="grow min-w-0 px-6 md:px-16">
                        <main class="relative pt-6 pb-16">
                            <div class="docs-markdown" id="docs-content">
                                <!-- Rendered if sidebar right is enabled -->
                                <div id="docs-sidebar-right-toggle"></div>
                
                                <!-- Page content  -->
<doc-anchor-target id="graph" class="break-words">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#graph">#</doc-anchor-trigger>
        <span>Graph</span>
    </h1>
</doc-anchor-target>
<div class="-mt-3 mb-12 flex flex-wrap text-sm text-gray-400 dark:text-dark-350 items-center">
    <div>In&nbsp;</div>
    <div><a href="../../categories/alg/">alg</a></div>
</div>

<p>Algorithm Design &amp; Analysis<br />
<strong>[Sub6] Graph</strong></p>
<!--more-->
<doc-anchor-target id="주제-6-graph-algorithms" class="break-words">
    <h1>
        <doc-anchor-trigger class="header-anchor-trigger" to="#주제-6-graph-algorithms">#</doc-anchor-trigger>
        <span>[주제 6] Graph Algorithms</span>
    </h1>
</doc-anchor-target>
<doc-anchor-target id="0-basic-things-to-know-about-graph-as-a-cse-undergraduate">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#0-basic-things-to-know-about-graph-as-a-cse-undergraduate">#</doc-anchor-trigger>
        <span>0. Basic Things to Know about Graph as a CSE Undergraduate</span>
    </h2>
</doc-anchor-target>
<ul>
<li>Definitions and representations</li>
<li>Graph traversal algorithms
<ul>
<li>Depth-first search</li>
<li>Breadth-first search</li>
</ul>
</li>
<li>Connectivity
<ul>
<li>Simple connectivity</li>
<li>Strong connectivity</li>
<li>Biconnectivity</li>
<li>Transitive closure</li>
</ul>
</li>
<li>Biconnected component algorithms</li>
<li>Shortest path algorithm
<ul>
<li>All-pairs shortest path algorithm</li>
<li>Single-source shortest path algorithm</li>
</ul>
</li>
<li>Minimum spanning tree algorithm
<ul>
<li>Prim’s minimum spanning tree algorithm</li>
<li>Kruskal’s minimum spanning tree algorithm</li>
</ul>
</li>
</ul>
<doc-anchor-target id="1-definitions">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#1-definitions">#</doc-anchor-trigger>
        <span>1. Definitions</span>
    </h2>
</doc-anchor-target>
<ul>
<li>An (<em>undirected</em>, <em>simple</em>) <em>graph</em> <em>G</em> is defined to be a pair of (<em>V</em>, <em>E</em>) , where <em>V</em> is a non-empty finite set of elements called <em>vertices</em>, and <em>E</em> is a finite set of unordered pairs of distinct elements of <em>V</em> called edges.
<ul>
<li><em>G</em> = (<em>V</em>, <em>E</em>) = (<em>V</em>(<em>G</em>), <em>E</em>(<em>G</em>))</li>
<li>Graphs that allow loops and multiple edges are often called a <em>general graphs</em>.</li>
</ul>
</li>
<li>A (<em>simple</em>) <em>digraph</em> <em>D</em> is defined to be a pair (<em>V</em>, <em>A</em>), where <em>V</em> is a non-empty finite set of elements called <em>vertices</em>, and <em>A</em> is a finite set of ordered pairs of distinct elements of <em>V</em> called (<em>directed</em>) <em>edges</em> or (<em>directed</em>) <em>arcs</em>.</li>
<li>A <em>weighted graph</em> is a graph in which a number, called the <em>weight</em>, is assigned to each edge.</li>
</ul>
<p><span class="math">V = \{ 1, 2, 3, 4, 5, 6 \}</span>
$ E = { (1, 2), (1, 5), (2, 3), (2, 5), (3, 4), (4, 5), (4, 6) }$</p>
<p>From Wikipedia</p>
<ul>
<li><p>A <em>subgraph</em> of a graph <em>G</em> is simply a graph, all of whose vertices belong to <em>V</em>(<em>G</em>) and all of whose edges belong to <em>E</em>(<em>G</em>).</p>
</li>
<li><p>Adjacency and incidence</p>
<ul>
<li>Two vertices <em>v</em> and <em>w</em> of a graph <em>G</em> are said to be <em>adjacent</em> if there is an edge joining them.</li>
<li>Two distinct edges of <em>G</em> are <em>adjacent</em> if they have at least one vertex in common.</li>
<li>The vertices <em>v</em> and <em>w</em> are then said to be <em>incident</em> to such an edge.</li>
<li>The <em>degree</em> of a vertex <em>v</em> of <em>G</em> is the number of edges incident to <em>v</em>.</li>
</ul>
</li>
<li><p><strong>Walk, trail, circuit, path, and cycle</strong></p>
<ul>
<li><p>A <em>walk</em> (or <em>edge-sequence</em>) is an alternating sequence of vertices and edges, starting and ending at a vertex, in which each edge is adjacent in the sequence to its two endpoints.</p>
</li>
<li><p>The <em>length</em> of a walk is the number of edges in it.</p>
</li>
<li><p>A <em>trail</em> is a walk in which all the edges are distinct from one another.</p>
</li>
<li><p>A walk is <em>closed</em> if it starts and ends at the same vertex.</p>
</li>
<li><p>A <em>circuit</em> is a trail that is closed.</p>
</li>
<li><p>A <em>path</em> is a walk in which all the vertices are distinct from one another.</p>
</li>
<li><p>A <em>cycle</em> is a path containing at least one edge with an exception that the first and last vertices coincide.</p>
<blockquote>
<p>The definitions differ by various textbooks!!!</p>
</blockquote>
</li>
<li><p>An Eulerian trail is a trail that visits every edge exactly once.</p>
</li>
<li><p>An Eulerian circuit is an Eulerian trail that starts and ends on the same vertex.</p>
</li>
<li><p>A Hamiltonian path is a path that visits each vertex exactly once.</p>
</li>
<li><p>A Hamiltonian cycle is a Hamiltonian path that is a cycle.</p>
<ul>
<li>An Eulerian circuit exists in a connected graph G if the degree of every vertex is even, and can be found in O(|E|) time.</li>
<li>Determining whether such paths and cycles exist in graphs is the Hamiltonian path problem, which is NP-complete.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="table-wrapper scrollbar overflow-hidden">
<table class="comfortable">
<thead>
<tr>
<th></th>
<th>Walk</th>
<th>Trail</th>
<th>Circuit</th>
<th>Path</th>
<th>Cycle</th>
</tr>
</thead>
<tbody>
<tr>
<td>Openness</td>
<td>Open/Closed</td>
<td>Open</td>
<td>Closed</td>
<td>Open</td>
<td>Closed</td>
</tr>
<tr>
<td>Vertex repetition</td>
<td>Allowed</td>
<td>Allowed</td>
<td>Allowed</td>
<td>Disallowed</td>
<td>Disallowed</td>
</tr>
<tr>
<td>Edge repetition</td>
<td>Allowed</td>
<td>Disallowed</td>
<td>Disallowed</td>
<td>Disallowed</td>
<td>Disallowed</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Examples of graphs</p>
<ul>
<li>A <em>null graph</em> is a graph whose edge-set is empty.</li>
<li>A <em>regular graph</em> is a graph in which each vertex has the same degree.</li>
<li>A <em>complete graph</em> is a graph in which each pair of vertices is joined by an edge.</li>
<li>A <em>bipartite graph</em> is a graph in which its vertex set can be partitioned into two sets <em>V</em>1 and <em>V</em>2, in such a way that every edge of the graph joins a vertex of <em>V</em>1 to a vertex of <em>V</em>2.</li>
<li>A <em>connected graph</em> is an undirected graph, in which, given any pair of vertices <em>v</em> and <em>w</em>, there is a path from <em>v</em> to <em>w</em>.
• An arbitrary graph can split up into disjoint connected subgraphs called <em>connected</em> <em>components</em>.</li>
<li>A <em>tree</em> is a connected graph with no cycles.</li>
<li>A <em>forest</em> is a graph with no cycles.</li>
</ul>
</li>
<li><p>Graph isomorphism</p>
<ul>
<li>Two graphs <em>G</em>1 and <em>G</em>2 are <em>isomorphic</em> if there is a one-to-one correspondence between the vertices of <em>G</em>1 and those of <em>G</em>2 with the property that the number of edges joining any two vertices of <em>G</em>1 is equal to the number of edges joining the corresponding vertices of <em>G</em>2.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="graph-representation">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#graph-representation">#</doc-anchor-trigger>
        <span>Graph Representation</span>
    </h3>
</doc-anchor-target>
<doc-anchor-target id="graph-representation-1-adjacency-list">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#graph-representation-1-adjacency-list">#</doc-anchor-trigger>
        <span>Graph Representation 1: Adjacency List</span>
    </h4>
</doc-anchor-target>
<p>In mathematics</p>
<doc-anchor-target id="graph-representation-2-adjacency-matrix">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#graph-representation-2-adjacency-matrix">#</doc-anchor-trigger>
        <span>Graph Representation 2: Adjacency Matrix</span>
    </h4>
</doc-anchor-target>
<p>In mathematics</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">for int A[3][5];
  A[i][j]
= *(A[i] + j)
= (*(A + i))[j]
= *((*(A + i)) + j)
= *(&amp;A[0][0] + 5*i + j)</code></pre>
</doc-codeblock></div>
<ul>
<li><p>In C</p>
</li>
<li><p>Various Costs for a Graph G = (V, E)</p>
</li>
</ul>
<div class="table-wrapper scrollbar overflow-hidden">
<table class="comfortable">
<thead>
<tr>
<th>--</th>
<th>Adjacency list</th>
<th>Adjacency matrix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Space</td>
<td><span class="math">O(|V|+|E|)</span></td>
<td><span class="math">O(|V|^2)</span></td>
</tr>
<tr>
<td>Initialize empty</td>
<td><span class="math">O(|V|)</span></td>
<td><span class="math">O(|V|^2)</span></td>
</tr>
<tr>
<td>Copy after initialization</td>
<td><span class="math">O(|E|)</span></td>
<td><span class="math">O(|V|^2)</span></td>
</tr>
<tr>
<td>Destroy</td>
<td><span class="math">O(|E|)</span></td>
<td><span class="math">O(|V|)</span> or <span class="math">O(1)</span></td>
</tr>
<tr>
<td>Insert vertex u</td>
<td><span class="math">O(1)</span></td>
<td><span class="math">O(|V|)</span> or <span class="math">O(|V|^2)</span></td>
</tr>
<tr>
<td>Insert Edge (u,v)</td>
<td><span class="math">O(1)</span></td>
<td><span class="math">O(1)</span></td>
</tr>
<tr>
<td>Remove vertex u</td>
<td><span class="math">O(|E|)</span></td>
<td><span class="math">O(|V|^2)</span></td>
</tr>
<tr>
<td>Find/Remove edge (u,v)</td>
<td><span class="math">O(|V|)</span></td>
<td><span class="math">O(1)</span></td>
</tr>
<tr>
<td>Are u, v adjacent?</td>
<td><span class="math">O(|V|)</span></td>
<td><span class="math">O(1)</span></td>
</tr>
</tbody>
</table>
</div>
<div class="table-wrapper scrollbar overflow-hidden">
<table class="comfortable">
<thead>
<tr>
<th></th>
<th>Adjacency list</th>
<th>Adjacency matrix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Is v isolated?</td>
<td><span class="math">O(1)</span></td>
<td><span class="math">O(|V|)</span></td>
</tr>
<tr>
<td>find a path from u to v</td>
<td><span class="math">O(|V|+|E|)</span></td>
<td><span class="math">O(|V|^2)</span></td>
</tr>
</tbody>
</table>
</div>
<doc-anchor-target id="some-problems-related-to-graph-search">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#some-problems-related-to-graph-search">#</doc-anchor-trigger>
        <span>Some Problems Related to Graph Search</span>
    </h3>
</doc-anchor-target>
<ul>
<li>Cycle detection
<ul>
<li>Does a given graph have any cycle?</li>
</ul>
</li>
<li>Simple path
<ul>
<li>Given two vertices, is there a path in the graph that connects them?</li>
</ul>
</li>
<li>Simple connectivity
<ul>
<li>Is a graph connected?</li>
</ul>
</li>
<li>Two-way Euler tour
<ul>
<li>Find a path that uses all the edges in a graph exactly twice – once in each direction.</li>
</ul>
</li>
<li>Spanning tree
<ul>
<li>Given a connected graph with n vertices, find a set of n-1 edges that connects the vertices.</li>
</ul>
</li>
<li>Vertex search
<ul>
<li>How many vertices are in the same connected component as a given vertex?</li>
</ul>
</li>
<li>Two-colorability, bipartiteness, odd cycle
<ul>
<li>Is there a way to assign one of two colors to each vertex of a graph such that no edge connects two vertices of the same color?</li>
<li>Is a given graph bipartite?</li>
<li>Does a given graph have a cycle of odd length?</li>
</ul>
</li>
<li>st-connectivity
<ul>
<li>What is the minimum number of edges whose removal will separate two given vertices s and t in a graph?</li>
</ul>
</li>
<li>General connectivity
<ul>
<li>Is a graph k-connected?</li>
<li>Is a given graph k-edge connected?</li>
<li>What is the edge connectivity and the vertex connectivity of a given graph?</li>
</ul>
</li>
<li>Shortest path
<ul>
<li>Find a shortest path in the graph from v to w.</li>
</ul>
</li>
<li>Single-source shortest paths
<ul>
<li>Find shortest paths connecting a given vertex v with each other vertex in the graph.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="2-graph-search">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#2-graph-search">#</doc-anchor-trigger>
        <span>2. Graph Search</span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="1-graph-search-1-depth-first-search-dfs">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#1-graph-search-1-depth-first-search-dfs">#</doc-anchor-trigger>
        <span>1) Graph Search 1: Depth-First Search (DFS)</span>
    </h3>
</doc-anchor-target>
<ul>
<li>자료구조 과목에서 배웠음</li>
</ul>
<doc-anchor-target id="depth-first-search-review">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#depth-first-search-review">#</doc-anchor-trigger>
        <span>Depth-First Search: Review</span>
    </h4>
</doc-anchor-target>
<ul>
<li>A graph structure definition</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">typedef struct _edgenode
{
    int y;               /* adjancency info */
    int weight;          /* edge weight, if any */
    struct _edgenode *next; /* next edge in list */
} edgenode;

typedef struct _graph{
    // The vertices are numbered starting from 1 not 0. edgenode *edges[MAXV + 1];
  /* adjacency info */
    int degree[MAXV + 1]; 
  /* outdegree of each vertex */
    int nvertices;        
  /* number of vertices in the graph */
    int nedges;           
  /* number of edges in the graph */
    int directed;         
  /* is the graph directed? */
} graph;</code></pre>
</doc-codeblock></div>
<ul>
<li>A Recursive implementation in C</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">void dfs(graph *g, int v)
{
    edgenode *p; /* temporary pointer */
    int y;       /* successor vertex */
    entry_time[v] = ++time;
    PROCESS_VERTEX_EARLY(v);
    discovered[v] = TRUE;
    p = g-&gt;edges[v];
    while (p != NULL)
    {
        y = p-&gt;y;
        if (discovered[y] == FALSE)
        {
            parent[y] = v;
            PROCESS_EDGE(v, y, g);
            dfs(g, y);
        }
        else
            PROCESS_EDGE(v, y, g);
        p = p-&gt;next;
    }
    exit_time[v] = ++time;
    PROCESS_VERTEX_LATE(v);
    processed[v] = TRUE;
}</code></pre>
</doc-codeblock></div>
<ul>
<li>parent = predecessor</li>
<li>entry time = discovery time</li>
<li>exit time = finish time</li>
</ul>
<doc-anchor-target id="an-abstract-implementation-using-a-stack">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#an-abstract-implementation-using-a-stack">#</doc-anchor-trigger>
        <span>An Abstract Implementation Using a Stack</span>
    </h4>
</doc-anchor-target>
<ul>
<li>편의상 connected graph로 가정 (아닐 경우에는?)</li>
<li>어떤 연산이 전체 탐색을 dominate하는가?</li>
<li>각 꼭지점은 unvisited 상태에서 스택에 몇 번 push되는가?</li>
<li>전체적으로 각 edge는 몇 번 access되는가?</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">DFS(G, s)
{ // s is the vertex where the DFS starts. Initialize a stack S to be empty;
visited[v] = F for all vertices in G;
Push(S, s);
while (S is not empty)  
  do{  
      v = Pop(S);
      if (visited[v] = F){
        visited[v] = T;
        for (each vertex u that is adjacent to v)
          if (visited[u] = F)
            Push(S, u);
        }
    }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>Time complexity
<ul>
<li>Adjacency list: <span class="math">O(|V|+|E|)</span></li>
<li>Adjacency matrix: <span class="math">O(|V|2)</span></li>
</ul>
</li>
<li>기존에 배운 recursion 기반 구현과 비교할 것</li>
</ul>
<doc-anchor-target id="3-graph-search-2-breadth-first-search-bfs">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#3-graph-search-2-breadth-first-search-bfs">#</doc-anchor-trigger>
        <span>3) Graph Search 2: Breadth-First Search (BFS)</span>
    </h3>
</doc-anchor-target>
<ul>
<li>자료구조 과목에서 배웠음</li>
</ul>
<doc-anchor-target id="an-abstract-implementation-using-a-queue">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#an-abstract-implementation-using-a-queue">#</doc-anchor-trigger>
        <span>An Abstract Implementation Using a Queue</span>
    </h4>
</doc-anchor-target>
<ul>
<li>편의상 connected graph로 가정 (아닐 경우에는?)</li>
<li>어떤 연산이 전체 탐색을 dominate하는가?</li>
<li>각 꼭지점은 unvisited 상태에서 스택에 몇 번 push되는가?</li>
<li>전체적으로 각 edge는 몇 번 access되는가?</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">void BFS(G, s)
{ // s is the vertex where the DFS starts. Initialize a queue Q to be empty;
visited[v] = F for all vertices in G;
visited[s] = T;
Insert(Q, s);
while (Q is not empty){
    v = delete (Q);
    for (each vertex u that is adjacent to v)    {
        if (visited[u] = F){
            visited[u] = T;
            Insert(Q, u);
        }
    }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>Time complexity</li>
<li>Adjacency list: $O(|V|+|E|) $</li>
<li>Adjacency matrix: <span class="math">O(|V|^2)</span></li>
</ul>
<doc-anchor-target id="3-shortest-path-algorithm">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#3-shortest-path-algorithm">#</doc-anchor-trigger>
        <span>3. Shortest Path Algorithm</span>
    </h2>
</doc-anchor-target>
<doc-anchor-target id="floyd-warshall-all-pairs-shortest-path-algorithm">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#floyd-warshall-all-pairs-shortest-path-algorithm">#</doc-anchor-trigger>
        <span>Floyd-Warshall All-Pairs Shortest Path Algorithm</span>
    </h3>
</doc-anchor-target>
<ul>
<li><p>Problem</p>
<ul>
<li>Given a weighted graph <em>G</em> = (<em>V</em>, <em>E</em>) with cost function <em>cost</em>[<em>i</em>][<em>j</em>], find the shortest paths between all pairs of vertices. (<em>V</em> = {<em>v</em>0*, v<em>1</em>, v<em>2</em>, ..., v**n*-1} with |<em>V</em>| = <em>n</em>)</li>
<li>In general, the cost(weight) may be negative, but there must not exist a negative cycle in the graph.</li>
</ul>
</li>
<li><p>A dynamic programming approach</p>
<ul>
<li><p>Let <span class="math">A^k [i][j]</span> be the cost of the shortest path from <em>i</em> to <em>j</em>, using only those intermediate vertices with an index ≤ <em>k</em>.</p>
</li>
<li><p>The goal is to compute <span class="math">A^{n-1} [i][j]</span> $ \forall i,j = 0,1,2,...,n-1$</p>
</li>
<li><p>Optimal substructure for computing <span class="math">A^k [i][j]</span> from <span class="math">A^{k-1} [i][j]</span></p>
<ol>
<li><p>If the shortest path from <em>i</em> to <em>j</em> going through no vertex with index greater than <em>k</em> does not go through the vertex with index <em>k</em></p>
<p><span class="math">A^k [i][j]</span> = <span class="math">A^{k-1} [i][j]</span></p>
</li>
<li><p>If the shortest path from <em>i</em> to <em>j</em> going through no vertex with index greater than <em>k</em> does go through the vertex with index <em>k</em></p>
<p><span class="math">A^k [i][j]</span> = $A^ [i][k] + A^ [k][j] $</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>The table computation</p>
<ul>
<li>Initialization / Table traversal order</li>
<li>Example: <em>k</em> = 4 (<em>A**k</em>[<em>i</em>][<em>j</em>]<em>A**k</em>-1[<em>i</em>][<em>j</em>])</li>
<li>$O(n^3)$time</li>
<li>An in-place implementation is possible.</li>
</ul>
</li>
<li><p>Path reconstruction</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">ref</a></li>
</ul>
</li>
</ul>
<doc-anchor-target id="4-minimum-spanning-trees">
    <h2>
        <doc-anchor-trigger class="header-anchor-trigger" to="#4-minimum-spanning-trees">#</doc-anchor-trigger>
        <span>4. Minimum Spanning Trees</span>
    </h2>
</doc-anchor-target>
<ul>
<li><p>Tree</p>
<ul>
<li>A tree is a connected graph T that contains no cycle.</li>
<li>Other equivalent statements (T = (V, E) where |V| = n)</li>
<li>T contains no cycles, and has n-1 edges.</li>
<li>T is connected, and has n-1 edges.</li>
<li>Any two vertices of T are connected by exactly one path.</li>
<li>T contains no cycles, but the addition of any new edge creates exactly one cycle.</li>
</ul>
</li>
<li><p>Forest</p>
<ul>
<li>A forest is a graph with no cycles.</li>
</ul>
</li>
<li><p>references</p>
<ul>
<li><a href="https://en.wikipedia.org/tree">https://en.wikipedia.org/tree</a></li>
<li><a href="https://www.mathreference.org/">https://www.mathreference.org/</a></li>
</ul>
</li>
<li><p>Buy-Two-Get-One-Free Theorem</p>
<ul>
<li>For a graph G = (V, E) with n vertices, any two of the following three properties imply the third one:
<ol>
<li>G is connected.</li>
<li>G is acyclic.</li>
<li>G has n-1 edges.</li>
</ol>
</li>
</ul>
</li>
<li><p>Minimum spanning tree</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">wiki</a></li>
<li>A spanning tree for a graph G = (V, E) is a tree that contains all the vertices of G.</li>
<li>The cost of a spanning tree of a weighted graph G = (V, E) is the sum of the weights of the edges in the spanning tree.</li>
<li>A minimum spanning tree for a weighted graph G = (V, E) is a spanning tree of least cost.</li>
</ul>
</li>
<li><p>Problem</p>
<ul>
<li>Given a weighted graph G = (V, E), find a minimum spanning tree of G.</li>
</ul>
</li>
<li><p>A naïve approach</p>
<ul>
<li>Examine all the spanning trees of G,and take one having least cost.</li>
<li>There are nn-2 spanning trees in Kn!</li>
</ul>
</li>
</ul>
<doc-anchor-target id="kruskals-algorithm-vs-prims-algorithm-greedy">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#kruskals-algorithm-vs-prims-algorithm-greedy">#</doc-anchor-trigger>
        <span>Kruskal’s Algorithm vs Prim’s Algorithm (Greedy!)</span>
    </h4>
</doc-anchor-target>
<ul>
<li>
<blockquote>
<p>ref. Courtesy of T. Cormen et al.</p>
</blockquote>
</li>
<li><p>Kruskal’s algorithm</p>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest.</li>
</ul>
</li>
<li><p>Prim’s algorithm</p>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="generic-mst-algorithm-and-its-correctness">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#generic-mst-algorithm-and-its-correctness">#</doc-anchor-trigger>
        <span>Generic MST Algorithm and its Correctness</span>
    </h4>
</doc-anchor-target>
<ul>
<li>Generic algorithm for a graph G = (V, E) with a weight function w
<ul>
<li>For an edge set A that is a subset of some MST, an edge (u, v) is called a safe edge for A if A  {(u, v)} is also a subset of some MST.</li>
<li>Loop invariant for a set of edges A
• Prior to each iteration, A is a subset of some minimum spanning tree.</li>
</ul>
</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
    A := empty; 
    // A: a set of edges of G 
    While (A does not form a spanning tree) {
        Find and edge (u, v) that is safe for A;
        A := A  {(u, v)}; 
    }
}</code></pre>
</doc-codeblock></div>
<ul>
<li><p>Some definitions</p>
<blockquote>
<p>Courtesy of T. Cormen et al.</p>
<ul>
<li>A cut (S, V-S) of G is a partition of V.</li>
</ul>
</blockquote>
<ul>
<li>An edge (u, v) of G crosses a cut (S, V-S) if u  S and v  V-S→cut-set.</li>
<li>A cut respects a set A of edges if no edge in A crosses the cut.</li>
<li>An edge is a light edge crossing a cut if its weight is the minimum of any edge crossing the cut.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="cut-property">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#cut-property">#</doc-anchor-trigger>
        <span>Cut Property</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>For any cut C of the graph, if the weight of an edge e in the cut-set of C is strictly smaller than the weights of all other edges of the cut-set of C, then this edge belongs to all MSTs of the graph.</p>
</li>
<li><p>Proof:</p>
<ul>
<li>Assume that there is an MST <span class="math">T</span> that does not contain e.</li>
<li>Adding <span class="math">e</span> to <span class="math">T</span> will produce a cycle, that crosses the cut once at e and crosses back at another edge $e&#x27; $.</li>
<li>Deleting e&#x27; we get a spanning tree <span class="math">T∖{e'}∪{e}</span> of strictly smaller weight than <span class="math">T</span>. This contradicts the assumption that T was a MST.</li>
</ul>
</li>
<li><p>By a similar argument, if more than one edge is of minimum weight across a cut, then each such edge is contained in some minimum spanning tree.</p>
</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
	A := empty; 
	// A: a set of edges of G 
  While (A does not form a spanning tree) {
    Find and edge (u, v) that is safe for A;
    A := A ∪  { (u, v) }; 
  }
}</code></pre>
</doc-codeblock></div>
<ul>
<li><p>Loop invariant for the set A</p>
<ul>
<li>Prior to each iteration, A is a subset of some minimum spanning tree.</li>
</ul>
</li>
<li><p>Theorem</p>
<ul>
<li>Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="selection-of-next-edge-kruskals-algorithm">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#selection-of-next-edge-kruskals-algorithm">#</doc-anchor-trigger>
        <span>Selection of Next Edge: Kruskal’s Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest.</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
  A := empty; 
  // A: a set of edges of G 
  While (A does not form a spanning tree) {
    Find and edge (u, v) that is safe for A;
    A := A ∪ { (u, v) }; 
  }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>Theorem
<ul>
<li>Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="selection-of-next-edge-prims-algorithm">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#selection-of-next-edge-prims-algorithm">#</doc-anchor-trigger>
        <span>Selection of Next Edge: Prim’s Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
  A := empty; // A: a set of edges of G 
  While (A does not form a spanning tree) {
    Find and edge (u, v) that is safe for A;
    A := A ∪ { (u, v) }; }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>Theorem
<ul>
<li>Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A.</li>
</ul>
</li>
</ul>
<p>(2020.12.01 화요일)</p>
<doc-anchor-target id="주제-6-graph-algorithms-1">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#주제-6-graph-algorithms-1">#</doc-anchor-trigger>
        <span>[주제 6] Graph Algorithms</span>
    </h3>
</doc-anchor-target>
<doc-anchor-target id="minimum-spanning-tree">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#minimum-spanning-tree">#</doc-anchor-trigger>
        <span>Minimum Spanning Tree</span>
    </h4>
</doc-anchor-target>
<doc-anchor-target id="kruskals-algorithm-vs-prims-algorithm-greedy-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#kruskals-algorithm-vs-prims-algorithm-greedy-1">#</doc-anchor-trigger>
        <span>Kruskal’s Algorithm vs Prim’s Algorithm (Greedy!)</span>
    </h4>
</doc-anchor-target>
<ul>
<li>
<blockquote>
<p>ref. Courtesy of T. Cormen et al.</p>
</blockquote>
</li>
<li><p>Kruskal’s algorithm</p>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest.</li>
</ul>
</li>
<li><p>Prim’s algorithm</p>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="generic-mst-algorithm-and-its-correctness-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#generic-mst-algorithm-and-its-correctness-1">#</doc-anchor-trigger>
        <span>Generic MST Algorithm and its Correctness</span>
    </h4>
</doc-anchor-target>
<ul>
<li>Generic algorithm for a graph G = (V, E) with a weight function w
<ul>
<li>For an edge set A that is a subset of some MST, an edge (u, v) is called a safe edge for A if A  {(u, v)} is also a subset of some MST.</li>
<li>Loop invariant for a set of edges A
• Prior to each iteration, A is a subset of some minimum spanning tree.</li>
</ul>
</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
    A := empty; 
    // A: a set of edges of G 
    While (A does not form a spanning tree) {
        Find and edge (u, v) that is safe for A;
        A := A  {(u, v)}; 
    }
}</code></pre>
</doc-codeblock></div>
<ul>
<li><p>Some definitions</p>
<blockquote>
<p>Courtesy of T. Cormen et al.</p>
</blockquote>
<ul>
<li>A cut (S, V-S) of G is a partition of V.</li>
<li>An edge (u, v) of G crosses a cut (S, V-S) if u  S and v  V-S→cut-set.</li>
<li>A cut respects a set A of edges if no edge in A crosses the cut.</li>
<li>An edge is a light edge crossing a cut if its weight is the minimum of any edge crossing the cut.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="cut-property-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#cut-property-1">#</doc-anchor-trigger>
        <span>Cut Property</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>For any cut C of the graph, if the weight of an edge e in the cut-set of C is strictly smaller than the weights of all other edges of the cut-set of C, then this edge belongs to all MSTs of the graph.</p>
</li>
<li><p>Proof:</p>
<ul>
<li>Assume that there is an MST <span class="math">T</span> that does not contain e.</li>
<li>Adding <span class="math">e</span> to <span class="math">T</span> will produce a cycle, that crosses the cut once at e and crosses back at another edge $e&#x27; $.</li>
<li>Deleting e&#x27; we get a spanning tree <span class="math">T∖{e'}∪{e}</span> of strictly smaller weight than <span class="math">T</span>. This contradicts the assumption that T was a MST.</li>
</ul>
</li>
<li><p>By a similar argument, if more than one edge is of minimum weight across a cut, then each such edge is contained in some minimum spanning tree.</p>
</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
	A := empty; 
	// A: a set of edges of G 
  While (A does not form a spanning tree) {
    Find and edge (u, v) that is safe for A;
    A := A ∪  { (u, v) }; 
  }
}</code></pre>
</doc-codeblock></div>
<ul>
<li><p>Loop invariant for the set A</p>
<ul>
<li>Prior to each iteration, A is a subset of some minimum spanning tree.</li>
</ul>
</li>
<li><p>Theorem</p>
<ul>
<li>Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="selection-of-next-edge-kruskals-algorithm-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#selection-of-next-edge-kruskals-algorithm-1">#</doc-anchor-trigger>
        <span>Selection of Next Edge: Kruskal’s Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects any two trees in the (current) forest.</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
  A := empty; 
  // A: a set of edges of G 
  While (A does not form a spanning tree) {
    Find and edge (u, v) that is safe for A;
    A := A ∪ { (u, v) }; 
  }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>Theorem
<ul>
<li>Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="selection-of-next-edge-prims-algorithm-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#selection-of-next-edge-prims-algorithm-1">#</doc-anchor-trigger>
        <span>Selection of Next Edge: Prim’s Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Generic-MST(G) {
  A := empty; // A: a set of edges of G 
  While (A does not form a spanning tree) {
    Find and edge (u, v) that is safe for A;
    A := A ∪ { (u, v) }; }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>Theorem
<ul>
<li>Let G = (V, E) be a connected, undirected graph with a real-valued weight function w defined on E. Let A be a set of E that is included in some minimum spanning tree for G, let (S, V-S) be any cut of G that respects A, and let (u, v) be a light edge crossing (S, V-S). Then, edge (u, v) is safe for A.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="kruskals-minimum-spanning-tree-algorithm">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#kruskals-minimum-spanning-tree-algorithm">#</doc-anchor-trigger>
        <span>Kruskal’s Minimum Spanning Tree Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>Idea</p>
<ul>
<li>Finds an edge of the least possible weight that connects any two trees in the forest.</li>
</ul>
</li>
<li><p>Implementation using disjoint-set data structure</p>
<ul>
<li>매 단계 forest를 어떻게 관리할 것인가?</li>
<li>두 tree를 어떻게 병합할 것인가?</li>
<li>매 단계 (u, v)를 어떻게 선택할 것인가?</li>
</ul>
</li>
<li><p>Complexity</p>
<ul>
<li>Sort the edges by weight: <span class="math">O(E log E)</span></li>
<li>Process the edges until a tree is built: <span class="math">O(E log V)</span></li>
<li><span class="math">O(E log E + E log V) = O(E log V)</span>
<ul>
<li>why?</li>
</ul>
</li>
</ul>
</li>
</ul>
<doc-anchor-target id="an-implementation-of-the-kruskals-algorithm">
    <h5>
        <doc-anchor-trigger class="header-anchor-trigger" to="#an-implementation-of-the-kruskals-algorithm">#</doc-anchor-trigger>
        <span>An implementation of the Kruskal’s algorithm</span>
    </h5>
</doc-anchor-target>
<ul>
<li>from <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/">http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/</a></li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">// C++ program for Kruskal's algorithm
// to find Minimum Spanning Tree of a
// given connected, undirected and weighted
// graph
#include &lt;bits/stdc++.h&gt;
using namespace std;

// a structure to represent a
// weighted edge in graph
class Edge {
public:
	int src, dest, weight;
};

// a structure to represent a connected,
// undirected and weighted graph
class Graph {
public:
	
	// V-&gt; Number of vertices, E-&gt; Number of edges
	int V, E;

	// graph is represented as an array of edges.
	// Since the graph is undirected, the edge
	// from src to dest is also edge from dest
	// to src. Both are counted as 1 edge here.
	Edge* edge;
};

// Creates a graph with V vertices and E edges
Graph* createGraph(int V, int E)
{
	Graph* graph = new Graph;
	graph-&gt;V = V;
	graph-&gt;E = E;

	graph-&gt;edge = new Edge[E];

	return graph;
}

// A structure to represent a subset for union-find
class subset {
public:
	int parent;
	int rank;
};

// A utility function to find set of an element i
// (uses path compression technique)
int find(subset subsets[], int i)
{
	// find root and make root as parent of i
	// (path compression)
	if (subsets[i].parent != i)
		subsets[i].parent
			= find(subsets, subsets[i].parent);

	return subsets[i].parent;
}

// A function that does union of two sets of x and y
// (uses union by rank)
void Union(subset subsets[], int x, int y)
{
	int xroot = find(subsets, x);
	int yroot = find(subsets, y);

	// Attach smaller rank tree under root of high
	// rank tree (Union by Rank)
	if (subsets[xroot].rank &lt; subsets[yroot].rank)
		subsets[xroot].parent = yroot;
	else if (subsets[xroot].rank &gt; subsets[yroot].rank)
		subsets[yroot].parent = xroot;

	// If ranks are same, then make one as root and
	// increment its rank by one
	else {
		subsets[yroot].parent = xroot;
		subsets[xroot].rank++;
	}
}

// Compare two edges according to their weights.
// Used in qsort() for sorting an array of edges
int myComp(const void* a, const void* b)
{
	Edge* a1 = (Edge*)a;
	Edge* b1 = (Edge*)b;
	return a1-&gt;weight &gt; b1-&gt;weight;
}

// The main function to construct MST using Kruskal's
// algorithm
void KruskalMST(Graph* graph)
{
	int V = graph-&gt;V;
	Edge result[V]; // Tnis will store the resultant MST
	int e = 0; // An index variable, used for result[]
	int i = 0; // An index variable, used for sorted edges

	// Step 1: Sort all the edges in non-decreasing
	// order of their weight. If we are not allowed to
	// change the given graph, we can create a copy of
	// array of edges
	qsort(graph-&gt;edge, graph-&gt;E, sizeof(graph-&gt;edge[0]),
		myComp);

	// Allocate memory for creating V ssubsets
	subset* subsets = new subset[(V * sizeof(subset))];

	// Create V subsets with single elements
	for (int v = 0; v &lt; V; ++v)
	{
		subsets[v].parent = v;
		subsets[v].rank = 0;
	}

	// Number of edges to be taken is equal to V-1
	while (e &lt; V - 1 &amp;&amp; i &lt; graph-&gt;E)
	{
		// Step 2: Pick the smallest edge. And increment
		// the index for next iteration
		Edge next_edge = graph-&gt;edge[i++];

		int x = find(subsets, next_edge.src);
		int y = find(subsets, next_edge.dest);

		// If including this edge does't cause cycle,
		// include it in result and increment the index
		// of result for next edge
		if (x != y) {
			result[e++] = next_edge;
			Union(subsets, x, y);
		}
		// Else discard the next_edge
	}

	// print the contents of result[] to display the
	// built MST
	cout &lt;&lt; &quot;Following are the edges in the constructed &quot;
			&quot;MST\n&quot;;
	int minimumCost = 0;
	for (i = 0; i &lt; e; ++i)
	{
		cout &lt;&lt; result[i].src &lt;&lt; &quot; -- &quot; &lt;&lt; result[i].dest
			&lt;&lt; &quot; == &quot; &lt;&lt; result[i].weight &lt;&lt; endl;
		minimumCost = minimumCost + result[i].weight;
	}
	// return;
	cout &lt;&lt; &quot;Minimum Cost Spanning Tree: &quot; &lt;&lt; minimumCost
		&lt;&lt; endl;
}

// Driver code
int main()
{
	/* Let us create following weighted graph
			10
		0--------1
		| \ |
	6| 5\ |15
		| \ |
		2--------3
			4 */
	int V = 4; // Number of vertices in graph
	int E = 5; // Number of edges in graph
	Graph* graph = createGraph(V, E);

	// add edge 0-1
	graph-&gt;edge[0].src = 0;
	graph-&gt;edge[0].dest = 1;
	graph-&gt;edge[0].weight = 10;

	// add edge 0-2
	graph-&gt;edge[1].src = 0;
	graph-&gt;edge[1].dest = 2;
	graph-&gt;edge[1].weight = 6;

	// add edge 0-3
	graph-&gt;edge[2].src = 0;
	graph-&gt;edge[2].dest = 3;
	graph-&gt;edge[2].weight = 5;

	// add edge 1-3
	graph-&gt;edge[3].src = 1;
	graph-&gt;edge[3].dest = 3;
	graph-&gt;edge[3].weight = 15;

	// add edge 2-3
	graph-&gt;edge[4].src = 2;
	graph-&gt;edge[4].dest = 3;
	graph-&gt;edge[4].weight = 4;


	// Function call
	KruskalMST(graph);

	return 0;
}

// This code is contributed by rathbhupendra
</code></pre>
</doc-codeblock></div>
<doc-anchor-target id="prims-minimum-spanning-tree-algorithm">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#prims-minimum-spanning-tree-algorithm">#</doc-anchor-trigger>
        <span>Prim’s Minimum Spanning Tree Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>Idea</p>
<ul>
<li>In each step, find and add an edge of the least possible weight that connects the (current) tree to a non-tree vertex.</li>
</ul>
</li>
<li><p>Algorithm</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">Given G = (V, E),
Begin with a tree T0 = (V0, E0) where V0 = {v1} and E0 = {}. 
repeat { 
  // Ti = (Vi, Ei)→Ti+1 = (Vi +1, Ei +1)
  Select a vertex v in V - Vi that is nearest to Vi. 
    // Let v is from the edge (u, v), where u in Vi.
    Update T in such a way that
    	Vi +1 = Vi + {v}, and Ei +1 = Ei + {(u, v)}.
until (an MST is found)
</code></pre>
</doc-codeblock></div>
</li>
<li><p>A key issue in implementation</p>
<ul>
<li>Tree vertices와 non-tree vertices들을 어떻게 관리할 것인가?</li>
<li>Tree vertices와 non-tree vertices들 간의 최소 비용 edge를 어떻게 (효율적으 로) 찾을 것인가?</li>
</ul>
</li>
<li><p>From Prof. Kenji Ikeda&#x27;s Home Page</p>
</li>
</ul>
<doc-anchor-target id="inductive-description-of-the-prims-algorithm">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#inductive-description-of-the-prims-algorithm">#</doc-anchor-trigger>
        <span>Inductive Description of the Prim’s Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li><span class="math">V=\{ v_0,v_1,v_2,...,v_{n-1} \}</span> with <span class="math">|V| = n</span></li>
<li><span class="math">T^k →T^{k+1}</span>
<ul>
<li>매번 가장 비용이 낮은 fringe edge를 선택하여 <span class="math">T^k</span> 로 옮긴 후 그에 따른 처리를 함.</li>
</ul>
</li>
</ul>
<doc-anchor-target id="an--implementation-adjacency-matrix-사용">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#an--implementation-adjacency-matrix-사용">#</doc-anchor-trigger>
        <span>An <span class="math">O(n^2)</span> Implementation: Adjacency Matrix 사용</span>
    </h4>
</doc-anchor-target>
<ul>
<li>a = 0, b = 1, c = 2, d = 3, e = 4, f = 5, g = 6, h = 7, i = 8, j = 9</li>
<li>st[i]: T로 선택된 vertex i의 parent vertex 번 호 저장</li>
<li>fr[i]: NT에 있는 vertex i에서 T에 있는 vertex 중 가장 가까운 vertex의 번호</li>
<li>wt[i]: NT에 있는 vertex i에 대해 그 vertex 에서 fr[i]까지의 거리</li>
</ul>
<div class="table-wrapper scrollbar overflow-hidden">
<table class="comfortable">
<thead>
<tr>
<th><strong>v</strong></th>
<th><strong>st[v]</strong></th>
<th><strong>fr[v]</strong></th>
<th><strong>wt[v]</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0(a)</td>
<td>0</td>
<td>0</td>
<td>maxWT</td>
</tr>
<tr>
<td>1(b)</td>
<td>3</td>
<td>3</td>
<td>13</td>
</tr>
<tr>
<td>2(c)</td>
<td>0</td>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>3(d)</td>
<td>2</td>
<td>2</td>
<td>23</td>
</tr>
<tr>
<td>4(e)</td>
<td>6</td>
<td>6</td>
<td>17</td>
</tr>
<tr>
<td>5(f)</td>
<td>-1</td>
<td>2</td>
<td>24</td>
</tr>
<tr>
<td>6(g)</td>
<td>3</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>7(h)</td>
<td>-1</td>
<td>4</td>
<td>35</td>
</tr>
<tr>
<td>8(i)</td>
<td>-1</td>
<td>6</td>
<td>45</td>
</tr>
<tr>
<td>9(j)</td>
<td>-1</td>
<td>6</td>
<td>42</td>
</tr>
<tr>
<td>10</td>
<td></td>
<td></td>
<td>maxWT</td>
</tr>
</tbody>
</table>
</div>
<p>n=| V|</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">static int fr[maxV];
#define P G-&gt;adj[v][w]
void GRAPHmstV(Graph G, int st[], double wt[])
{

    int v, w, min, n = G-&gt;V;
    for (v = 0; v &lt; n; v++)
    {

        st[v] = -1;
        fr[v] = v;
        wt[v] = maxWT;
    }

    wt[**n * *] = **maxWT * *;

    // wt[n] : dummy vertex, maxWT: dummy weight
    // Check to see whether adding the new edge brought any nontree vertex closer to the tree. Find the next edge to add to the tree.
    for (min = 0; min != n;){            
      //언제 끝날까?
        v = min; //다음으로 선택된 vertex 번호
        st[min] = fr[min];
        for (w = 0, min = n; w &lt; n; w++)
//아직 선택되지 않은 모든 vertex w에 대해, v = min이 선택된 것에 대한 update 수행
            if (st[w] == -1)
            {
                if (P &lt; wt[w])
                {
                    wt[w] = P;
                    fr[w] = v;
                }
                if (wt[w] &lt; wt[min])
                    min = w;
//wt[w]를 update하면서, 동시에 가장 작은 wt 값을 가지는 vertex 번호 min을 계산
            }
    }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>모든 계산이 끝난 후 wt[i]는 어떤 정보를 가지고 있을까?</li>
</ul>
<doc-anchor-target id="an-oe-log-n-implementation-adjacency-list-사용">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#an-oe-log-n-implementation-adjacency-list-사용">#</doc-anchor-trigger>
        <span>An O(e log n) Implementation: Adjacency List 사용</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>Observations</p>
<ul>
<li>The inner for-loop in the O(n2) implementation visits all the vertices to update wt[] array and to find the minimum.</li>
<li>An O(e log n) time implementation is possible.
<ul>
<li>If the graph is dense, <span class="math">n^2 logn</span></li>
<li>If the graph is sparse, <span class="math">n log n</span></li>
</ul>
</li>
<li>n = | V |, e = | E |</li>
</ul>
</li>
<li><p>We need to employ the priority queue that allows</p>
<ul>
<li>to insert a new item (PQinsert(w)),</li>
<li>to delete the minimum item (w = PQdelmin()), and</li>
<li>to change the priority of an arbitrary specified item (PQdec(w)).</li>
</ul>
</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">typedef struct node *link;
struct node
{
    int v;
    double wt, link next;
};

struct graph
{
    int V;
    int E;
    link *adj;
};</code></pre>
</doc-codeblock></div>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">typedef struct graph *Graph;
#define GRAPHpfs GRAPHmst static int fr[maxV];
static double *priority;
// Put the priority queue codes here. #define P t-&gt;wt

void GRAPHpfs(Graph G, int st[], double wt[]){
    link t;
    int v, w;
    PQinit();
    priority = wt;

    for (v = 0; v &lt; G-&gt;V; v++){
        st[v] = -1;
        fr[v] = -1;
    }
    fr[0] = 0;
    PQinsert(0 **) * *;
    while (!PQempty()){
      v = PQdelmin();
      st[v] = fr[v];
      for (t = G-&gt;adj[v]; t != NULL; t = t-&gt;next){
        if (fr[w = t-&gt;v] == -1){
          wt[w] = P;
          PQinsert (w);
          fr[w] = v;
        }
      	else if ((st[w] == -1) &amp;&amp; (P &lt; wt[w])){
          wt[w] = P;
          PQdec (w);
          fr[w] = v;
        }
      }
    }
}
</code></pre>
</doc-codeblock></div>
<p>15 - 1</p>
<p>2020.12.08 화요일</p>
<doc-anchor-target id="주제-6-graph-algorithms-2">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#주제-6-graph-algorithms-2">#</doc-anchor-trigger>
        <span>[주제 6] Graph Algorithms</span>
    </h3>
</doc-anchor-target>
<doc-anchor-target id="shortest-paths-problems">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#shortest-paths-problems">#</doc-anchor-trigger>
        <span>Shortest-Paths Problems</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p><a href="https://datascience.lc/2019/10/26/shortest-path-dijkstra-algorithm/">https://datascience.lc/2019/10/26/shortest-path-dijkstra-algorithm/</a></p>
</li>
<li><p>Single-source shortest-paths problem</p>
<ul>
<li>Dijkstra’s algorithm
<ul>
<li>Only nonnegative-weight edges are present.</li>
</ul>
</li>
<li>Bellman-Ford algorithm
<ul>
<li>Negative-weight edges may be present, but there are no negative-weight cycles.</li>
</ul>
</li>
</ul>
</li>
<li><p>Single-destination shortest-paths problem</p>
</li>
<li><p>Singe-pair shortest-path problem</p>
</li>
<li><p>All-pairs shortest-paths problem</p>
<ul>
<li>Floyd-Warshall algorithm
<ul>
<li>Negative-weight edges may be present, but there are no negative-weight cycles.</li>
</ul>
</li>
<li>Johnson’s algorithm for sparse graphs
<ul>
<li>Negative-weight edges may be present, but there are no negative-weight cycles.</li>
</ul>
</li>
</ul>
</li>
<li><p>The optimal-substructure property of shortest paths</p>
<ul>
<li>Subpaths of shortest paths are shortest paths!</li>
</ul>
</li>
</ul>
<doc-anchor-target id="single-source-shortest-path">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#single-source-shortest-path">#</doc-anchor-trigger>
        <span>Single-Source Shortest Path</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>Problem</p>
<ul>
<li>Given a weighted directed graph G = (V, E) with a weighting function w(e) (w(e) ≥ 0 for the edges in G), and a source vertex v0, find a shortest path from v0 to each of the remaining vertices of G.</li>
</ul>
</li>
<li><p>Note</p>
<ul>
<li>The case of an undirected graph can be handled by simply replacing each undirected edge e = (u, v) of length w(e) by two directed edges (u, v) and (v, u), each of the same length.</li>
<li>Only the case of a directed graph whose weights are positive (or nonnegative) is handled by the Dijkstra’s algorithm. For a graph that allows a negative weight, the Bellman-Ford algorithm is one to be used.</li>
<li>Before learning the single-source shortest path algorithm that builds some tree, recall how the breadth first search tries to build a BFS tree.</li>
<li>A breadth first search tree</li>
<li>A tree built by the Dijkstra’s algorithm</li>
</ul>
</li>
</ul>
<doc-anchor-target id="dijkstras-single-source-shortest-path-algorithm">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#dijkstras-single-source-shortest-path-algorithm">#</doc-anchor-trigger>
        <span>Dijkstra’s Single-Source Shortest Path Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li>A greedy approach
<ul>
<li>Generate the shortest paths in non-decreasing order of lengths!</li>
</ul>
</li>
</ul>
<ol>
<li><p>$S^1={ v_0 } $로 설정하고 시작.</p>
</li>
<li><p>($i=k$일 때) $S<sup>k$의 꼭지점들만 사용할 경우에 대한 $v_0$에서 $v$까지의 shortest path가 구해져 있음. ($v$는 $S</sup>k$의 꼭지점)</p>
</li>
<li><p>$S<sup>k$상황에서 가장 짧은 path에 대한 꼭지점 $v$를 $S</sup>k$로 옮긴 후 적절한 처리를 수행 → <span class="math">S^{k+1}</span></p>
</li>
<li><p>($i = k+1$일 때) <span class="math">S^{k+1}</span> 의 꼭지점들만 사용할 경우에 대한 $v_0$에서 $v$까지의 shortest path가 구해져 있음. ($v$는 $S^{k+1}$의 꼭지점)</p>
<ul>
<li>다시 2. 로 감</li>
</ul>
</li>
<li><p>Sn이 다 구해졌을 경우</p>
</li>
</ol>
<doc-anchor-target id="from-prof-kenji-ikedas-home-page">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#from-prof-kenji-ikedas-home-page">#</doc-anchor-trigger>
        <span>From Prof. Kenji Ikeda&#x27;s Home Page</span>
    </h4>
</doc-anchor-target>
<doc-anchor-target id="dijkstras-algorithm">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#dijkstras-algorithm">#</doc-anchor-trigger>
        <span>Dijkstra’s Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>(from Introduction to Algorithms by T. Cormen)</p>
</li>
<li><p>A directed graph with nonnegative weight <span class="math">G(V, E)</span> with <span class="math">w: E→ [0,∞)</span> and source <span class="math">s</span></p>
</li>
<li><p>Two components for each vertex <span class="math">v</span></p>
<ul>
<li><p><span class="math">v.d</span>: an upper bound on the weight of a shortest path from s to v (a shortest path estimate)</p>
</li>
<li><p><span class="math">v.π</span>: the predecessor of v in the (current) shortest path</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-markdown"><code v-pre class="language-markdown">Initialize-Single-Source(G,s)
for each vertex v in G.V
	v.d = infinite
	v.pi = NIL
s.d = 0</code></pre>
</doc-codeblock></div>
</li>
</ul>
</li>
<li><p>Relaxation</p>
<ul>
<li><p>The process of relaxing an edge (u, v) consists of testing whether we can improve the shortest path to v found so far by going through u and, if so, updating v.d and v.π.</p>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-markdown"><code v-pre class="language-markdown">Relax(u,v,w)
if v.d &gt; u.d + w(u,v)
	v.d = u.d + w(u,v)
	v.pi = u</code></pre>
</doc-codeblock></div>
<ul>
<li>아직 shortest path를 찾지 못한 vertex v에 대해</li>
<li>새롭게 선택된 vertex u에 adjacent한 vertex v에 대해</li>
</ul>
</li>
</ul>
</li>
<li><p>Dijkstra’s algorithm</p>
<ul>
<li><p>Maintains a set S of vertices whose final shortest-path weight from the source s have already been determined.</p>
<ol>
<li>Select repeatedly the vertex u in V-S with the minimum shortest-path estimate</li>
<li>
<ol start="2">
<li>adds u to S, and 3. relaxes all edges leaving u.</li>
</ol>
</li>
</ol>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-markdown"><code v-pre class="language-markdown">Dijkstra(G,w,s)
Initialize-Single-Source(G,s)
S = zero-set
Q = G.V
while Q != zero-set
	u= extract-min(Q)
	S= S U {u}
	for each vertex v in G.Adj[u]
		Relax(u,v,w)</code></pre>
</doc-codeblock></div>
</li>
<li><p>When the algorithm adds a vertex u to the set S, u.d is the final shortest-path weight from s to u.</p>
</li>
</ul>
</li>
</ul>
<p>15-2</p>
<p>2020.12.10 목요일</p>
<doc-anchor-target id="주제-6-graph-algorithms-3">
    <h3>
        <doc-anchor-trigger class="header-anchor-trigger" to="#주제-6-graph-algorithms-3">#</doc-anchor-trigger>
        <span>[주제 6] Graph Algorithms</span>
    </h3>
</doc-anchor-target>
<doc-anchor-target id="dijkstras-single-source-shortest-path-algorithm-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#dijkstras-single-source-shortest-path-algorithm-1">#</doc-anchor-trigger>
        <span>Dijkstra’s Single-Source Shortest Path Algorithm</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>Dijkstra’s algorithm</p>
<ul>
<li>Maintains a set S of vertices whose final shortest-path weight from the source s have already been determined.</li>
</ul>
<ol>
<li>Select repeatedly the vertex u in V-S with the minimum shortest-path estimate</li>
<li>adds u to S, and 3. relaxes all edges leaving u.</li>
</ol>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-markdown"><code v-pre class="language-markdown">Dijkstra(G,w,s)
Initialize-Single-Source(G,s)
S = zero-set
Q = G.V
while Q != zero-set
  u= extract-min(Q)
  S= S U {u}
  for each vertex v in G.Adj[u]
  	Relax(u,v,w)</code></pre>
</doc-codeblock></div>
<ul>
<li>When the algorithm adds a vertex u to the set S, u.d is the final shortest-path weight from s to u.</li>
<li>계산과정 예</li>
</ul>
</li>
<li><p>Correctness of Dijkstra’s algorithm</p>
<ul>
<li>Theorem
<ul>
<li>Dijkstra algorithm, run on a weighted, directed graph $ G=(V,E)$ with nonnegative weight function $w : E \rightarrow R $ and source <span class="math">s</span>, terminates with <span class="math">v.d = \delta(s,v)</span> $\forall $vertices <span class="math">v \in V</span></li>
</ul>
</li>
<li>Loop invariant
<ul>
<li>At the start of each iteration of the while loop of lines 4-8, <span class="math">v.d = \delta(s,v)</span> for each vertex $ v \in S$</li>
</ul>
</li>
<li>A key in the proof
<ul>
<li>to show that for each vertex $ u \in V$, we have <span class="math">u.d = \delta(s,u)</span> at the time when <span class="math">u</span> is added to set <span class="math">S</span></li>
<li>Suppose for contradiction that <span class="math">u</span> be the first vertex for which <span class="math">u.d \neq \delta(s,u)</span> when it is added to set <span class="math">S</span></li>
</ul>
</li>
<li>s ---&gt; x -&gt;y가 shortest path이므로, x가 S에 add 되면서 x-&gt;y에 relaxation할 때, y.d에 δ(s, y)가 저장. 따라서 u가 S에 add가 될 때에도 y.d = δ(s, y).</li>
</ul>
</li>
</ul>
<doc-anchor-target id="an--implementation--adjacency-matrix-사용">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#an--implementation--adjacency-matrix-사용">#</doc-anchor-trigger>
        <span>An <span class="math">O(n^2)</span> Implementation : Adjacency Matrix 사용</span>
    </h4>
</doc-anchor-target>
<ul>
<li><p>S: the set of vertices, including <span class="math">v_0</span>, whose shortest paths have been found</p>
</li>
<li><p>distance[w]: the length of the shortest path starting from <span class="math">v_0</span>, going through vertices only in S, and ending in w (w not in S)</p>
</li>
<li><p>Observations</p>
<ul>
<li><em>When the shortest paths are generated in nondecreasing order of length,</em></li>
</ul>
</li>
<li><p>If the next shortest path is to vertex <em>u</em>, then the path from <em>v</em>0 to <em>u</em> goes through only those vertices that are in <em>S</em>.</p>
</li>
<li><p>Vertex <em>u</em> is chosen so that it has the minimum distance <em>distance</em>[<em>u</em>] among all the vertices not in <em>S</em>.</p>
</li>
<li><p>Adding <em>u</em> to <em>S</em> may change the distance of shortest paths starting at <em>v</em>0 going through vertices only in the new <em>S</em>, and ending at a vertex <em>w</em> that is not currently in the new <em>S</em>.</p>
</li>
<li><p><span class="math">distance[w]  = min\{distance[w], distance[u] + length(&lt;u, w&gt;) \}</span></p>
</li>
<li><p><span class="math">V = \{ v_0, v_1, ..., v_{n-1}\}</span> with <span class="math">|V| = n</span></p>
</li>
<li><p>code in [Horowitz]</p>
</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">int choose(int distance[], int n, int found[])
{
    int i, min = INT_MAX,
           minpos = -1;
    for (i = 0; i &lt; n; i++) // O(n)
        if (distance[i] &lt; min &amp;&amp; !found[i])
        {
            min = distance[i];
            minpos = i;
        }
    return minpos;
}
void shortestpath(int v,
                  int cost[][MAX_VERTICES],
                  int distance[], int n, int found[])
{
    int i, u, w, tmp;
    for (i = 0; i &lt; n; i++)
    {
        found[i] = FALSE;
        distance[i] = cost[v][i];
    }
    found[v] = TRUE;
    distance[v] = 0;
    for (i = 0; i &lt; n - 2; i++)
    { // O(n)
        // find the next u to be added to S
        u = choose(distance, n, found);
        found[u] = TRUE; // add u to S for (w = 0; w &lt; n; w++)
        if (!found[w])   // for w not in S
        if ((tmp = distance[u] +
    }
}
cost[u][w]) &lt; distance[w]) distance[w] = tmp;</code></pre>
</doc-codeblock></div>
<ul>
<li><span class="math">distance[i]</span> : the length of the SP from vertex v to i</li>
<li><span class="math">found[i]</span>
<ul>
<li><span class="math">FALSE</span> if the SP from vertex i has not been found,</li>
<li><span class="math">TRUE</span> otherwise</li>
</ul>
</li>
<li><span class="math">cost[i][j]</span> : cost adjacency matrix</li>
</ul>
<doc-anchor-target id="an-oe-log-n-implementation-adjacency-list-사용-1">
    <h4>
        <doc-anchor-trigger class="header-anchor-trigger" to="#an-oe-log-n-implementation-adjacency-list-사용-1">#</doc-anchor-trigger>
        <span>An O(e log n) Implementation: Adjacency List 사용</span>
    </h4>
</doc-anchor-target>
<ul>
<li>매 순간 $wt[w]$에는 항상 <em>S**k</em> 의 꼭지점들만 사용할 경우에 대한 <em>v**s</em>에서 <em>w</em>까지의 shortest path의 길이가 저장되어 있음.</li>
<li>wt[]는 앞의 프로그램에서의 distance[]에 해당</li>
</ul>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">typedef struct node \*link;
struct node
{
    int v;
    double wt;
    link next;
};
struct graph
{
    int V;
    int E;
    link *adj;
};
typedef struct graph *Graph;</code></pre>
</doc-codeblock></div>
<div class="codeblock-wrapper"><doc-codeblock>
<pre class="language-cpp"><code v-pre class="language-cpp">#define GRAPHpfs GRAPHspt
#define P(wt[v] + t-&gt;wt) 
void GRAPHpfs(Graph G, int s, int st[],​ double wt[]){
    
  int v, w;
  link t;
  PQinit();
  priority = wt;
  for (v = 0; v &lt; G-&gt;V; v++){
    st[v] = -1;
    wt[v] = maxWT;
    PQinsert(v);
  }
  wt[s] = 0.0;
  PQdec(s);
  while (!PQempty())// 언제 끝날까?
    if (wt[v = PQdelmin()] ! = maxWT) //어떤 경우인가?
      for (t = G-&gt;adj[v]; t != NULL; t = t-&gt;next)
        if (P &lt; wt[w = t-&gt;v]){
          wt[w] = P;          
          PQdec(w); 
         //다 끝난 후 각 꼭지점에 대한 sp를 어떻게 출력할까?
          st[w] = v;  
        }
    }
}</code></pre>
</doc-codeblock></div>
<ul>
<li>MO ̈HRING et at., Partitioning Graphs to Speedup Dijkstra’s Algorithm, ACM Journal of Experimental Algorithmics, 2006.
<ul>
<li>Standard Dijkstra’s Algorithm</li>
<li>Acceleration Algorithm</li>
</ul>
</li>
</ul>

                                <div class="flex items-center mt-6 mb-6 clear-both">
                                    <span>
                                        <a href="../../tags/">
                                            <svg class="inline-block -mb-px mr-1.5 text-blue-500 dark:text-blue-400" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" overflow="visible" fill="currentColor"><g><path d="M21.3 9.88l-8.59-8.59C12.52 1.11 12.27 1 12 1H2c-.55 0-1 .45-1 1v10c0 .27.11.52.29.71l8.59 8.58c.57.57 1.32.88 2.12.88s1.55-.31 2.12-.88l7.17-7.17a3.009 3.009 0 00.01-4.24zm-1.42 2.82l-7.17 7.17c-.39.39-1.02.39-1.42 0L3 11.59V3h8.59l8.29 8.29c.39.39.39 1.03 0 1.41z" /><path d="M7.01 6C6.45 6 6 6.45 6 7s.45 1 1 1 1-.45 1-1-.44-1-.99-1z" /></g></svg>
                                        </a>
                                        <span class="mr-2"><a href="../../tags/alg/" class="no-link inline-flex items-center justify-center font-medium leading-none whitespace-nowrap text-blue-500 dark:text-blue-400 border border-blue-500 dark:border-blue-400 hover:bg-blue-100 dark:hover:bg-transparent dark:hover:border-blue-200 dark:hover:text-blue-200 transition-colors duration-200 ease-out h-6 px-2 text-xs rounded-md">
                                    <span>alg</span>
                                </a></span>
                                    </span>
                                </div>
                
                                <!-- Required only on API pages -->
                                <doc-toolbar-member-filter-no-results />
                            </div>
                            <footer class="clear-both">
                            
                                <nav class="flex mt-14">
                                    <div class="w-1/2">
                                        <a class="px-5 py-4 h-full flex items-center break-normal font-medium text-blue-500 dark:text-blue-400 border border-gray-300 hover:border-gray-400 dark:border-dark-650 dark:hover:border-dark-450 rounded-l-lg transition-colors duration-150 relative hover:z-5" href="../../algorithm/sub4/">
                                            <svg xmlns="http://www.w3.org/2000/svg" class="mr-3" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M19 11H7.41l5.29-5.29a.996.996 0 10-1.41-1.41l-7 7a1 1 0 000 1.42l7 7a1.024 1.024 0 001.42-.01.996.996 0 000-1.41L7.41 13H19c.55 0 1-.45 1-1s-.45-1-1-1z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
                                            <span>
                                                <span class="block text-xs font-normal text-gray-400 dark:text-dark-400">Previous</span>
                                                <span class="block mt-1">DP</span>
                                            </span>
                                        </a>
                                    </div>
                            
                                    <div class="w-1/2">
                                        <a class="px-5 py-4 -mx-px h-full flex items-center justify-end break-normal font-medium text-blue-500 dark:text-blue-400 border border-gray-300 hover:border-gray-400 dark:border-dark-650 dark:hover:border-dark-450 rounded-r-lg transition-colors duration-150 relative hover:z-5" href="../../algorithm/sub5/">
                                            <span>
                                                <span class="block text-xs font-normal text-right text-gray-400 dark:text-dark-400">Next</span>
                                                <span class="block mt-1">Greedy Method</span>
                                            </span>
                                            <svg xmlns="http://www.w3.org/2000/svg" class="ml-3" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" overflow="visible"><path d="M19.92 12.38a1 1 0 00-.22-1.09l-7-7a.996.996 0 10-1.41 1.41l5.3 5.3H5c-.55 0-1 .45-1 1s.45 1 1 1h11.59l-5.29 5.29a.996.996 0 000 1.41c.19.2.44.3.7.3s.51-.1.71-.29l7-7c.09-.09.16-.21.21-.33z" /><path fill="none" d="M0 0h24v24H0z" /></svg>
                                        </a>
                                    </div>
                                </nav>
                            </footer>
                        </main>
                
                        <div class="border-t dark:border-dark-650 pt-6 mb-8">
                            <footer class="flex flex-wrap items-center justify-between">
                                <div>
                                    <ul class="flex flex-wrap items-center text-sm">
                                    </ul>
                                </div>
                                <div class="docs-copyright py-2 text-gray-500 dark:text-dark-350 text-sm leading-relaxed"><p>© Copyright 2020 - 2022 KyuHwan Shim, All rights reserved.</p></div>
                            </footer>
                        </div>
                    </div>
                
                    <!-- Rendered if sidebar right is enabled -->
                    <!-- Sidebar right skeleton-->
                    <div v-cloak class="fixed top-0 bottom-0 right-0 translate-x-full bg-white border-gray-200 lg:sticky lg:border-l lg:shrink-0 lg:pt-6 lg:transform-none sm:w-1/2 lg:w-64 lg:z-0 md:w-104 sidebar-right skeleton dark:bg-dark-850 dark:border-dark-650">
                        <div class="pl-5">
                            <div class="w-32 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                            <div class="w-48 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                            <div class="w-40 h-3 mb-4 bg-gray-200 dark:bg-dark-600 rounded-full loading"></div>
                        </div>
                    </div>
                
                    <!-- User should be able to hide sidebar right -->
                    <doc-sidebar-right v-cloak></doc-sidebar-right>
                </div>

            </div>
        </div>
    
        <doc-search-mobile></doc-search-mobile>
        <doc-back-to-top></doc-back-to-top>
    </div>


    <div id="docs-overlay-target"></div>

    <script>window.__DOCS__ = { "title": "Graph", level: 2, icon: "file", hasPrism: true, hasMermaid: false, hasMath: true }</script>
</body>
</html>
